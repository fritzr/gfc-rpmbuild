diff --git a/README.md b/README.md
new file mode 100644
index 00000000000..cf8c736dd34
--- /dev/null
+++ b/README.md
@@ -0,0 +1,146 @@
+Open source fortran compiler for Midas
+======================================
+This repository contains source code for `gfc-gfortran`, a modified version
+of `gfortran`, the open source GNU Fortran Compiler. This version of the
+compiler supports all the DEC extensions used in the old Fortran code present
+in the Midas baseline. With `gfc-gfortran` you can build Midas for free!
+
+About this repository
+=====================
+The contents of this repository only contain _changes_ to the gcc source code
+starting from the gcc-4.8.5 release. Version 4.8.5 is modern and will
+be the default compiler shipped with RHEL/CentOs 7 and Fedora 20. To build this
+version of the compiler you need to independently acquire the gcc source code
+(described below).
+
+This version of gcc is maintained by Fritz Reese <Reese-Fritz@zai.com>. Contact
+him with any questions, problems, or bugs you encounter. In the future,
+these changes will hopefully be included in the gcc baseline and maintained by
+GNU.
+
+Installing the compiler
+=======================
+Binary RPMs are available in the
+[gfc-rpms](http://repo.rincon.com:5000/M50/gfc-rpms) repository which allow
+easy installation of `gfc-gfortran` and related components on x86_64 RedHat
+6/7 systems. For other systems, you must build the compiler from scratch (see
+below).
+
+Building the compiler from scratch
+==================================
+Building this version of the compiler is just like building any version of gcc.
+If you need additional guidance check out the GNU page on
+[Installing GCC: Building](https://gcc.gnu.org/install/build.html). GCC has a
+few dependencies, including:
+```
+glibc-devel
+libgmp-devel
+libmpfr-devel
+libmpc-devel
+```
+If you wish to build for 32-bit compatibility, you must also install the 32-bit
+compatibility package for glibc-devel (e.g. `glibc-devel.i686` on x86_64).
+
+We will assume you have created three directories which this section will
+refer to as `$GCCSRC`, `$GCCDST`, and `$GCCBLD`. These directories will be used
+to contain the compiler sources, temporary build files, and the resulting
+executables and libraries, respectively.
+
+First fetch the original sources from the gcc-4.8.5 release:
+```bash
+wget -O /tmp/gcc-4.8.5.tar.bz2 ftp://gcc.gnu.org/pub/gcc/releases/gcc-4.8.5/gcc-4.8.5.tar.bz2
+bzip2 -cd /tmp/gcc-4.8.5.tar.bz2 | tar --strip-components=1 -C $GCCSRC -xf -
+```
+(Note: The gcc sources are large (~80MB); if you find the download too slow,
+you should try one of the [GNU mirror sites](http://www.gnu.org/prep/ftp.html).
+Just replace [ftp://gcc.gnu.org/pub] with the URL of a site near you.)
+
+Next copy the files from this repository over the regular gcc sources. You can
+use the commands below to do so grabbing the latest version of the gfc-gfortran
+sources from this repository (make sure to replace `$username` with your
+RhodeCode username):
+
+```bash
+cd /tmp
+wget -O gfc-gcc-4.8.5.zip $username@repo.rincon.com:5000/M50/gfc-gfortran/archive/tip.zip
+unzip gfc-gcc-4.8.5.zip # extracts in ./gfc-gfortran-<hash>/
+rsync -raz gfc-gfortran-*/* $GCCSRC
+```
+
+Then simply configure gcc to build the fortran compiler into your `$GCCDST`.
+If you do not have the 32-bit glibc-devel compatibility package installed,
+either install it or add `--disable-multilib` to the configure line.
+
+```bash
+cd $GCCBLD
+$GCCSRC/configure --prefix=$GCCDST --enable-languages=c,c++,fortran --program-prefix=gfc-
+make && make install
+```
+
+As a last step, you will need to update your `PATH` and `LD_LIBRARY_PATH` to
+allow your system to locate the new compiler and supporting libraries. 
+
+With bash, include something like the following in `~/.bashrc`:
+```bash
+export PATH="$GCCDST/bin:$PATH"
+export LD_LIBRARY_PATH="$GCCDST/lib64:$GCCDST/lib:$LD_LIBRARY_PATH"
+```
+
+With tcsh, include something like the following in `~/.tcshrc`:
+```bash
+setenv PATH "$GCCDST/bin":"$PATH"
+setenv LD_LIBRARY_PATH "$GCCDST/lib64":"$GCCDST/lib":"$LD_LIBRARY_PATH"
+```
+
+Congratulations, you can now compile really really really old Fortran code with
+`gfc-gfortran`!
+
+Documentation on new compile flags and DEC extension support can be found by
+placing `$GCCDST/share/man` in `MANPATH` (similar to `PATH` and
+`LD_LIBRARY_PATH`) and running `man gfc-gfortran`. More complete HTML
+documentation is available if you build it:
+
+```bash
+cd $GCCBLD
+make html && make install-html
+firefox $GCCDST/share/doc/gfortran/Optional-DEC-extension-support.html
+```
+
+Using the compiler
+==================
+Midas supports the version of gfortran, gcc and g++ built from the sources
+in this repository since version 4.14.0, including Midas 5.0+. Midas is
+configured to allow the following compilers:
+```
+XM_FORTRAN=gfc-gfortran
+XM_CC=gfc-gcc
+XM_CXX=gfc-g++
+```
+
+By default (for compatibility) this version of the compiler does not interpret
+Fortran code much differently than stock gfortran 4.8.5. Nearly all DEC
+extension support is enabled with the compile-time flag `-fdec`. Midas 5.0
+has been tested with the following flags, which should be in
+`$XMDISK/xm/cfg/build_flags.cfg`:
+
+`fortran: -fPIC -fdec -finit-local-zero -finit-derived -fdollar-ok -fcray-pointer -ffixed-line-length-132 -Wno-argument-mismatch`
+
+If you run into any problems using this version of gfortran with Midas 5.0+
+that you do not encounter with another compiler, please contact Fritz Reese
+<Reese-Fritz@zai.com>.
+
+COPYRIGHT
+=========
+This set of modifications to the GNU Fortran compiler is released under the GNU
+General Public License version 3, published at
+[http://www.gnu.org/licenses/](http://www.gnu.org/licenses/).
+
+I, Fritz Reese, hereby disclaim all copyright interest in my changes and
+enhancements to the GNU Compiler Collection.
+
+I affirm that I have no other intellectual property interest that would
+undermine this release. I represent that these changes and enhancements are my
+own and not a copy of someone else's work.
+
+Fritz Reese
+September 15, 2014
diff --git a/gcc/fortran/ChangeLog b/gcc/fortran/ChangeLog
index 3bc3b96cf10..a4e217f7d49 100644
--- a/gcc/fortran/ChangeLog
+++ b/gcc/fortran/ChangeLog
@@ -158,20 +158,6 @@
 	* decl.c (variable_decl): Reject old style initialization
 	for derived type components.
 
-2014-06-15  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>
-
-	Backport from trunk.
-	PR fortran/45187
-	* trans-decl.c (gfc_create_module_variable): Don't create
-	Cray-pointee decls twice.
-
-2014-05-26  Janne Blomqvist  <jb@gcc.gnu.org>
-
-	Backport from mainline
-	PR libfortran/61310
-	* intrinsics.texi (CTIME): Remove mention of locale-dependent
-	behavior.
-
 2014-05-22  Release Manager
 
 	* GCC 4.8.3 released.
diff --git a/gcc/fortran/check.c b/gcc/fortran/check.c
index c9520f628ea..19847711274 100644
--- a/gcc/fortran/check.c
+++ b/gcc/fortran/check.c
@@ -203,6 +203,25 @@ double_check (gfc_expr *d, int n)
 }
 
 
+/* Make sure the expression is a quad precision real.  */
+
+static gfc_try
+quad_check (gfc_expr *d, int n)
+{
+    if (type_check (d, n, BT_REAL) == FAILURE)
+      return FAILURE;
+
+    if (d->ts.kind != 16)
+      {
+        gfc_error ("'%s' argument of '%s' intrinsic at %L must be quad "
+                   "precision", gfc_current_intrinsic_arg[n]->name,
+                   gfc_current_intrinsic, &d->where);
+        return FAILURE;
+      }
+    
+    return SUCCESS;
+}
+
 static gfc_try
 coarray_check (gfc_expr *e, int n)
 {
@@ -1716,6 +1735,17 @@ gfc_check_fn_d (gfc_expr *a)
   return SUCCESS;
 }
 
+/* A single quad-precision real argument. */
+
+gfc_try
+gfc_check_fn_q (gfc_expr *a)
+{
+    if (quad_check (a, 0) == FAILURE)
+      return FAILURE;
+    
+    return SUCCESS;
+}
+
 /* A single real or complex argument.  */
 
 gfc_try
@@ -2119,7 +2149,7 @@ gfc_check_kill_sub (gfc_expr *pid, gfc_expr *sig, gfc_expr *status)
 gfc_try
 gfc_check_kind (gfc_expr *x)
 {
-  if (x->ts.type == BT_DERIVED)
+  if (gfc_bt_struct (x->ts.type) || x->ts.type == BT_CLASS)
     {
       gfc_error ("'%s' argument of '%s' intrinsic at %L must be a "
 		 "non-derived type", gfc_current_intrinsic_arg[0]->name,
diff --git a/gcc/fortran/class.c b/gcc/fortran/class.c
index 55c072b8235..9841e41fe0f 100644
--- a/gcc/fortran/class.c
+++ b/gcc/fortran/class.c
@@ -71,12 +71,11 @@ insert_component_ref (gfc_typespec *ts, gfc_ref **ref, const char * const name)
   gcc_assert (ts->type == BT_DERIVED || ts->type == BT_CLASS);
   type_sym = ts->u.derived;
 
-  new_ref = gfc_get_ref ();
-  new_ref->type = REF_COMPONENT;
-  new_ref->next = *ref;
-  new_ref->u.c.sym = type_sym;
-  new_ref->u.c.component = gfc_find_component (type_sym, name, true, true);
+  gfc_find_component (type_sym, name, true, true, &new_ref);
   gcc_assert (new_ref->u.c.component);
+  while (new_ref->next)
+    new_ref = new_ref->next;
+  new_ref->next = *ref;
 
   if (new_ref->next)
     {
@@ -199,8 +198,9 @@ gfc_fix_class_refs (gfc_expr *e)
 void
 gfc_add_component_ref (gfc_expr *e, const char *name)
 {
+  gfc_component *c;
   gfc_ref **tail = &(e->ref);
-  gfc_ref *next = NULL;
+  gfc_ref *ref, *next = NULL;
   gfc_symbol *derived = e->symtree->n.sym->ts.u.derived;
   while (*tail != NULL)
     {
@@ -219,14 +219,13 @@ gfc_add_component_ref (gfc_expr *e, const char *name)
     }
   if (*tail != NULL && strcmp (name, "_data") == 0)
     next = *tail;
-  (*tail) = gfc_get_ref();
-  (*tail)->next = next;
-  (*tail)->type = REF_COMPONENT;
-  (*tail)->u.c.sym = derived;
-  (*tail)->u.c.component = gfc_find_component (derived, name, true, true);
-  gcc_assert((*tail)->u.c.component);
+  c = gfc_find_component (derived, name, true, true, tail);
+  gcc_assert (c);
+  for (ref = *tail; ref->next; ref = ref->next)
+    ;
+  ref->next = next;
   if (!next)
-    e->ts = (*tail)->u.c.component->ts;
+    e->ts = c->ts;
 }
 
 
@@ -462,8 +461,7 @@ get_unique_type_string (char *string, gfc_symbol *derived)
   if (derived->attr.unlimited_polymorphic)
     strcpy (dt_name, "STAR");
   else
-    strcpy (dt_name, derived->name);
-  dt_name[0] = TOUPPER (dt_name[0]);
+    strcpy (dt_name, gfc_dt_upper_string (derived->name));
   if (derived->attr.unlimited_polymorphic)
     sprintf (string, "_%s", dt_name);
   else if (derived->module)
@@ -687,7 +685,7 @@ add_proc_comp (gfc_symbol *vtype, const char *name, gfc_typebound_proc *tb)
   if (tb->non_overridable)
     return;
 
-  c = gfc_find_component (vtype, name, true, true);
+  c = gfc_find_component (vtype, name, true, true, NULL);
 
   if (c == NULL)
     {
@@ -754,7 +752,7 @@ copy_vtab_proc_comps (gfc_symbol *declared, gfc_symbol *vtype)
 
   for (cmp = vtab->ts.u.derived->components; cmp; cmp = cmp->next)
     {
-      if (gfc_find_component (vtype, cmp->name, true, true))
+      if (gfc_find_component (vtype, cmp->name, true, true, NULL))
 	continue;
 
       add_proc_comp (vtype, cmp->name, cmp->tb);
@@ -2300,7 +2298,8 @@ gfc_find_derived_vtab (gfc_symbol *derived)
 		  gfc_set_sym_referenced (def_init);
 		  def_init->ts.type = BT_DERIVED;
 		  def_init->ts.u.derived = derived;
-		  def_init->value = gfc_default_initializer (&def_init->ts);
+		  def_init->value = gfc_default_initializer (&def_init->ts,
+                                                             false);
 
 		  c->initializer = gfc_lval_expr_from_sym (def_init);
 		}
@@ -2392,7 +2391,7 @@ gfc_find_derived_vtab (gfc_symbol *derived)
 
 have_vtype:
 	  vtab->ts.u.derived = vtype;
-	  vtab->value = gfc_default_initializer (&vtab->ts);
+	  vtab->value = gfc_default_initializer (&vtab->ts, false);
 	}
     }
 
@@ -2666,7 +2665,7 @@ gfc_find_intrinsic_vtab (gfc_typespec *ts)
 	      c->initializer = gfc_get_null_expr (NULL);
 	    }
 	  vtab->ts.u.derived = vtype;
-	  vtab->value = gfc_default_initializer (&vtab->ts);
+	  vtab->value = gfc_default_initializer (&vtab->ts, false);
 	}
     }
 
diff --git a/gcc/fortran/decl.c b/gcc/fortran/decl.c
index 1bf6175f47b..8f5964a00a1 100644
--- a/gcc/fortran/decl.c
+++ b/gcc/fortran/decl.c
@@ -53,6 +53,7 @@ static gfc_typespec current_ts;
 static symbol_attribute current_attr;
 static gfc_array_spec *current_as;
 static int colon_seen;
+static int attr_seen;
 
 /* The current binding label (if any).  */
 static const char* curr_binding_label;
@@ -93,7 +94,6 @@ gfc_symbol *gfc_new_block;
 
 bool gfc_matching_function;
 
-
 /********************* DATA statement subroutines *********************/
 
 static bool in_match_data = false;
@@ -377,13 +377,13 @@ match_data_constant (gfc_expr **result)
 
   if (sym == NULL
       || (sym->attr.flavor != FL_PARAMETER
-	  && (!dt_sym || dt_sym->attr.flavor != FL_DERIVED)))
+	  && (!dt_sym || !gfc_fl_struct (dt_sym->attr.flavor))))
     {
       gfc_error ("Symbol '%s' must be a PARAMETER in DATA statement at %C",
 		 name);
       return MATCH_ERROR;
     }
-  else if (dt_sym && dt_sym->attr.flavor == FL_DERIVED)
+  else if (dt_sym && gfc_fl_struct (dt_sym->attr.flavor))
     return gfc_match_structure_constructor (dt_sym, result);
 
   /* Check to see if the value is an initialization array expression.  */
@@ -582,6 +582,147 @@ cleanup:
 
 /************************ Declaration statements *********************/
 
+/* Like gfc_match_init_expr, but matches a 'clist' (old-style initialization
+   list). The difference here is the expression is a list of constants
+   and is surrounded by '/'. 
+   The typespec ts must match the typespec of the variable which the
+   clist is initializing.
+   The scalar parameter tells whether this should match a scalar
+   initialization or a list of constants corresponding to array elements. */
+match
+gfc_match_clist_expr (gfc_expr **result, gfc_typespec *ts, gfc_array_spec *as)
+{
+  gfc_constructor_base array_head = NULL;
+  gfc_expr *expr = NULL;
+  match m;
+  locus where;
+  mpz_t repeat, size;
+  bool scalar;
+  int cmp;
+
+  gcc_assert (ts);
+
+  mpz_init_set_ui (repeat, 0);
+  mpz_init (size);
+  scalar = !as || !as->rank;
+
+  /* We have already matched "/". Now look for a constant list, as with
+     top_val_list from decl.c, but append the result to an array constructor. */
+  if (gfc_match ("/") == MATCH_YES)
+  {
+    gfc_error ("Empty old style initializer list at %C");
+    goto cleanup;
+  }
+
+  where = gfc_current_locus;
+  for (;;)
+    {
+      m = match_data_constant (&expr);
+      if (m == MATCH_NO)
+        goto syntax;
+      if (m == MATCH_ERROR)
+        goto cleanup;
+
+      /* Found a repeat specification; match again the actual constant. */
+      if (expr->ts.type == BT_INTEGER && gfc_match_char ('*') == MATCH_YES)
+      {
+        if (scalar)
+        {
+          gfc_error ("Invalid scalar initializer at %C");
+          goto cleanup;
+        }
+        mpz_set (repeat, expr->value.integer);
+        gfc_free_expr (expr);
+        expr = NULL;
+
+        m = match_data_constant (&expr);
+        if (m == MATCH_NO)
+          goto syntax;
+        if (m == MATCH_ERROR)
+          goto cleanup;
+      }
+      else
+        mpz_set_ui (repeat, 1);
+
+      if (!scalar)
+      {
+        /* Add the constant initializer as many times as repeated. */
+        for (; mpz_cmp_ui (repeat, 0) > 0; mpz_sub_ui (repeat, repeat, 1))
+        {
+          /* Make sure types of elements match */
+          if(ts && !gfc_compare_types (&expr->ts, ts)
+                && gfc_convert_type (expr, ts, 1) == FAILURE)
+            goto cleanup;
+
+          gfc_constructor_append_expr (&array_head,
+              gfc_copy_expr (expr), &gfc_current_locus);
+        }
+
+        gfc_free_expr (expr);
+      }
+      /* For scalar initializers quit after one element. */
+      else
+      {
+        if(gfc_match_char ('/') != MATCH_YES)
+        {
+          gfc_error ("End of scalar initializer expected at %C");
+          goto cleanup;
+        }
+        break;
+      }
+
+      if (gfc_match_char ('/') == MATCH_YES)
+        break;
+      if (gfc_match_char (',') == MATCH_NO)
+        goto syntax;
+    }
+
+  /* Set up expr as an array constructor. */
+  if (!scalar)
+  {
+    expr = gfc_get_array_expr (ts->type, ts->kind, &where);
+    expr->ts = *ts;
+    expr->value.constructor = array_head;
+
+    expr->rank = as->rank;
+    expr->shape = gfc_get_shape (expr->rank);
+
+    /* Validate sizes. */
+    gcc_assert (gfc_array_size (expr, &size) == SUCCESS);
+    gcc_assert (spec_size (as, &repeat) == SUCCESS);
+    cmp = mpz_cmp (size, repeat);
+    if (cmp < 0)
+      gfc_error ("Not enough elements in array initializer at %C");
+    else if (cmp > 0)
+      gfc_error ("Too many elements in array initializer at %C");
+    if (cmp)
+      goto cleanup;
+  }
+
+  /* Make sure scalar types match. */
+  else if (!gfc_compare_types (&expr->ts, ts)
+           && gfc_convert_type (expr, ts, 1) == FAILURE)
+    goto cleanup;
+
+  if (expr->ts.u.cl)
+    expr->ts.u.cl->length_from_typespec = 1;
+
+  *result = expr;
+  mpz_clear (size);
+  mpz_clear (repeat);
+  return MATCH_YES;
+
+syntax:
+  gfc_error ("Syntax error in old style initializer list at %C");
+
+cleanup:
+  gfc_constructor_free (array_head);
+  expr->value.constructor = NULL;
+  gfc_free_expr (expr);
+  mpz_clear (size);
+  mpz_clear (repeat);
+  return MATCH_ERROR;
+}
 
 /* Auxiliary function to merge DIMENSION and CODIMENSION array specs.  */
 
@@ -1344,7 +1485,7 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)
 
       /* Check if the assignment can happen. This has to be put off
 	 until later for derived type variables and procedure pointers.  */
-      if (sym->ts.type != BT_DERIVED && init->ts.type != BT_DERIVED
+      if (!gfc_bt_struct (sym->ts.type) && !gfc_bt_struct (init->ts.type)
 	  && sym->ts.type != BT_CLASS && init->ts.type != BT_CLASS
 	  && !sym->attr.proc_pointer
 	  && gfc_check_assign_symbol (sym, NULL, init) == FAILURE)
@@ -1464,7 +1605,7 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)
 	 If we mark my_int as iso_c (since we can see it's value
 	 is equal to one of the named constants), then my_int_2
 	 will be considered C interoperable.  */
-      if (sym->ts.type != BT_CHARACTER && sym->ts.type != BT_DERIVED)
+      if (sym->ts.type != BT_CHARACTER && !gfc_bt_struct (sym->ts.type))
 	{
 	  sym->ts.is_iso_c |= init->ts.is_iso_c;
 	  sym->ts.is_c_interop |= init->ts.is_c_interop;
@@ -1522,6 +1663,7 @@ static gfc_try
 build_struct (const char *name, gfc_charlen *cl, gfc_expr **init,
 	      gfc_array_spec **as)
 {
+  gfc_state_data *s;
   gfc_component *c;
   gfc_try t = SUCCESS;
 
@@ -1545,6 +1687,32 @@ build_struct (const char *name, gfc_charlen *cl, gfc_expr **init,
 	}
     }
 
+  /* If we are in a nested union/map definition, gfc_add_component will not
+     properly find repeated components because they are implicitly chained.
+     Since union and map blocks are not actually linked as components of their
+     parent structures until after they are parsed, we must traverse up the
+     parse stack until we find the top level structure declaration, searching
+     for the component in each block along the way. */
+  s = gfc_state_stack;
+  if (s->state == COMP_UNION || s->state == COMP_MAP)
+  {
+    while (s->state == COMP_UNION || s->state == COMP_MAP
+           || gfc_comp_is_derived (s->state))
+    {
+      c = gfc_find_component (s->sym, name, true, true, NULL);
+      if (c != NULL)
+      {
+        gfc_error_now ("Component '%s' at %C already declared at %L",
+                       name, &c->loc);
+        return FAILURE;
+      }
+      /* Break after we've searched the ultimate parent of the current union. */
+      if (s->state == COMP_DERIVED || s->state == COMP_STRUCTURE)
+        break;
+      s = s->previous;
+    }
+  }
+
   if (gfc_add_component (gfc_current_block (), name, &c) == FAILURE)
     return FAILURE;
 
@@ -1566,51 +1734,7 @@ build_struct (const char *name, gfc_charlen *cl, gfc_expr **init,
     }
   *as = NULL;
 
-  /* Should this ever get more complicated, combine with similar section
-     in add_init_expr_to_sym into a separate function.  */
-  if (c->ts.type == BT_CHARACTER && !c->attr.pointer && c->initializer
-      && c->ts.u.cl
-      && c->ts.u.cl->length && c->ts.u.cl->length->expr_type == EXPR_CONSTANT)
-    {
-      int len;
-
-      gcc_assert (c->ts.u.cl && c->ts.u.cl->length);
-      gcc_assert (c->ts.u.cl->length->expr_type == EXPR_CONSTANT);
-      gcc_assert (c->ts.u.cl->length->ts.type == BT_INTEGER);
-
-      len = mpz_get_si (c->ts.u.cl->length->value.integer);
-
-      if (c->initializer->expr_type == EXPR_CONSTANT)
-	gfc_set_constant_character_len (len, c->initializer, -1);
-      else if (mpz_cmp (c->ts.u.cl->length->value.integer,
-			c->initializer->ts.u.cl->length->value.integer))
-	{
-	  gfc_constructor *ctor;
-	  ctor = gfc_constructor_first (c->initializer->value.constructor);
-
-	  if (ctor)
-	    {
-	      int first_len;
-	      bool has_ts = (c->initializer->ts.u.cl
-			     && c->initializer->ts.u.cl->length_from_typespec);
-
-	      /* Remember the length of the first element for checking
-		 that all elements *in the constructor* have the same
-		 length.  This need not be the length of the LHS!  */
-	      gcc_assert (ctor->expr->expr_type == EXPR_CONSTANT);
-	      gcc_assert (ctor->expr->ts.type == BT_CHARACTER);
-	      first_len = ctor->expr->value.character.length;
-
-	      for ( ; ctor; ctor = gfc_constructor_next (ctor))
-		if (ctor->expr->expr_type == EXPR_CONSTANT)
-		{
-		  gfc_set_constant_character_len (len, ctor->expr,
-						  has_ts ? -1 : first_len);
-		  ctor->expr->ts.u.cl->length = gfc_copy_expr (c->ts.u.cl->length);
-		}
-	    }
-	}
-    }
+  gfc_apply_init (&c->ts, &c->attr, c->initializer);
 
   /* Check array components.  */
   if (!c->attr.dimension)
@@ -1727,7 +1851,7 @@ match_pointer_init (gfc_expr **init, int procptr)
 {
   match m;
 
-  if (gfc_pure (NULL) && gfc_state_stack->state != COMP_DERIVED)
+  if (gfc_pure (NULL) && !gfc_comp_is_derived(gfc_state_stack->state))
     {
       gfc_error ("Initialization of pointer at %C is not allowed in "
 		 "a PURE procedure");
@@ -1798,6 +1922,7 @@ static match
 variable_decl (int elem)
 {
   char name[GFC_MAX_SYMBOL_LEN + 1];
+  static int fill_id = 0;
   gfc_expr *initializer, *char_len;
   gfc_array_spec *as;
   gfc_array_spec *cp_as; /* Extra copy for Cray Pointees.  */
@@ -1815,9 +1940,44 @@ variable_decl (int elem)
   /* When we get here, we've just matched a list of attributes and
      maybe a type and a double colon.  The next thing we expect to see
      is the name of the symbol.  */
-  m = gfc_match_name (name);
+
+  /* If we are parsing a structure, we allow the name of the symbol to
+     be '%FILL', which gives it an anonymous (inaccessible) name. */
+  m = MATCH_NO;
+  gfc_gobble_whitespace ();
+  if (gfc_peek_ascii_char () == '%')
+  {
+    gfc_next_ascii_char ();
+    m = gfc_match ("fill");
+  }
   if (m != MATCH_YES)
-    goto cleanup;
+  {
+    m = gfc_match_name (name);
+    if (m != MATCH_YES)
+      goto cleanup;
+  }
+  else 
+  {
+    m = MATCH_ERROR;
+    if (!gfc_option.flag_dec_structure)
+    {
+      gfc_error ("%%FILL at %C is an extension, enable with -fdec-structure");
+      goto cleanup;
+    }
+    if (gfc_current_state () != COMP_STRUCTURE)
+    {
+      gfc_error ("Unnamed field at %C only allowed in a STRUCTURE block");
+      goto cleanup;
+    }
+    if (attr_seen)
+    {
+      gfc_error ("Unnamed field at %C may not have attributes");
+      goto cleanup;
+    }
+    /* The unique anonymous name is an invalid fortran identifier. */
+    sprintf (name, "%%FILL%d", fill_id++);
+    m = MATCH_YES;
+  }
 
   var_locus = gfc_current_locus;
 
@@ -1902,10 +2062,19 @@ variable_decl (int elem)
 	}
     }
 
+  /* Fill components may not have initializers. */
+  if (name[0] == '%' && gfc_match_eos () != MATCH_YES) 
+  {
+    gfc_error ("Unnamed field at %C may not have initializers");
+    m = MATCH_ERROR;
+    goto cleanup;
+  }
+
   /*  If this symbol has already shown up in a Cray Pointer declaration,
       and this is not a component declaration,
       then we want to set the type & bail out.  */
-  if (gfc_option.flag_cray_pointer && gfc_current_state () != COMP_DERIVED)
+  if (gfc_option.flag_cray_pointer
+      && !gfc_comp_is_derived (gfc_current_state ()))
     {
       gfc_find_symbol (name, gfc_current_ns, 1, &sym);
       if (sym != NULL && sym->attr.cray_pointee)
@@ -1970,7 +2139,7 @@ variable_decl (int elem)
      For components of derived types, it is not true, so we don't
      create a symbol for those yet.  If we fail to create the symbol,
      bail out.  */
-  if (gfc_current_state () != COMP_DERIVED
+  if (!gfc_comp_is_derived (gfc_current_state ())
       && build_sym (name, cl, cl_deferred, &as, &var_locus) == FAILURE)
     {
       m = MATCH_ERROR;
@@ -1997,15 +2166,33 @@ variable_decl (int elem)
       if (gfc_notify_std (GFC_STD_GNU, "Old-style "
 			  "initialization at %C") == FAILURE)
 	return MATCH_ERROR;
+      /* Allow old style initializations for STRUCTURE/MAP declarations but
+         not derived TYPE declarations (matches DEC/Intel behavior). */
       else if (gfc_current_state () == COMP_DERIVED)
-	{
-	  gfc_error ("Invalid old style initialization for derived type "
-		     "component at %C");
-	  m = MATCH_ERROR;
-	  goto cleanup;
-	}
+        {
+          gfc_error ("Invalid old style initialization for derived type "
+                     "component at %C");
+          m = MATCH_ERROR;
+          goto cleanup;
+        }
+
+      /* For derived type components, read the initializer as a special
+         expression and let the rest of this function apply the initializer
+         as usual. */
+      else if (gfc_comp_is_derived (gfc_current_state ()))
+      {
+        m = gfc_match_clist_expr (&initializer, &current_ts, as);
+        if (m == MATCH_NO)
+          gfc_error ("Syntax error in old style initialization of "
+                     "structure component %s at %C", name);
+        if (m != MATCH_YES)
+          goto cleanup;
+      }
 
-      return match_old_style_init (name);
+      /* Otherwise we treat the old style initialization just like a
+         DATA declaration for the current variable. */
+      else
+        return match_old_style_init (name);
     }
 
   /* The double colon must be present in order to have initializers.
@@ -2043,7 +2230,7 @@ variable_decl (int elem)
 	    }
 
 	  if (current_attr.flavor != FL_PARAMETER && gfc_pure (NULL)
-	      && gfc_state_stack->state != COMP_DERIVED)
+	      && !gfc_comp_is_derived (gfc_state_stack->state))
 	    {
 	      gfc_error ("Initialization of variable at %C is not allowed in "
 			 "a PURE procedure");
@@ -2051,7 +2238,7 @@ variable_decl (int elem)
 	    }
 
 	  if (current_attr.flavor != FL_PARAMETER
-	      && gfc_state_stack->state != COMP_DERIVED)
+	      && !gfc_comp_is_derived(gfc_state_stack->state))
 	    gfc_unset_implicit_pure (gfc_current_ns->proc_name);
 
 	  if (m != MATCH_YES)
@@ -2060,7 +2247,7 @@ variable_decl (int elem)
     }
 
   if (initializer != NULL && current_attr.allocatable
-	&& gfc_current_state () == COMP_DERIVED)
+	&& gfc_comp_is_derived (gfc_current_state ()))
     {
       gfc_error ("Initialization of allocatable component at %C is not "
 		 "allowed");
@@ -2071,14 +2258,20 @@ variable_decl (int elem)
   /* Add the initializer.  Note that it is fine if initializer is
      NULL here, because we sometimes also need to check if a
      declaration *must* have an initialization expression.  */
-  if (gfc_current_state () != COMP_DERIVED)
+  if (!gfc_comp_is_derived (gfc_current_state ()))
     t = add_init_expr_to_sym (name, &initializer, &var_locus);
   else
     {
       if (current_ts.type == BT_DERIVED
 	  && !current_attr.pointer && !initializer)
-	initializer = gfc_default_initializer (&current_ts);
+	initializer = gfc_default_initializer (&current_ts, false);
       t = build_struct (name, cl, &initializer, &as);
+
+      /* If we match a nested structure definition we expect to see the
+         body even if the component declarations blow up, so we need to keep
+         the structure type around.  */
+      if (gfc_new_block && gfc_new_block->attr.flavor == FL_STRUCT)
+        gfc_commit_symbol (gfc_new_block);
     }
 
   m = (t == SUCCESS) ? MATCH_YES : MATCH_ERROR;
@@ -2565,6 +2758,35 @@ done:
   return MATCH_YES;
 }
 
+/* Matches a RECORD declaration. */
+
+static match
+match_record_decl(const char *name)
+{
+    locus old_loc;
+    old_loc = gfc_current_locus;
+
+    if (gfc_match (" record") == MATCH_YES)
+    {
+        if (!gfc_option.flag_dec_structure)
+        {
+            gfc_current_locus = old_loc;
+            gfc_error ("RECORD at %C is a DEC extension, enable with "
+                       "-fdec-structure");
+            return MATCH_ERROR;
+        }
+        if (gfc_match (" /%n/", name) != MATCH_YES)
+        {
+            gfc_error ("Expected \"/field-name/\" after RECORD at %C");
+            gfc_current_locus = old_loc;
+            return MATCH_ERROR;
+        }
+        return MATCH_YES;
+    }
+
+    gfc_current_locus = old_loc;
+    return MATCH_NO;
+}
 
 /* Matches a declaration-type-spec (F03:R502).  If successful, sets the ts
    structure to the matched specification.  This is necessary for FUNCTION and
@@ -2624,7 +2846,7 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)
 	{
 	  if ((m = gfc_match ("*)")) != MATCH_YES)
 	    return m;
-	  if (gfc_current_state () == COMP_DERIVED)
+	  if (gfc_comp_is_derived (gfc_current_state ()))
 	    {
 	      gfc_error ("Assumed type at %C is not allowed for components");
 	      return MATCH_ERROR;
@@ -2737,9 +2959,57 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)
     m = gfc_match_char (')');
 
   if (m == MATCH_YES)
+  {
     ts->type = BT_DERIVED;
+    /* Don't need all the extra derived-type stuff for structures. */
+    if (gfc_find_symbol (gfc_dt_upper_string (name), NULL, 1, &sym))
+    {
+      gfc_error ("Type name '%s' at %C is ambiguous", name);
+      return MATCH_ERROR;
+    }
+    if (sym && sym->attr.flavor == FL_STRUCT)
+    {
+      ts->u.derived = sym;
+      return MATCH_YES;
+    }
+  }
   else
     {
+      /* Match RECORD declarations. */
+      m = match_record_decl (name);
+      if (m == MATCH_YES)
+      {
+        ts->type = BT_DERIVED;
+        /* Don't need all the extra derived-type stuff for structures. */
+        if (gfc_find_symbol (gfc_dt_upper_string (name), NULL, 1, &sym))
+        {
+          gfc_error ("Type name '%s' at %C is ambiguous", name);
+          return MATCH_ERROR;
+        }
+        if (sym && sym->attr.flavor == FL_STRUCT)
+        {
+          ts->u.derived = sym;
+          return MATCH_YES;
+        }
+        goto derived;
+      }
+
+      /* Match ad-hoc STRUCTURE declarations; only valid within another
+         derived/structure declaration. */
+      m = gfc_match (" structure");
+      if (m == MATCH_YES && gfc_comp_is_derived (gfc_current_state ()))
+      {
+        m = gfc_match_structure_decl ();
+        if (m == MATCH_YES)
+        {
+          /* gfc_new_block updated by match_structure_decl() */
+          ts->type = BT_DERIVED;
+          ts->u.derived = gfc_new_block;
+          return MATCH_YES;
+        }
+        return MATCH_ERROR;
+      }
+
       /* Match CLASS declarations.  */
       m = gfc_match (" class ( * )");
       if (m == MATCH_ERROR)
@@ -2788,6 +3058,7 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)
 	return MATCH_ERROR;
     }
 
+derived:
   /* Defer association of the derived type until the end of the
      specification block.  However, if the derived type can be
      found, add it to the typespec.  */
@@ -2809,9 +3080,7 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)
      stored in a symtree with the first letter of the name capitalized; the
      symtree with the all lower-case name contains the associated
      generic function.  */
-  dt_name = gfc_get_string ("%c%s",
-			    (char) TOUPPER ((unsigned char) name[0]),
-			    (const char*)&name[1]);
+  dt_name = gfc_dt_upper_string (name);
   sym = NULL;
   dt_sym = NULL;
   if (ts->kind != -1)
@@ -2843,7 +3112,7 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)
 	return MATCH_NO;
     }
 
-  if ((sym->attr.flavor != FL_UNKNOWN
+  if ((sym->attr.flavor != FL_UNKNOWN && sym->attr.flavor != FL_STRUCT
        && !(sym->attr.flavor == FL_PROCEDURE && sym->attr.generic))
       || sym->attr.subroutine)
     {
@@ -2883,9 +3152,8 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)
 
   gfc_set_sym_referenced (dt_sym);
 
-  if (dt_sym->attr.flavor != FL_DERIVED
-      && gfc_add_flavor (&dt_sym->attr, FL_DERIVED, sym->name, NULL)
-			 == FAILURE)
+  if (dt_sym->attr.flavor != FL_DERIVED && dt_sym->attr.flavor != FL_STRUCT
+      && gfc_add_flavor (&dt_sym->attr, FL_DERIVED, sym->name, NULL) == FAILURE)
     return MATCH_ERROR;
 
   ts->u.derived = dt_sym;
@@ -3246,9 +3514,7 @@ gfc_match_import (void)
 		 letter of the name capitalized; the symtree with the all
 		 lower-case name contains the associated generic function. */
 	      st = gfc_new_symtree (&gfc_current_ns->sym_root,
-			gfc_get_string ("%c%s",
-				(char) TOUPPER ((unsigned char) name[0]),
-				&name[1]));
+                                    gfc_dt_upper_string (name));
 	      st->n.sym = sym;
 	      sym->refs++;
 	      sym->attr.imported = 1;
@@ -3312,6 +3578,7 @@ match_attr_spec (void)
     DECL_ALLOCATABLE = GFC_DECL_BEGIN, DECL_DIMENSION, DECL_EXTERNAL,
     DECL_IN, DECL_OUT, DECL_INOUT, DECL_INTRINSIC, DECL_OPTIONAL,
     DECL_PARAMETER, DECL_POINTER, DECL_PROTECTED, DECL_PRIVATE,
+    DECL_STATIC, DECL_AUTOMATIC,
     DECL_PUBLIC, DECL_SAVE, DECL_TARGET, DECL_VALUE, DECL_VOLATILE,
     DECL_IS_BIND_C, DECL_CODIMENSION, DECL_ASYNCHRONOUS, DECL_CONTIGUOUS,
     DECL_NONE, GFC_DECL_END /* Sentinel */
@@ -3332,6 +3599,7 @@ match_attr_spec (void)
 
   current_as = NULL;
   colon_seen = 0;
+  attr_seen = 0;
 
   /* See if we get all of the keywords up to the final double colon.  */
   for (d = GFC_DECL_BEGIN; d != GFC_DECL_END; d++)
@@ -3375,6 +3643,14 @@ match_attr_spec (void)
 		      d = DECL_ASYNCHRONOUS;
 		    }
 		  break;
+
+                case 'u':
+                  if (match_string_p ("tomatic"))
+                    {
+                      /* Matched "automatic". */
+                      d = DECL_AUTOMATIC;
+                    }
+                  break;
 		}
 	      break;
 
@@ -3503,8 +3779,25 @@ match_attr_spec (void)
 	      break;
 
 	    case 's':
-	      if (match_string_p ("save"))
-		d = DECL_SAVE;
+	      gfc_next_ascii_char ();
+	      switch (gfc_next_ascii_char ())
+                {
+                  case 'a':
+                  if (match_string_p ("ve"))
+                    {
+                      /* Matched "save". */
+                      d = DECL_SAVE;
+                    }
+                  break;
+
+                  case 't':
+                  if (match_string_p ("atic"))
+                    {
+                      /* Matched "static". */
+                      d = DECL_STATIC;
+                    }
+                  break;
+                }
 	      break;
 
 	    case 't':
@@ -3641,6 +3934,12 @@ match_attr_spec (void)
 	  case DECL_SAVE:
 	    attr = "SAVE";
 	    break;
+          case DECL_STATIC:
+            attr = "STATIC";
+            break;
+          case DECL_AUTOMATIC:
+            attr = "AUTOMATIC";
+            break;
 	  case DECL_TARGET:
 	    attr = "TARGET";
 	    break;
@@ -3668,8 +3967,22 @@ match_attr_spec (void)
     {
       if (seen[d] == 0)
 	continue;
+      else
+        attr_seen = 1;
+
+      if ((d == DECL_STATIC || d == DECL_AUTOMATIC)
+          && !gfc_option.flag_dec_static)
+      {
+        gfc_error ("%s at %L is a DEC extension, enable with -fdec-static",
+                   d == DECL_STATIC ? "STATIC" : "AUTOMATIC", &seen_at[d]);
+        m = MATCH_ERROR;
+        goto cleanup;
+      }
+      /* Allow SAVE with STATIC, but don't complain. */
+      if (d == DECL_STATIC && seen[DECL_SAVE])
+        continue;
 
-      if (gfc_current_state () == COMP_DERIVED
+      if (gfc_comp_is_derived (gfc_current_state ())
 	  && d != DECL_DIMENSION && d != DECL_CODIMENSION
 	  && d != DECL_POINTER   && d != DECL_PRIVATE
 	  && d != DECL_PUBLIC && d != DECL_CONTIGUOUS && d != DECL_NONE)
@@ -3677,7 +3990,8 @@ match_attr_spec (void)
 	  if (d == DECL_ALLOCATABLE)
 	    {
 	      if (gfc_notify_std (GFC_STD_F2003, "ALLOCATABLE "
-				  "attribute at %C in a TYPE definition")
+				  "attribute at %C in a %s definition",
+                                  gfc_ascii_comp_state(gfc_current_state()))
 		  == FAILURE)
 		{
 		  m = MATCH_ERROR;
@@ -3686,8 +4000,8 @@ match_attr_spec (void)
 	    }
 	  else
 	    {
-	      gfc_error ("Attribute at %L is not allowed in a TYPE definition",
-			 &seen_at[d]);
+	      gfc_error ("Attribute at %L is not allowed in a %s definition",
+			&seen_at[d], gfc_ascii_comp_state(gfc_current_state()));
 	      m = MATCH_ERROR;
 	      goto cleanup;
 	    }
@@ -3700,13 +4014,14 @@ match_attr_spec (void)
 	    attr = "PRIVATE";
 	  else
 	    attr = "PUBLIC";
-	  if (gfc_current_state () == COMP_DERIVED
+	  if (gfc_comp_is_derived (gfc_current_state ())
 	      && gfc_state_stack->previous
 	      && gfc_state_stack->previous->state == COMP_MODULE)
 	    {
 	      if (gfc_notify_std (GFC_STD_F2003, "Attribute %s "
-				  "at %L in a TYPE definition", attr,
-				  &seen_at[d])
+				  "at %L in a %s definition", attr,
+				  &seen_at[d],
+                                  gfc_ascii_comp_state(gfc_current_state()))
 		  == FAILURE)
 		{
 		  m = MATCH_ERROR;
@@ -3813,10 +4128,15 @@ match_attr_spec (void)
 			      &seen_at[d]);
 	  break;
 
+        case DECL_STATIC:
 	case DECL_SAVE:
 	  t = gfc_add_save (&current_attr, SAVE_EXPLICIT, NULL, &seen_at[d]);
 	  break;
 
+        case DECL_AUTOMATIC:
+          t = gfc_add_automatic (&current_attr, NULL, &seen_at[d]);
+          break;
+
 	case DECL_TARGET:
 	  t = gfc_add_target (&current_attr, &seen_at[d]);
 	  break;
@@ -3866,6 +4186,7 @@ cleanup:
   gfc_current_locus = start;
   gfc_free_array_spec (current_as);
   current_as = NULL;
+  attr_seen = 0;
   return m;
 }
 
@@ -3918,7 +4239,7 @@ set_com_block_bind_c (gfc_common_head *com_block, int is_bind_c)
 gfc_try
 gfc_verify_c_interop (gfc_typespec *ts)
 {
-  if (ts->type == BT_DERIVED && ts->u.derived != NULL)
+  if (gfc_bt_struct (ts->type) && ts->u.derived != NULL)
     return (ts->u.derived->ts.is_c_interop || ts->u.derived->attr.is_bind_c)
 	   ? SUCCESS : FAILURE;
   else if (ts->type == BT_CLASS)
@@ -4008,7 +4329,8 @@ verify_bind_c_sym (gfc_symbol *tmp_sym, gfc_typespec *ts,
 	    }
 	  else
 	    {
-              if (tmp_sym->ts.type == BT_DERIVED || ts->type == BT_DERIVED)
+              if (gfc_bt_struct (tmp_sym->ts.type) 
+                  || gfc_bt_struct (ts->type))
                 gfc_error ("Type declaration '%s' at %L is not C "
                            "interoperable but it is BIND(C)",
                            tmp_sym->name, &(tmp_sym->declared_at));
@@ -4270,7 +4592,7 @@ gfc_match_data_decl (void)
     return m;
 
   if ((current_ts.type == BT_DERIVED || current_ts.type == BT_CLASS)
-	&& gfc_current_state () != COMP_DERIVED)
+	&& !gfc_comp_is_derived(gfc_current_state ()))
     {
       sym = gfc_use_derived (current_ts.u.derived);
 
@@ -4299,7 +4621,7 @@ gfc_match_data_decl (void)
       && !current_ts.u.derived->attr.zero_comp)
     {
 
-      if (current_attr.pointer && gfc_current_state () == COMP_DERIVED)
+      if (current_attr.pointer && gfc_comp_is_derived (gfc_current_state ()))
 	goto ok;
 
       gfc_find_symbol (current_ts.u.derived->name,
@@ -4307,9 +4629,10 @@ gfc_match_data_decl (void)
 
       /* Any symbol that we find had better be a type definition
 	 which has its components defined.  */
-      if (sym != NULL && sym->attr.flavor == FL_DERIVED
+      if (sym != NULL && gfc_fl_struct (sym->attr.flavor)
 	  && (current_ts.u.derived->components != NULL
-	      || current_ts.u.derived->attr.zero_comp))
+	      || current_ts.u.derived->attr.zero_comp
+              || current_ts.u.derived == gfc_new_block))
 	goto ok;
 
       /* Now we have an error, which we signal, and then fix up
@@ -5211,6 +5534,7 @@ gfc_match_procedure (void)
     case COMP_INTERFACE:
       m = match_procedure_in_interface ();
       break;
+    case COMP_STRUCTURE:
     case COMP_DERIVED:
       m = match_ppc_decl ();
       break;
@@ -5458,6 +5782,10 @@ gfc_match_entry (void)
 	    gfc_error ("ENTRY statement at %C cannot appear within "
 		       "an INTERFACE");
 	    break;
+          case COMP_STRUCTURE:
+            gfc_error ("ENTRY statement at %C cannot appear within "
+                       "a STRUCTURE block");
+            break;
 	  case COMP_DERIVED:
 	    gfc_error ("ENTRY statement at %C cannot appear within "
 		       "a DERIVED TYPE block");
@@ -6043,6 +6371,24 @@ gfc_match_end (gfc_statement *st)
       eos_ok = 0;
       break;
 
+    case COMP_MAP:
+      *st = ST_END_MAP;
+      target = " map";
+      eos_ok = 0;
+      break;
+
+    case COMP_UNION:
+      *st = ST_END_UNION;
+      target = " union";
+      eos_ok = 0;
+      break;
+
+    case COMP_STRUCTURE:
+      *st = ST_END_STRUCTURE;
+      target = " structure";
+      eos_ok = 0;
+      break;
+
     case COMP_DERIVED:
     case COMP_DERIVED_CONTAINS:
       *st = ST_END_TYPE;
@@ -7007,10 +7353,16 @@ cleanup:
 match
 gfc_match_parameter (void)
 {
+  const char *term = " )%t";
   match m;
 
   if (gfc_match_char ('(') == MATCH_NO)
-    return MATCH_NO;
+    {
+      /* With legacy PARAMETER statements, don't expect a terminating ')'.  */
+      if (!gfc_notify_std (GFC_STD_LEGACY, "PARAMETER without '()' at %C"))
+        return MATCH_NO;
+      term = " %t";
+    }
 
   for (;;)
     {
@@ -7018,7 +7370,7 @@ gfc_match_parameter (void)
       if (m != MATCH_YES)
 	break;
 
-      if (gfc_match (" )%t") == MATCH_YES)
+      if (gfc_match (term) == MATCH_YES)
 	break;
 
       if (gfc_match_char (',') != MATCH_YES)
@@ -7033,6 +7385,110 @@ gfc_match_parameter (void)
 }
 
 
+match
+gfc_match_automatic (void)
+{
+  gfc_symbol *sym;
+  match m;
+  bool seen_symbol = false;
+
+  if (!gfc_option.flag_dec_static)
+  {
+    gfc_error ("AUTOMATIC at %C is a DEC extension, enable with -fdec-static");
+    return MATCH_ERROR;
+  }
+
+  gfc_match (" ::");
+
+  for (;;)
+    {
+      m = gfc_match_symbol (&sym, 0);
+      switch (m)
+	{
+        case MATCH_NO:
+	case MATCH_ERROR:
+	  return MATCH_ERROR;
+
+	case MATCH_YES:
+	  if (gfc_add_automatic (&sym->attr, sym->name, &gfc_current_locus)
+              == FAILURE)
+	    return MATCH_ERROR;
+          seen_symbol = true;
+	  break;
+	}
+
+      if (gfc_match_eos () == MATCH_YES)
+	break;
+      if (gfc_match_char (',') != MATCH_YES)
+	goto syntax;
+    }
+
+  if (!seen_symbol)
+  {
+    gfc_error ("Expected var-list in AUTOMATIC statement at %C");
+    return MATCH_ERROR;
+  }
+
+  return MATCH_YES;
+
+syntax:
+  gfc_error ("Syntax error in AUTOMATIC statement at %C");
+  return MATCH_ERROR;
+}
+
+
+match
+gfc_match_static (void)
+{
+  gfc_symbol *sym;
+  match m;
+  bool seen_symbol = false;
+
+  if (!gfc_option.flag_dec_static)
+  {
+    gfc_error ("STATIC at %C is a DEC extension, enable with -fdec-static");
+    return MATCH_ERROR;
+  }
+
+  gfc_match (" ::");
+
+  for (;;)
+    {
+      m = gfc_match_symbol (&sym, 0);
+      switch (m)
+	{
+        case MATCH_NO:
+	case MATCH_ERROR:
+	  return MATCH_ERROR;
+
+	case MATCH_YES:
+	  if (gfc_add_save (&sym->attr, SAVE_EXPLICIT, sym->name,
+			    &gfc_current_locus) == FAILURE)
+	    return MATCH_ERROR;
+          seen_symbol = true;
+	  break;
+	}
+
+      if (gfc_match_eos () == MATCH_YES)
+	break;
+      if (gfc_match_char (',') != MATCH_YES)
+	goto syntax;
+    }
+
+  if (!seen_symbol)
+  {
+    gfc_error ("Expected var-list in STATIC statement at %C");
+    return MATCH_ERROR;
+  }
+
+  return MATCH_YES;
+
+syntax:
+  gfc_error ("Syntax error in STATIC statement at %C");
+  return MATCH_ERROR;
+}
+
+
 /* Save statements have a special syntax.  */
 
 match
@@ -7515,6 +7971,308 @@ gfc_get_type_attr_spec (symbol_attribute *attr, char *name)
   return MATCH_YES;
 }
 
+/* Common function for type declaration blocks similar to derived types, such
+   as STRUCTURES and MAPs. Unlike derived types, a structure type
+   does NOT have a generic symbol matching the name given by the user.
+   STRUCTUREs can share names with variables and PARAMETERs so we must allow
+   for the creation of an independent symbol.
+   Other parameters are a message to prefix errors with, the name of the new 
+   type to be created, and the flavor to add to the resulting symbol. */
+
+static gfc_try
+get_struct_decl (const char *name, sym_flavor fl, locus *decl,
+                 gfc_symbol **result)
+{
+  gfc_symbol *sym;
+  locus where;
+
+  if (decl)
+    where = *decl;
+  else
+    where = gfc_current_locus;
+
+  if (gfc_get_symbol (name, NULL, &sym))
+    return FAILURE;
+
+  sym->declared_at = where;
+
+  gcc_assert (name[0] == (char) TOUPPER (name[0]));
+
+  if (sym && (sym->components != NULL || sym->attr.zero_comp))
+  {
+    gfc_error ("Type definition of '%s' at %C was already defined at %L", 
+               sym->name, &sym->declared_at);
+    return FAILURE;
+  }
+
+  if (!sym)
+  {
+    gfc_internal_error ("Failed to create structure type '%s' at %C", name);
+    return FAILURE;
+  }
+
+  if (sym->attr.flavor != fl
+      && gfc_add_flavor (&sym->attr, fl, sym->name, NULL) == FAILURE)
+    return FAILURE;
+
+  if (!sym->hash_value)
+      /* Set the hash for the compound name for this type.  */
+    sym->hash_value = gfc_hash_value (sym);
+
+  /* Normally the type is expected to have been completely parsed by the time
+     a field declaration with this type is seen. For unions, maps, and nested
+     structure declarations, we need to indicate that it is okay that we
+     haven't seen any components yet. This will be updated after the structure
+     is fully parsed. */
+  sym->attr.zero_comp = 0;
+
+  /* Structures always act like derived-types with the SEQUENCE attribute */
+  gfc_add_sequence (&sym->attr, sym->name, NULL);
+
+  if (result) *result = sym;
+
+  return SUCCESS;
+}
+
+match
+gfc_match_map (void)
+{
+    /* Counter used to give unique internal names to map declarations. */
+    static unsigned int gfc_map_id = 0;
+    char name[GFC_MAX_SYMBOL_LEN + 1];
+    gfc_symbol *sym;
+    locus old_loc;
+
+    old_loc = gfc_current_locus;
+
+    if (gfc_current_state () != COMP_UNION)
+    {
+        gfc_current_locus = old_loc;
+        gfc_error ("MAP statement at %C illegal outside of union declaration");
+        return MATCH_ERROR;
+    }
+    if (gfc_match_eos () != MATCH_YES)
+    {
+        gfc_error ("Expected end of statement at %C after MAP statement");
+        gfc_current_locus = old_loc;
+        return MATCH_ERROR;
+    }
+
+    /* Make up a unique name for the map to store it in the symbol table. */
+    snprintf (name, GFC_MAX_SYMBOL_LEN + 1, "MM$%u", gfc_map_id++);
+
+    if (get_struct_decl (name, FL_STRUCT, &old_loc, &sym) == FAILURE)
+      return MATCH_ERROR;
+
+    gfc_new_block = sym;
+
+    return MATCH_YES;
+}
+
+match
+gfc_match_union (void)
+{
+    /* Counter used to give unique internal names to union declarations. */
+    static unsigned int gfc_union_id = 0;
+    char name[GFC_MAX_SYMBOL_LEN + 1];
+    gfc_symbol *sym;
+    locus old_loc;
+
+    old_loc = gfc_current_locus;
+
+    if (!gfc_comp_is_derived (gfc_current_state ()))
+    {
+        gfc_current_locus = old_loc;
+        gfc_error ("UNION statement at %C illegal outside of structure "
+                   "declaration");
+        return MATCH_ERROR;
+    }
+    if (gfc_match_eos () != MATCH_YES)
+    {
+        gfc_error ("Expected end of statement at %C after UNION statement");
+        gfc_current_locus = old_loc;
+        return MATCH_ERROR;
+    }
+
+    snprintf (name, GFC_MAX_SYMBOL_LEN + 1, "UU$%u", gfc_union_id++);
+    if (get_struct_decl (name, FL_UNION, &old_loc, &sym) == FAILURE)
+      return MATCH_ERROR;
+
+    gfc_new_block = sym;
+
+    return MATCH_YES;
+}
+
+/* Match the beginning of a structure declaration. This is similar to
+   matching the beginning of a derived type declaration, but the resulting
+   symbol has no access control or other interesting attributes. 
+   
+   If we are inside another structure declaration, we expect a field list
+   after the name of the structure. For example, in the following structure,
+   appointments have members START and END which are of ad-hoc structure type.
+   STRUCTURE /APPOINTMENT/ 
+     STRUCTURE /TIME/ START, END
+       INTEGER*1 HOUR, MINUTE, SECOND
+     END STRUCTURE
+     ...
+   END STRUCTURE
+   */
+
+match
+gfc_match_structure_decl (void)
+{
+    /* Counter used to give anonymous structures unique internal names. */
+    static unsigned int gfc_structure_id = 0;
+    char name[GFC_MAX_SYMBOL_LEN + 1];
+    gfc_symbol *sym;
+    match m;
+    locus where;
+
+    if(!gfc_option.flag_dec_structure)
+    {
+        gfc_error ("STRUCTURE at %C is a DEC extension, enable with "
+                   "-fdec-structure");
+        return MATCH_ERROR;
+    }
+
+    name[0] = '\0';
+
+    m = gfc_match (" /%n/", name);
+    if (m != MATCH_YES)
+    {
+        /* Non-nested structure declarations require a structure name. */
+        if (!gfc_comp_is_derived (gfc_current_state ()))
+        {
+            gfc_error ("Structure name expected in non-nested structure "
+                       "declaration at %C");
+            return MATCH_ERROR;
+        }
+        /* This is an anonymous structure; make up a unique name for it
+           (upper-case letters never make it to symbol names from the source).
+           The important thing is initializing the type declaration variable
+           and setting gfc_new_symbol, which is immediately used by
+           parse_structure () and variable_decl () to add fields of this type
+           and add components. */
+        snprintf (name, GFC_MAX_SYMBOL_LEN + 1, "SS$%u", gfc_structure_id++);
+    }
+    where = gfc_current_locus;
+    /* No field list allowed after non-nested structure declaration. */
+    if (!gfc_comp_is_derived (gfc_current_state ()) && gfc_match_eos () != MATCH_YES)
+    {
+        gfc_error ("Field list at %C illegal in non-nested structure "
+                   "declaration");
+        return MATCH_ERROR;
+    }
+
+    /* Make sure the name is not the name of an intrinsic type.  */
+    if (gfc_is_intrinsic_typename (name))
+    {
+      gfc_error ("Structure name '%s' at %C cannot be the same as an intrinsic "
+                 "type", name);
+      return MATCH_ERROR;
+    }
+
+    sprintf (name, gfc_dt_upper_string (name));
+    if (get_struct_decl (name, FL_STRUCT, &where, &sym) == FAILURE)
+      return MATCH_ERROR;
+
+    gfc_new_block = sym;
+    return MATCH_YES;
+}
+
+
+/* This function does some work to determine which matcher should be used to
+ * match a statement beginning with "TYPE". This is used to disambiguate TYPE
+ * as an alias for PRINT from derived type declarations, TYPE IS statements,
+ * and derived type data declarations.  */
+
+match
+gfc_match_type (gfc_statement *st)
+{
+  char name[GFC_MAX_SYMBOL_LEN + 1];
+  match m;
+  locus old_loc;
+
+  /* Requires -ftype-print.  */
+  if (!gfc_option.flag_type_print)
+    return MATCH_NO;
+
+  m = gfc_match ("type");
+  if (m != MATCH_YES)
+    return m;
+  /* If we already have an error in the buffer, it is probably from failing to
+   * match a derived type data declaration. Let it happen.  */
+  else if (gfc_error_flag_test ())
+    return MATCH_NO;
+
+  old_loc = gfc_current_locus;
+  *st = ST_NONE;
+
+  /* If we see an attribute list before anything else it's definitely a derived
+   * type declaration.  */
+  if (gfc_match (" ,") == MATCH_YES || gfc_match (" ::") == MATCH_YES)
+    {
+      gfc_current_locus = old_loc;
+      *st = ST_DERIVED_DECL;
+      return gfc_match_derived_decl ();
+    }
+
+  /* By now "TYPE" has already been matched. If we do not see a name, this may
+   * be something like "TYPE *" or "TYPE <fmt>".  */
+  m = gfc_match_name (name);
+  if (m != MATCH_YES)
+    {
+      /* Let print match if it can, otherwise throw an error from
+       * gfc_match_derived_decl.  */
+      gfc_current_locus = old_loc;
+      if (gfc_match_print () == MATCH_YES)
+        {
+          *st = ST_WRITE;
+          return MATCH_YES;
+        }
+      gfc_current_locus = old_loc;
+      *st = ST_DERIVED_DECL;
+      return gfc_match_derived_decl ();
+    }
+
+  /* A derived type declaration requires an EOS. Without it, assume print.  */
+  m = gfc_match_eos ();
+  if (m == MATCH_NO)
+    {
+      /* Check manually for TYPE IS (... - this is invalid print syntax.  */
+      if (strncmp ("is", name, 3) == 0
+          && gfc_match (" (", name) == MATCH_YES)
+        {
+          gfc_current_locus = old_loc;
+          gcc_assert (gfc_match (" is") == MATCH_YES);
+          *st = ST_TYPE_IS;
+          return gfc_match_type_is ();
+        }
+      gfc_current_locus = old_loc;
+      *st = ST_WRITE;
+      return gfc_match_print ();
+    }
+  else
+    {
+      /* By now we have "TYPE <name> <EOS>". Check first if the name is an
+       * intrinsic typename - if so let gfc_match_derived_decl dump an error.
+       * Otherwise if gfc_match_derived_decl fails it's probably an existing
+       * symbol which can be printed.  */
+      gfc_current_locus = old_loc;
+      m = gfc_match_derived_decl ();
+      if (gfc_is_intrinsic_typename (name) || m == MATCH_YES)
+        {
+          *st = ST_DERIVED_DECL;
+          return m;
+        }
+      gfc_current_locus = old_loc;
+      *st = ST_WRITE;
+      return gfc_match_print ();
+    }
+
+  return MATCH_NO;
+}
+
 
 /* Match the beginning of a derived type declaration.  If a type name
    was the result of a function, then it is possible to have a symbol
@@ -7531,9 +8289,10 @@ gfc_match_derived_decl (void)
   match m;
   match is_type_attr_spec = MATCH_NO;
   bool seen_attr = false;
+  locus where;
   gfc_interface *intr = NULL, *head;
 
-  if (gfc_current_state () == COMP_DERIVED)
+  if (gfc_comp_is_derived (gfc_current_state ()))
     return MATCH_NO;
 
   name[0] = '\0';
@@ -7565,7 +8324,11 @@ gfc_match_derived_decl (void)
       return MATCH_ERROR;
     }
 
-  m = gfc_match (" %n%t", name);
+  m = gfc_match (" %n", name);
+  if (m != MATCH_YES)
+    return m;
+  where = gfc_current_locus;
+  m = gfc_match_eos ();
   if (m != MATCH_YES)
     return m;
 
@@ -7619,6 +8382,7 @@ gfc_match_derived_decl (void)
       intr->next = head;
       gensym->generic = intr;
       gensym->attr.if_source = IFSRC_DECL;
+      gensym->declared_at = where;
     }
 
   /* The symbol may already have the derived attribute without the
@@ -7663,7 +8427,7 @@ gfc_match_derived_decl (void)
 
       p->ts.type = BT_DERIVED;
       p->ts.u.derived = extended;
-      p->initializer = gfc_default_initializer (&p->ts);
+      p->initializer = gfc_default_initializer (&p->ts, false);
 
       /* Set extension level.  */
       if (extended->attr.extension == 255)
@@ -7690,6 +8454,13 @@ gfc_match_derived_decl (void)
   /* Take over the ABSTRACT attribute.  */
   sym->attr.abstract = attr.abstract;
 
+  /* Normally the type is expected to have been completely parsed by the time
+     a field declaration with this type is seen. For unions, maps, and nested
+     structure declarations, we need to indicate that it is okay that we
+     haven't seen any components yet. This will be updated after the structure
+     is fully parsed. */
+  sym->attr.zero_comp = sym->components == NULL;
+
   gfc_new_block = sym;
 
   return MATCH_YES;
diff --git a/gcc/fortran/dump-parse-tree.c b/gcc/fortran/dump-parse-tree.c
index 501a4ebb566..06d9e6cf475 100644
--- a/gcc/fortran/dump-parse-tree.c
+++ b/gcc/fortran/dump-parse-tree.c
@@ -47,6 +47,7 @@ static FILE *dumpfile;
 static void show_expr (gfc_expr *p);
 static void show_code_node (int, gfc_code *);
 static void show_namespace (gfc_namespace *ns);
+static void show_symbol (gfc_symbol *sym);
 
 
 /* Allow dumping of an expression in the debugger.  */
@@ -109,6 +110,10 @@ show_typespec (gfc_typespec *ts)
       fprintf (dumpfile, "%s", ts->u.derived->name);
       break;
 
+    case BT_UNION:
+      fprintf (dumpfile, "%s", ts->u.derived->name);
+      break;
+
     case BT_CHARACTER:
       if (ts->u.cl)
 	show_expr (ts->u.cl->length);
@@ -700,9 +705,11 @@ show_components (gfc_symbol *sym)
 {
   gfc_component *c;
 
+  ++show_level;
   for (c = sym->components; c; c = c->next)
     {
-      fprintf (dumpfile, "(%s ", c->name);
+      show_indent ();
+      fprintf (dumpfile, "%s ", c->name);
       show_typespec (&c->ts);
       if (c->attr.allocatable)
 	fputs (" ALLOCATABLE", dumpfile);
@@ -716,10 +723,14 @@ show_components (gfc_symbol *sym)
       show_array_spec (c->as);
       if (c->attr.access)
 	fprintf (dumpfile, " %s", gfc_code2string (access_types, c->attr.access));
-      fputc (')', dumpfile);
-      if (c->next != NULL)
-	fputc (' ', dumpfile);
+      if (c->initializer)
+      {
+        fprintf (dumpfile, " (init ");
+        show_expr (c->initializer);
+        fprintf (dumpfile, ")");
+      }
     }
+  --show_level;
 }
 
 
@@ -845,13 +856,6 @@ show_symbol (gfc_symbol *sym)
   fputs ("attributes: ", dumpfile);
   show_attr (&sym->attr, sym->module);
 
-  if (sym->value)
-    {
-      show_indent ();
-      fputs ("value: ", dumpfile);
-      show_expr (sym->value);
-    }
-
   if (sym->as)
     {
       show_indent ();
@@ -873,13 +877,6 @@ show_symbol (gfc_symbol *sym)
       fprintf (dumpfile, "result: %s", sym->result->name);
     }
 
-  if (sym->components)
-    {
-      show_indent ();
-      fputs ("components: ", dumpfile);
-      show_components (sym);
-    }
-
   if (sym->f2k_derived)
     {
       show_indent ();
@@ -910,6 +907,20 @@ show_symbol (gfc_symbol *sym)
       fputs ("Formal namespace", dumpfile);
       show_namespace (sym->formal_ns);
     }
+
+  if (sym->value)
+    {
+      show_indent ();
+      fputs ("value: ", dumpfile);
+      show_expr (sym->value);
+    }
+
+  if (sym->components)
+    {
+      show_indent ();
+      fputs ("components: ", dumpfile);
+      show_components (sym);
+    }
   --show_level;
 }
 
diff --git a/gcc/fortran/expr.c b/gcc/fortran/expr.c
index 0e89a4ce98a..5b874afb155 100644
--- a/gcc/fortran/expr.c
+++ b/gcc/fortran/expr.c
@@ -333,9 +333,9 @@ gfc_copy_expr (gfc_expr *p)
 
 	case BT_HOLLERITH:
 	case BT_LOGICAL:
-	case BT_DERIVED:
 	case BT_CLASS:
 	case BT_ASSUMED:
+        case_struct_bt:
 	  break;		/* Already done.  */
 
 	case BT_PROCEDURE:
@@ -1640,7 +1640,8 @@ simplify_const_ref (gfc_expr *p)
 
 	    case AR_FULL:
 	      if (p->ref->next != NULL
-		  && (p->ts.type == BT_CHARACTER || p->ts.type == BT_DERIVED))
+		  && (p->ts.type == BT_CHARACTER 
+                      || gfc_bt_struct (p->ts.type)))
 		{
 		  for (c = gfc_constructor_first (p->value.constructor);
 		       c; c = gfc_constructor_next (c))
@@ -1650,7 +1651,7 @@ simplify_const_ref (gfc_expr *p)
 			return FAILURE;
 		    }
 
-		  if (p->ts.type == BT_DERIVED
+		  if (gfc_bt_struct (p->ts.type)
 			&& p->ref->next
 			&& (c = gfc_constructor_first (p->value.constructor)))
 		    {
@@ -2674,6 +2675,208 @@ gfc_match_init_expr (gfc_expr **result)
   return MATCH_YES;
 }
 
+/* Build an initializer for a local integer, real, complex, logical, or
+   character variable, based on the command line flags finit-local-zero,
+   finit-integer=, finit-real=, and finit-logical=. */
+gfc_expr *
+gfc_build_default_init_expr (gfc_typespec *ts, locus *where)
+{
+  int char_len;
+  int i;
+  gfc_expr *init_expr;
+
+  init_expr = gfc_get_constant_expr (ts->type, ts->kind, where);
+
+  /* We will only initialize integers, reals, complex, logicals, and
+     characters, and only if the corresponding command-line flags
+     were set.  Otherwise, we free init_expr and return null.  */
+  switch (ts->type)
+    {
+    case BT_INTEGER:
+      if (gfc_option.flag_init_integer != GFC_INIT_INTEGER_OFF)
+	mpz_set_si (init_expr->value.integer,
+			 gfc_option.flag_init_integer_value);
+      else
+	{
+	  gfc_free_expr (init_expr);
+	  init_expr = NULL;
+	}
+      break;
+
+    case BT_REAL:
+      switch (gfc_option.flag_init_real)
+	{
+	case GFC_INIT_REAL_SNAN:
+	  init_expr->is_snan = 1;
+	  /* Fall through.  */
+	case GFC_INIT_REAL_NAN:
+	  mpfr_set_nan (init_expr->value.real);
+	  break;
+
+	case GFC_INIT_REAL_INF:
+	  mpfr_set_inf (init_expr->value.real, 1);
+	  break;
+
+	case GFC_INIT_REAL_NEG_INF:
+	  mpfr_set_inf (init_expr->value.real, -1);
+	  break;
+
+	case GFC_INIT_REAL_ZERO:
+	  mpfr_set_ui (init_expr->value.real, 0.0, GFC_RND_MODE);
+	  break;
+
+	default:
+	  gfc_free_expr (init_expr);
+	  init_expr = NULL;
+	  break;
+	}
+      break;
+
+    case BT_COMPLEX:
+      switch (gfc_option.flag_init_real)
+	{
+	case GFC_INIT_REAL_SNAN:
+	  init_expr->is_snan = 1;
+	  /* Fall through.  */
+	case GFC_INIT_REAL_NAN:
+	  mpfr_set_nan (mpc_realref (init_expr->value.complex));
+	  mpfr_set_nan (mpc_imagref (init_expr->value.complex));
+	  break;
+
+	case GFC_INIT_REAL_INF:
+	  mpfr_set_inf (mpc_realref (init_expr->value.complex), 1);
+	  mpfr_set_inf (mpc_imagref (init_expr->value.complex), 1);
+	  break;
+
+	case GFC_INIT_REAL_NEG_INF:
+	  mpfr_set_inf (mpc_realref (init_expr->value.complex), -1);
+	  mpfr_set_inf (mpc_imagref (init_expr->value.complex), -1);
+	  break;
+
+	case GFC_INIT_REAL_ZERO:
+	  mpc_set_ui (init_expr->value.complex, 0, GFC_MPC_RND_MODE);
+	  break;
+
+	default:
+	  gfc_free_expr (init_expr);
+	  init_expr = NULL;
+	  break;
+	}
+      break;
+
+    case BT_LOGICAL:
+      if (gfc_option.flag_init_logical == GFC_INIT_LOGICAL_FALSE)
+	init_expr->value.logical = 0;
+      else if (gfc_option.flag_init_logical == GFC_INIT_LOGICAL_TRUE)
+	init_expr->value.logical = 1;
+      else
+	{
+	  gfc_free_expr (init_expr);
+	  init_expr = NULL;
+	}
+      break;
+
+    case BT_CHARACTER:
+      /* For characters, the length must be constant in order to
+	 create a default initializer.  */
+      if (gfc_option.flag_init_character == GFC_INIT_CHARACTER_ON
+	  && ts->u.cl->length
+	  && ts->u.cl->length->expr_type == EXPR_CONSTANT)
+	{
+	  char_len = mpz_get_si (ts->u.cl->length->value.integer);
+	  init_expr->value.character.length = char_len;
+	  init_expr->value.character.string = gfc_get_wide_string (char_len+1);
+	  for (i = 0; i < char_len; i++)
+	    init_expr->value.character.string[i]
+	      = (unsigned char) gfc_option.flag_init_character_value;
+	}
+      else
+	{
+	  gfc_free_expr (init_expr);
+	  init_expr = NULL;
+	}
+      if (!init_expr && gfc_option.flag_init_character == GFC_INIT_CHARACTER_ON
+	  && ts->u.cl->length && gfc_option.flag_max_stack_var_size != 0)
+	{
+	  gfc_actual_arglist *arg;
+	  init_expr = gfc_get_expr ();
+	  init_expr->where = *where;
+	  init_expr->ts = *ts;
+	  init_expr->expr_type = EXPR_FUNCTION;
+	  init_expr->value.function.isym =
+		gfc_intrinsic_function_by_id (GFC_ISYM_REPEAT);
+	  init_expr->value.function.name = "repeat";
+	  arg = gfc_get_actual_arglist ();
+	  arg->expr = gfc_get_character_expr (ts->kind, where, NULL, 1);
+	  arg->expr->value.character.string[0]
+		= gfc_option.flag_init_character_value;
+	  arg->next = gfc_get_actual_arglist ();
+	  arg->next->expr = gfc_copy_expr (ts->u.cl->length);
+	  init_expr->value.function.actual = arg;
+	}
+      break;
+
+    default:
+     gfc_free_expr (init_expr);
+     init_expr = NULL;
+    }
+
+  return init_expr;
+}
+
+
+/* Apply an initialization expression to a typespec.
+   Can be used for both symbols and components.
+   Similar to add_init_expr_to_sym in decl.c; could probably be combined with
+   some effort. */
+void
+gfc_apply_init (gfc_typespec *ts, symbol_attribute *attr, gfc_expr *init)
+{
+  if (ts->type == BT_CHARACTER && !attr->pointer && init
+      && ts->u.cl
+      && ts->u.cl->length && ts->u.cl->length->expr_type == EXPR_CONSTANT)
+    {
+      int len;
+
+      gcc_assert (ts->u.cl && ts->u.cl->length);
+      gcc_assert (ts->u.cl->length->expr_type == EXPR_CONSTANT);
+      gcc_assert (ts->u.cl->length->ts.type == BT_INTEGER);
+
+      len = mpz_get_si (ts->u.cl->length->value.integer);
+
+      if (init->expr_type == EXPR_CONSTANT)
+	gfc_set_constant_character_len (len, init, -1);
+      else if (mpz_cmp (ts->u.cl->length->value.integer,
+			init->ts.u.cl->length->value.integer))
+	{
+	  gfc_constructor *ctor;
+	  ctor = gfc_constructor_first (init->value.constructor);
+
+	  if (ctor)
+	    {
+	      int first_len;
+	      bool has_ts = (init->ts.u.cl
+			     && init->ts.u.cl->length_from_typespec);
+
+	      /* Remember the length of the first element for checking
+		 that all elements *in the constructor* have the same
+		 length.  This need not be the length of the LHS!  */
+	      gcc_assert (ctor->expr->expr_type == EXPR_CONSTANT);
+	      gcc_assert (ctor->expr->ts.type == BT_CHARACTER);
+	      first_len = ctor->expr->value.character.length;
+
+	      for ( ; ctor; ctor = gfc_constructor_next (ctor))
+		if (ctor->expr->expr_type == EXPR_CONSTANT)
+		{
+		  gfc_set_constant_character_len (len, ctor->expr,
+						  has_ts ? -1 : first_len);
+		  ctor->expr->ts.u.cl->length = gfc_copy_expr (ts->u.cl->length);
+		}
+	    }
+	}
+    }
+}
+
 
 /* Given an actual argument list, test to see that each argument is a
    restricted expression and optionally if the expression type is
@@ -3859,9 +4062,10 @@ gfc_has_default_initializer (gfc_symbol *der)
 {
   gfc_component *c;
 
-  gcc_assert (der->attr.flavor == FL_DERIVED);
+  gcc_assert (gfc_fl_struct (der->attr.flavor));
   for (c = der->components; c; c = c->next)
-    if (c->ts.type == BT_DERIVED)
+  {
+    if (gfc_bt_struct (c->ts.type))
       {
         if (!c->attr.pointer
 	     && gfc_has_default_initializer (c->ts.u.derived))
@@ -3874,26 +4078,124 @@ gfc_has_default_initializer (gfc_symbol *der)
         if (c->initializer)
 	  return true;
       }
+  }
 
   return false;
 }
 
 
-/* Get an expression for a default initializer.  */
+/* Only the last initializer in a union matters. */
+static gfc_expr *
+get_last_init (gfc_symbol *uniont, gfc_component **mapp)
+{
+  gfc_component *map;
+  gfc_expr *init=NULL, *init2;
+  for (map = uniont->components; map; map = map->next)
+  {
+    if (!gfc_has_default_initializer (map->ts.u.derived))
+      continue;
+
+    init2 = gfc_default_initializer (&map->ts, false);
+    if (!init2)
+      continue;
+
+    if (init)
+    {
+      gfc_warning_now ("Initializer in map at %L overwritten by initializer in "
+                       "map at %L in union", &init->where, &init2->where);
+      gfc_free_expr (init);
+    }
+
+    init = init2;
+    if (mapp) *mapp = map;
+  }
+  if (!init) *mapp = NULL;
+  return init;
+}
+
+
+/* Fetch or generate an initializer for the given component.
+   Only generate an initializer if generate is true. */
+
+static gfc_expr *
+component_init (gfc_component *c, bool generate)
+{
+  gfc_component *map = NULL;
+  gfc_expr *init = NULL;
+
+  if (c->initializer) return c->initializer;
+
+  /* Recursively handle derived type components */
+  if (generate && (c->ts.type == BT_DERIVED || c->ts.type == BT_CLASS))
+    init = gfc_default_initializer (&c->ts, true);
+
+  else if (c->ts.type == BT_UNION && c->ts.u.derived->components)
+  {
+    /* TODO: keep _all_ map initializers here, and squash them together
+       during the translation phase (in trans-expr.c:gfc_conv_structure?)
+       to allow non-overlapping initializers across maps. */
+
+    /* Try to take an existing initializer from a map. */
+    gfc_constructor *ctor;
+    init = get_last_init (c->ts.u.derived, &map);
+
+    if (!map)
+    {
+      gcc_assert (init == NULL);
+      /* If no maps had an explicit initializer, and generate is not set, then
+         this union has no initializer. Otherwise generate an initializer from
+         the first map. */
+      /* TODO: Use the largest map / initialize the entire union.
+         This can only be determined in translation (?) */
+      if (!generate)
+        return NULL;
+      map = c->ts.u.derived->components;
+      init = gfc_default_initializer (&map->ts, true);
+    }
+
+    ctor = gfc_constructor_get ();
+    ctor->expr = init;
+    ctor->n.component = map;
+
+    init = gfc_get_structure_constructor_expr (c->ts.type, c->ts.kind, &c->loc);
+    init->ts = c->ts;
+    gfc_constructor_append (&init->value.constructor, ctor);
+  }
+
+  /* Simple components */
+  else if (generate)
+  {
+    init = gfc_build_default_init_expr (&c->ts, &c->loc);
+    gfc_apply_init (&c->ts, &c->attr, init);
+  }
+
+  return init;
+}
+
+
+/* Get an expression for a default initializer of a derived type. 
+   If -finit-derived is specified, generate default initialization expressions
+   for components that lack them as with gfc_build_default_init_expr. */
 
 gfc_expr *
-gfc_default_initializer (gfc_typespec *ts)
+gfc_default_initializer (gfc_typespec *ts, bool generate)
 {
-  gfc_expr *init;
+  gfc_expr *init, *tmp;
   gfc_component *comp;
+  generate = gfc_option.flag_init_derived && generate;
 
   /* See if we have a default initializer in this, but not in nested
-     types (otherwise we could use gfc_has_default_initializer()).  */
-  for (comp = ts->u.derived->components; comp; comp = comp->next)
-    if (comp->initializer || comp->attr.allocatable
-	|| (comp->ts.type == BT_CLASS && CLASS_DATA (comp)
-	    && CLASS_DATA (comp)->attr.allocatable))
-      break;
+     types (otherwise we could use gfc_has_default_initializer()).
+     We don't need to check if we are going to generate them. */
+  comp = ts->u.derived->components;
+  if (!generate)
+  {
+    for (; comp; comp = comp->next)
+      if (comp->initializer || comp->attr.allocatable
+          || (comp->ts.type == BT_CLASS && CLASS_DATA (comp)
+              && CLASS_DATA (comp)->attr.allocatable))
+        break;
+  }
 
   if (!comp)
     return NULL;
@@ -3906,11 +4208,14 @@ gfc_default_initializer (gfc_typespec *ts)
     {
       gfc_constructor *ctor = gfc_constructor_get();
 
-      if (comp->initializer)
+      /* Fetch or generate an initializer for the component.  */
+      tmp = component_init (comp, generate);
+      if (tmp)
 	{
-	  ctor->expr = gfc_copy_expr (comp->initializer);
-	  if ((comp->ts.type != comp->initializer->ts.type
-	       || comp->ts.kind != comp->initializer->ts.kind)
+          /* If the initializer was not generated, we need a copy.  */
+          ctor->expr = comp->initializer ? gfc_copy_expr (tmp) : tmp;
+	  if ((comp->ts.type != tmp->ts.type
+	       || comp->ts.kind != tmp->ts.kind)
 	      && !comp->attr.pointer && !comp->attr.proc_pointer)
 	    gfc_convert_type_warn (ctor->expr, &comp->ts, 2, false);
 	}
diff --git a/gcc/fortran/f95-lang.c b/gcc/fortran/f95-lang.c
index 60d790b0858..0803b65f923 100644
--- a/gcc/fortran/f95-lang.c
+++ b/gcc/fortran/f95-lang.c
@@ -570,6 +570,7 @@ gfc_define_builtin (const char *name, tree type, enum built_in_function code,
     DO_DEFINE_MATH_BUILTIN (code, name, argtype, mfunc_) \
     DO_DEFINE_MATH_BUILTIN (C##code, "c" name, argtype, mfunc_c)
 
+#define MATH_ALIAS_BUILTIN(newid, id, name, type)
 
 /* Create function types for builtin functions.  */
 
@@ -1046,6 +1047,7 @@ gfc_init_builtin_functions (void)
   targetm.init_builtins ();
 }
 
+#undef MATH_ALIAS_BUILTIN
 #undef DEFINE_MATH_BUILTIN_C
 #undef DEFINE_MATH_BUILTIN
 
diff --git a/gcc/fortran/frontend-passes.c b/gcc/fortran/frontend-passes.c
index 7bbdac81b9e..8c62d83a969 100644
--- a/gcc/fortran/frontend-passes.c
+++ b/gcc/fortran/frontend-passes.c
@@ -1852,6 +1852,8 @@ gfc_code_walker (gfc_code **c, walk_code_fn_t codefn, walk_expr_fn_t exprfn,
 	      WALK_SUBEXPR (co->ext.open->asynchronous);
 	      WALK_SUBEXPR (co->ext.open->id);
 	      WALK_SUBEXPR (co->ext.open->newunit);
+	      WALK_SUBEXPR (co->ext.open->share);
+	      WALK_SUBEXPR (co->ext.open->cc);
 	      break;
 
 	    case EXEC_CLOSE:
diff --git a/gcc/fortran/gfortran.h b/gcc/fortran/gfortran.h
index 2428b519b20..3fd6bcf3770 100644
--- a/gcc/fortran/gfortran.h
+++ b/gcc/fortran/gfortran.h
@@ -49,7 +49,18 @@ along with GCC; see the file COPYING3.  If not see
 #define MAX_SUBRECORD_LENGTH 2147483639   /* 2**31-9 */
 
 
-#define gfc_is_whitespace(c) ((c==' ') || (c=='\t'))
+#define gfc_is_whitespace(c) ((c==' ') || (c=='\t') \
+                              || (gfc_option.flag_feed && c=='\f'))
+
+/* Common macros to check structure-like types and flavors, since things like
+   STRUCTURES, MAPs and UNIONs are often treated similarly. */
+
+#define gfc_bt_struct(t) \
+  ((t) == BT_DERIVED || (t) == BT_UNION)
+#define gfc_fl_struct(f) \
+  ((f) == FL_DERIVED || (f) == FL_UNION || (f) == FL_STRUCT)
+#define case_struct_bt case BT_DERIVED: case BT_UNION
+#define case_struct_fl case FL_DERIVED: case FL_UNION: case FL_STRUCT
 
 /* Stringization.  */
 #define stringize(x) expand_macro(x)
@@ -202,6 +213,7 @@ typedef enum
   ST_END_FILE, ST_FINAL, ST_FLUSH, ST_END_FORALL, ST_END_FUNCTION, ST_ENDIF,
   ST_END_INTERFACE, ST_END_MODULE, ST_END_PROGRAM, ST_END_SELECT,
   ST_END_SUBROUTINE, ST_END_WHERE, ST_END_TYPE, ST_ENTRY, ST_EQUIVALENCE,
+  ST_END_STRUCTURE,
   ST_ERROR_STOP, ST_EXIT, ST_FORALL, ST_FORALL_BLOCK, ST_FORMAT, ST_FUNCTION,
   ST_GOTO, ST_IF_BLOCK, ST_IMPLICIT, ST_IMPLICIT_NONE, ST_IMPORT,
   ST_INQUIRE, ST_INTERFACE, ST_SYNC_ALL, ST_SYNC_MEMORY, ST_SYNC_IMAGES,
@@ -210,6 +222,7 @@ typedef enum
   ST_STOP, ST_SUBROUTINE, ST_TYPE, ST_USE, ST_WHERE_BLOCK, ST_WHERE, ST_WAIT,
   ST_WRITE, ST_ASSIGNMENT, ST_POINTER_ASSIGNMENT, ST_SELECT_CASE, ST_SEQUENCE,
   ST_SIMPLE_IF, ST_STATEMENT_FUNCTION, ST_DERIVED_DECL, ST_LABEL_ASSIGNMENT,
+  ST_STRUCTURE_DECL, ST_UNION, ST_END_UNION, ST_MAP, ST_END_MAP,
   ST_ENUM, ST_ENUMERATOR, ST_END_ENUM, ST_SELECT_TYPE, ST_TYPE_IS, ST_CLASS_IS,
   ST_OMP_ATOMIC, ST_OMP_BARRIER, ST_OMP_CRITICAL, ST_OMP_END_ATOMIC,
   ST_OMP_END_CRITICAL, ST_OMP_END_DO, ST_OMP_END_MASTER, ST_OMP_END_ORDERED,
@@ -234,12 +247,12 @@ typedef enum
 interface_type;
 
 /* Symbol flavors: these are all mutually exclusive.
-   10 elements = 4 bits.  */
+   12 elements = 4 bits.  */
 typedef enum sym_flavor
 {
   FL_UNKNOWN = 0, FL_PROGRAM, FL_BLOCK_DATA, FL_MODULE, FL_VARIABLE,
   FL_PARAMETER, FL_LABEL, FL_PROCEDURE, FL_DERIVED, FL_NAMELIST,
-  FL_VOID
+  FL_UNION, FL_STRUCT, FL_VOID
 }
 sym_flavor;
 
@@ -339,6 +352,7 @@ enum gfc_isym_id
   GFC_ISYM_CONVERSION,
   GFC_ISYM_COS,
   GFC_ISYM_COSH,
+  GFC_ISYM_COTAN,
   GFC_ISYM_COUNT,
   GFC_ISYM_CPU_TIME,
   GFC_ISYM_CSHIFT,
@@ -587,6 +601,13 @@ init_local_integer;
 
 typedef enum
 {
+  GFC_INIT_DERIVED_OFF = 0,
+  GFC_INIT_DERIVED_ON
+}
+init_derived;
+
+typedef enum
+{
   GFC_FCOARRAY_NONE = 0,
   GFC_FCOARRAY_SINGLE,
   GFC_FCOARRAY_LIB
@@ -702,7 +723,7 @@ typedef struct
     optional:1, pointer:1, target:1, value:1, volatile_:1, temporary:1,
     dummy:1, result:1, assign:1, threadprivate:1, not_always_present:1,
     implied_index:1, subref_array_pointer:1, proc_pointer:1, asynchronous:1,
-    contiguous:1;
+    contiguous:1, automatic:1;
 
   /* For CLASS containers, the pointer attribute is sometimes set internally
      even though it was not directly specified.  In this case, keep the
@@ -922,7 +943,7 @@ typedef struct
 
   union
   {
-    struct gfc_symbol *derived;	/* For derived types only.  */
+    struct gfc_symbol *derived;	/* For derived types or unions.  */
     gfc_charlen *cl;		/* For character types only.  */
     int pad;			/* For hollerith types only.  */
   }
@@ -976,6 +997,9 @@ typedef struct gfc_component
 
   /* Needed for procedure pointer components.  */
   struct gfc_typebound_proc *tb;
+
+  /* Pointer to MAP list for union types. */
+  struct gfc_symbol *maps;
 }
 gfc_component;
 
@@ -1991,7 +2015,9 @@ typedef struct
 {
   gfc_expr *unit, *file, *status, *access, *form, *recl,
     *blank, *position, *action, *delim, *pad, *iostat, *iomsg, *convert,
-    *decimal, *encoding, *round, *sign, *asynchronous, *id, *newunit;
+    *decimal, *encoding, *round, *sign, *asynchronous, *id, *newunit, *share,
+    *cc;
+  int readonly : 1;
   gfc_st_label *err;
 }
 gfc_open;
@@ -2256,6 +2282,9 @@ typedef struct
   int warn_realloc_lhs_all;
   int warn_compare_reals;
   int warn_target_lifetime;
+  int warn_argument_mismatch;
+  int warn_format_tab;
+  int warn_missing_include_dirs;
   int max_errors;
 
   int flag_all_intrinsics;
@@ -2290,6 +2319,7 @@ typedef struct
   int flag_module_private;
   int flag_recursive;
   int flag_init_local_zero;
+  int flag_init_derived;
   int flag_init_integer;
   int flag_init_integer_value;
   int flag_init_real;
@@ -2302,6 +2332,19 @@ typedef struct
   int flag_realloc_lhs;
   int flag_aggressive_function_elimination;
   int flag_frontend_optimize;
+  int flag_dec_extended_int;
+  int flag_dec_structure;
+  int flag_dec_member_dot;
+  int flag_dec_math;
+  int flag_dec_logical_xor;
+  int flag_dec_bitwise_ops;
+  int flag_dec_io;
+  int flag_dec_intrinsic_ints;
+  int flag_dec_static;
+  int flag_lazy_logicals;
+  int flag_loc_rval;
+  int flag_feed;
+  int flag_type_print;
 
   int fpe;
   int rtcheck;
@@ -2523,6 +2566,7 @@ gfc_try gfc_check_any_c_kind (gfc_typespec *);
 int gfc_validate_kind (bt, int, bool);
 int gfc_get_int_kind_from_width_isofortranenv (int size);
 int gfc_get_real_kind_from_width_isofortranenv (int size);
+tree gfc_get_union_type (gfc_symbol *);
 tree gfc_get_derived_type (gfc_symbol * derived);
 extern int gfc_index_integer_kind;
 extern int gfc_default_integer_kind;
@@ -2568,6 +2612,7 @@ gfc_try gfc_add_cray_pointee (symbol_attribute *, locus *);
 match gfc_mod_pointee_as (gfc_array_spec *);
 gfc_try gfc_add_protected (symbol_attribute *, const char *, locus *);
 gfc_try gfc_add_result (symbol_attribute *, const char *, locus *);
+gfc_try gfc_add_automatic (symbol_attribute *, const char *, locus *);
 gfc_try gfc_add_save (symbol_attribute *, save_state, const char *, locus *);
 gfc_try gfc_add_threadprivate (symbol_attribute *, const char *, locus *);
 gfc_try gfc_add_saved_common (symbol_attribute *, locus *);
@@ -2610,7 +2655,8 @@ gfc_try gfc_copy_attr (symbol_attribute *, symbol_attribute *, locus *);
 gfc_try gfc_add_component (gfc_symbol *, const char *, gfc_component **);
 gfc_symbol *gfc_use_derived (gfc_symbol *);
 gfc_symtree *gfc_use_derived_tree (gfc_symtree *);
-gfc_component *gfc_find_component (gfc_symbol *, const char *, bool, bool);
+gfc_component *gfc_find_component (gfc_symbol *, const char *, bool, bool,
+                                   gfc_ref **);
 
 gfc_st_label *gfc_get_st_label (int);
 void gfc_free_st_label (gfc_st_label *);
@@ -2786,7 +2832,9 @@ gfc_try gfc_check_pointer_assign (gfc_expr *, gfc_expr *);
 gfc_try gfc_check_assign_symbol (gfc_symbol *, gfc_component *, gfc_expr *);
 
 bool gfc_has_default_initializer (gfc_symbol *);
-gfc_expr *gfc_default_initializer (gfc_typespec *);
+gfc_expr *gfc_default_initializer (gfc_typespec *, bool);
+gfc_expr *gfc_build_default_init_expr (gfc_typespec *, locus *);
+void gfc_apply_init (gfc_typespec *, symbol_attribute *, gfc_expr *);
 gfc_expr *gfc_get_variable_expr (gfc_symtree *);
 void gfc_add_full_array_ref (gfc_expr *, gfc_array_spec *);
 gfc_expr * gfc_lval_expr_from_sym (gfc_symbol *);
@@ -2880,6 +2928,7 @@ gfc_try gfc_ref_dimen_size (gfc_array_ref *, int dimen, mpz_t *, mpz_t *);
 
 /* interface.c -- FIXME: some of these should be in symbol.c */
 void gfc_free_interface (gfc_interface *);
+int gfc_compare_union_types (gfc_symbol *, gfc_symbol *);
 int gfc_compare_derived_types (gfc_symbol *, gfc_symbol *);
 int gfc_compare_types (gfc_typespec *, gfc_typespec *);
 int gfc_compare_interfaces (gfc_symbol*, gfc_symbol*, const char *, int, int,
@@ -2925,6 +2974,8 @@ void gfc_module_done_2 (void);
 void gfc_dump_module (const char *, int);
 bool gfc_check_symbol_access (gfc_symbol *);
 void gfc_free_use_stmts (gfc_use_list *);
+const char *gfc_dt_lower_string (const char *);
+const char *gfc_dt_upper_string (const char *);
 
 /* primary.c */
 symbol_attribute gfc_variable_attr (gfc_expr *, gfc_typespec *);
diff --git a/gcc/fortran/gfortran.texi b/gcc/fortran/gfortran.texi
index 4f9008d3d26..71161a9b67f 100644
--- a/gcc/fortran/gfortran.texi
+++ b/gcc/fortran/gfortran.texi
@@ -473,9 +473,9 @@ The GNU Fortran compiler is able to compile nearly all
 standard-compliant Fortran 95, Fortran 90, and Fortran 77 programs,
 including a number of standard and non-standard extensions, and can be
 used on real-world programs.  In particular, the supported extensions
-include OpenMP, Cray-style pointers, and several Fortran 2003 and Fortran
-2008 features, including TR 15581.  However, it is still under
-development and has a few remaining rough edges.
+include OpenMP, Cray-style pointers, several Fortran 2003 and Fortran
+2008 features, including TR 15581, and some of the Intel/DEC extensions.
+However, it is still under development and has a few remaining rough edges.
 
 At present, the GNU Fortran compiler passes the
 @uref{http://www.fortran-2000.com/ArnaudRecipes/fcvs21_f95.html, 
@@ -1338,7 +1338,8 @@ purely for backward compatibility with legacy compilers.  By default,
 extensions, but to warn about the use of the latter.  Specifying
 either @option{-std=f95}, @option{-std=f2003} or @option{-std=f2008}
 disables both types of extensions, and @option{-std=legacy} allows both
-without warning.
+without warning. Those extensions which are enabled by specific compile
+flags do not produce warnings.
 
 @menu
 * Old-style kind specifications::
@@ -1358,6 +1359,7 @@ without warning.
 * CONVERT specifier::
 * OpenMP::
 * Argument list functions::
+* Optional DEC extension support::
 @end menu
 
 @node Old-style kind specifications
@@ -1554,7 +1556,7 @@ type, then the real-literal-constant will be interpreted as a
 
 @node BOZ literal constants
 @subsection BOZ literal constants
-@cindex BOZ literal constants
+@cindex literal constants, BOZ
 
 Besides decimal constants, Fortran also supports binary (@code{b}),
 octal (@code{o}) and hexadecimal (@code{z}) integer constants.  The
@@ -1646,6 +1648,37 @@ However, there is no implicit conversion of @code{INTEGER} values in
 @code{if}-statements, nor of @code{LOGICAL} or @code{INTEGER} values
 in I/O operations.
 
+As a further extension, when the flag @option{-fdec-bitwise-ops} is asserted
+any logical operators with at least one @code{INTEGER} operand implicitly
+use the corresponding bitwise intrinsic function instead of the logical
+operation. The result is an integer type with the same kind of the largest
+integer operand. A complete list of the conversions that take place is given
+here:
+
+@smallexample
+  .NOT.  X -> NOT(X)
+X .AND.  Y -> IAND(X,Y)
+X .OR.   Y -> IOR(X,Y)
+X .XOR.  Y -> IEOR(X,Y)*
+X .NEQV. Y -> IEOR(X,Y)
+X .EQV.  Y -> NOT(IEOR(X,Y))
+@end smallexample
+@emph{See @ref{.XOR. operator}}
+
+For example, with @option{-fdec-bitwise-ops}, the following two examples are
+equivalent:
+
+@smallexample
+      INTEGER :: i, j
+      LOGICAL :: l
+      j = i .AND. l
+@end smallexample
+@smallexample
+      INTEGER :: i, j
+      LOGICAL :: l
+      j = IAND(i, l)
+@end smallexample
+
 @node Hollerith constants support
 @subsection Hollerith constants support
 @cindex Hollerith constants
@@ -1959,55 +1992,56 @@ C
       end
 @end smallexample
 
+Use of @code{%LOC()} as an rvalue is supported with the flag
+@option{-floc-rval} (its behavior is identical to the @code{LOC()} intrinsic).
+
 For details refer to the g77 manual
 @uref{http://gcc.gnu.org/@/onlinedocs/@/gcc-3.4.6/@/g77/@/index.html#Top}.
 
 Also, @code{c_by_val.f} and its partner @code{c_by_val.c} of the
 GNU Fortran testsuite are worth a look.
 
+@node Optional DEC extension support
+@subsection Optional DEC extension support
+@cindex extensions, dec
 
-@node Extensions not implemented in GNU Fortran
-@section Extensions not implemented in GNU Fortran
-@cindex extensions, not implemented
-
-The long history of the Fortran language, its wide use and broad
-userbase, the large number of different compiler vendors and the lack of
-some features crucial to users in the first standards have lead to the
-existence of a number of important extensions to the language.  While
-some of the most useful or popular extensions are supported by the GNU
-Fortran compiler, not all existing extensions are supported.  This section
-aims at listing these extensions and offering advice on how best make
-code that uses them running with the GNU Fortran compiler.
+Long long ago in a land far far away, in the time before Fortran standards
+existed, compiler writers loved to add extensions to Fortran for anyone who
+asked them nicely. The most popular of these extensions were implemented by
+Digital Equipment Corporation (DEC). Since they were so popular they were
+maintained in the Digital (and since Intel) compiler long after standards were
+introduced. Unfortunately these extensions remain in use by a number of users.
 
-@c More can be found here:
-@c   -- http://gcc.gnu.org/onlinedocs/gcc-3.4.6/g77/Missing-Features.html
-@c   -- the list of Fortran and libgfortran bugs closed as WONTFIX:
-@c      http://tinyurl.com/2u4h5y
+GNU Fortran provides selective automatic support for some of these
+extensions, described in the previous section @ref{Extensions implemented in
+GNU Fortran}. Other DEC extensions are so heinous that GNU Fortran requires the
+user to explicitly enable them; these are the "optional" DEC extensions,
+described here. Most of the time they are enabled with a compile flag prefaced
+by @option{-fdec-}.
 
 @menu
 * STRUCTURE and RECORD::
-@c * UNION and MAP::
-* ENCODE and DECODE statements::
-* Variable FORMAT expressions::
-@c * Q edit descriptor::
-@c * AUTOMATIC statement::
-@c * TYPE and ACCEPT I/O Statements::
-@c * .XOR. operator::
-@c * CARRIAGECONTROL, DEFAULTFILE, DISPOSE and RECORDTYPE I/O specifiers::
-@c * Omitted arguments in procedure call::
-* Alternate complex function syntax::
+* UNION and MAP::
+* .XOR. operator::
+* Base#value literal constants::
+* I/O specifiers::
+* Type prefixes to integer intrinsic functions::
+* Extended math intrinsics::
+* AUTOMATIC and STATIC attributes::
+* Form feed as whitespace::
+* Legacy PARAMETER statements::
 @end menu
 
-
 @node STRUCTURE and RECORD
-@subsection @code{STRUCTURE} and @code{RECORD}
+@subsubsection @code{STRUCTURE} and @code{RECORD}
 @cindex @code{STRUCTURE}
 @cindex @code{RECORD}
 
-Record structures are a pre-Fortran-90 vendor extension to create
-user-defined aggregate data types.  GNU Fortran does not support
-record structures, only Fortran 90's ``derived types'', which have
-a different syntax.
+Record structures are a pre-Fortran-90 DEC extension to create
+user-defined aggregate data types. Support for record structures in GNU
+Fortran can be enabled with the @option{-fdec-structure} compile option.
+If you have a choice, you should instead use Fortran 90's ``derived types'',
+which have a different syntax. 
 
 In many cases, record structures can easily be converted to derived types.
 To convert, replace @code{STRUCTURE /}@var{structure-name}@code{/}
@@ -2016,6 +2050,10 @@ by @code{TYPE} @var{type-name}.  Additionally, replace
 @code{TYPE(}@var{type-name}@code{)}. Finally, in the component access,
 replace the period (@code{.}) by the percent sign (@code{%}).
 
+Note that component access by period can be enabled for derived types
+separately from structure/record support with @option{-fdec-member-dot};
+however, it is enabled automatically with @option{-fdec-structure}.
+
 Here is an example of code using the non portable record structure syntax:
 
 @example
@@ -2045,43 +2083,502 @@ print *, store_catalog(12)
 @end example
 
 @noindent
-This code can easily be rewritten in the Fortran 90 syntax as following:
+Structures and derived types differ in a few ways:
+ 
+@itemize @bullet
+@item Structures act like derived types with the @code{SEQUENCE} attribute.
+Otherwise they may contain no specifiers.
+
+@item Structures may contain a variable with the name @code{%FILL}; this will
+create an anonymous component which cannot be referenced but fills space just
+like a component for alignment purposes. For example, the following structure
+will take up sixteen bytes:
+
+@smallexample 
+structure /useless/
+  integer(4) i
+  integer(8) %FILL
+end structure
+@end smallexample
+
+@item Structures may share names with other symbols. For example, the following
+is invalid for derived types, but valid for structures:
+
+@smallexample
+structure /Header/
+  ! ...
+end structure
+record /Header/ header
+@end smallexample
+
+@item Structures may be defined 'ad-hoc' within another parent structure. The
+type names for these structures may be ommitted, in which case the structure
+type itself is anonymous, and other structures of the same type cannot be
+instantiated. The following shows some examples:
 
 @example
-! ``STRUCTURE /name/ ... END STRUCTURE'' becomes
-! ``TYPE name ... END TYPE''
-TYPE item
-  INTEGER id
-  CHARACTER(LEN=200) description
-  REAL price
-END TYPE
+type appointment
+  ! 'ad-hoc' structure definition; app_time is an array of two 'time'
+  structure /time/ app_time (2) 
+    integer(1) hour, minute
+  end structure
+  character(10) memo
+end type appointment
+
+! The 'time' structure is still usable
+record /time/ now
+now = time(5, 30)
+
+...
+
+type appointment
+  ! anonymous ad-hoc structure definition
+  structure start, end
+    integer(1) hour, minute
+  end structure
+  character(10) memo
+end type appointment
+@end example
 
-! ``RECORD /name/ variable'' becomes ``TYPE(name) variable''
-TYPE(item) pear, store_catalog(100)
+@item Structures may contain @code{UNION} declarations. For more detail see the
+section on @ref{UNION and MAP}.
 
-! Instead of using a dot (.) to access fields of a record, the
-! standard syntax uses a percent sign (%)
-pear%id = 92316
-pear%description = "juicy D'Anjou pear"
-pear%price = 0.15
-store_catalog(7)%id = 7831
-store_catalog(7)%description = "milk bottle"
-store_catalog(7)%price = 1.2
+@item Structures support old-style initialization of components, identical to
+those described in @ref{Old-style variable initialization}.
+@end itemize
 
-! Assignments of a whole variable do not change
-store_catalog(12) = pear
-print *, store_catalog(12)
+@node UNION and MAP
+@subsubsection @code{UNION} and @code{MAP}
+@cindex @code{UNION}
+@cindex @code{MAP}
+
+Unions are a DEC extension which were commonly used with the non-standard
+@ref{STRUCTURE and RECORD} extensions. Use of @code{UNION} and @code{MAP} is
+automatically enabled with @option{-fdec-structure}.
+
+A @code{UNION} declaration occurs within a structure; within the definition of
+each union is a number of @code{MAP} definitions. Each @code{MAP} shares
+storage with its sibling maps (in the same union), and the size of the union
+is the size of the largest map within it, just as with unions in C. The major
+difference is that component references do not indicate which union or map the
+component is in (the compiler gets to figure that out).
+
+Here is a small example:
+@smallexample
+structure /words_long/
+union
+  map
+    integer(2) w0, w1, w2
+  end map
+  map
+    integer(4) long
+  end map
+end union
+end structure
+@end smallexample
+
+The two maps share memory, and the size of the union is ultimately six bytes:
+
+@example
+0    1    2    3    4   5   6     Byte offset
+-------------------------------
+|    |    |    |    |    |    |
+-------------------------------
+
+^    W0   ^    W1   ^    W2   ^
+ \-------/ \-------/ \-------/
+
+^       LONG        ^  unused ^
+ \-----------------/ \-------/
+@end example
+
+Following is an example mirroring the layout of an Intel x86_64 register:
+
+@example
+structure /reg/
+  union    ! rax
+    map
+      integer*8 rx         ! rax
+    end map
+    map
+      integer*4 rh         ! rah
+      union   ! eax
+        map
+          integer*4 rl     ! ral
+        end map
+        map
+          integer*4 ex     ! eax
+        end map
+        map
+          integer*2 eh     ! eah
+          union     ! ax
+            map
+              integer*2 el ! eal
+            end map
+            map
+              integer*2 x  ! ax
+            end map
+            map
+              integer*1 h  ! ah
+              integer*1 l  ! al
+            end map
+          end union ! ax
+        end map
+      end union ! eax
+    end map
+  end union ! rax
+end structure
+
+record /reg/ a
+
+! After this assignment...
+a.rx = z'AABBCCCCFFFFFFFF'
+
+! The following is true:
+!
+! a.rx == z'AABBCCCCFFFFFFFF'
+! a.rh ==         z'FFFFFFFF'
+! a.rl == z'AABBCCCC'
+!
+! a.ex == z'AABBCCCC'
+! a.eh ==     z'CCCC'
+! a.el == z'AABB'
+!
+!  a.x == z'AABB'
+!  a.h ==   z'BB'
+!  a.l == z'AA'
+@end example
+
+@node .XOR. operator
+@subsubsection @code{.XOR.} operator
+@cindex operator, @code{XOR}
+
+With @option{-fdec-logical-xor}, @code{.XOR.} is supported as a logical
+operator. It is entirely equivalent to the standard operator @code{.NEQV.}:
+
+@example
+logical :: a = .true., b = .false., c
+c = a .xor. b ! same as a .neqv. b
+@end example
+
+@node Base#value literal constants
+@subsubsection Base#value literal constants
+
+With the flag @option{-fdec-extended-int} GNU Fortran supports the use of the
+DEC @code{base#value} integer constants. The base may lie anywhere between 2
+and 36. If no base is present (as in @code{#value}) the default base is 16
+(hexadecimal). The letters of the alphabet A-Z represent digits starting at ten
+for bases higher than base ten. In the following example, each assignment
+results in the value 63:
+
+@example
+I = #3D + 2
+J = 16#3f
+K = 2#1000000 - 6#1
+L = -4#3 + 5#231
+M = '3f'x
+N = 36#1R
+@end example
+
+Extended integer literals of this form are also supported in standard variable
+kind specifications (not old-style):
+
+@example
+integer(kind=2#100) I ! valid: 100 base 2 => 4
+integer(5#13)       J ! valid: 13  base 5 => 8
+integer*3#11        K ! UNSUPPORTED
+@end example
+
+@node I/O specifiers
+@subsubsection I/O specifiers
+@cindex I/O
+@cindex @code{CARRIAGECONTROL}
+@cindex @code{READONLY}
+@cindex @code{SHARED}
+
+With @option{-fdec-io} GNU Fortran supports additional DEC extended I/O
+features. Currently implemented are three additional categories of specifiers
+for the @code{OPEN} statement:
+
+@itemize @bullet
+
+@item @code{READONLY}
+
+Specifying @code{READONLY} in an @code{OPEN} statement is equivalent to
+specifying @code{ACTION='READ'}, except that the file is protected from
+deletion on close. A runtime error will be thrown if a unit opened
+@code{READONLY} is closed with @code{STATUS='DELETE'}. @code{READONLY} may not
+be present with the @code{ACTION=} specifier. Example:
+
+@example
+open (unit=fd, file=fname, readonly)
+ ...
+close (unit=fd, status='delete') ! will cause runtime error
 @end example
 
+@item @code{SHARED}, @code{NOSHARED}, @code{SHARE=DENYNONE|DENYRW}
 
-@c @node UNION and MAP
-@c @subsection @code{UNION} and @code{MAP}
-@c @cindex @code{UNION}
-@c @cindex @code{MAP}
-@c
-@c For help writing this one, see
-@c http://www.eng.umd.edu/~nsw/ench250/fortran1.htm#UNION and
-@c http://www.tacc.utexas.edu/services/userguides/pgi/pgiws_ug/pgi32u06.htm
+When this specifier is given, runtime file locking occurs based on the option
+given. The locking is performed by @code{fcntl}; see your system's
+documentation for details on the locking performed.
+
+@itemize
+@item @code{DENYNONE} Lock the file with a shared (read) lock (i.e. F_RDLCK) on
+open.
+@item @code{DENYRW} Lock the file with an exclusive (write) lock (i.e. F_WRLCK)
+on open.
+@end itemize
+
+@code{SHARED} is equivalent to @code{SHARE=DENYNONE}, and
+@code{NOSHARED} is equivalent to @code{SHARE=DENYRW}. Examples:
+
+@example
+open (..., action='*')                       ! open with no locking
+
+open (..., action='read',  share='denynone') ! open with shared/read lock
+open (..., action='read',  shared)           ! equivalent to the above
+
+open (..., action='write', share='denyrw')   ! open with exclusive/write lock
+open (..., action='write', noshared)         ! equivalent to the above
+@end example
+
+@item @code{CARRIAGECONTROL=NONE|LIST|FORTRAN}
+
+The @code{CARRIAGECONTROL} specifier dictates how reading and writing between
+records is performed for the given unit at runtime.
+
+@itemize
+@item @code{NONE} - default for unformatted or binary I/O.
+
+When writing, no line feed is written following each record. When reading
+there are no records; the entire read buffer is filled with each read.
+
+@item @code{LIST} - default for regular formatted I/O.
+
+When writing, a space is written before each record and a line feed (or CR-LF)
+is written following each record. This is because of the historical special
+interpretation of the character in the first column of a line.
+
+@item @code{FORTRAN}
+
+When writing, no space is inserted before each record, but a line feed (or
+CR-LF) is still written following each record. This is to allow output into
+the first column of a line for special interpretation. Reading is identical to
+@code{CARRIAGECONTROL=LIST}.
+
+@end itemize
+
+Examples:
+
+@example
+open (unit=3, ..., carriagecontrol='list')
+write (3, *) "hi"
+write (3, *) "there"
+...
+! Output is " hi\n there\n":
+ hi
+ there
+@end example
+@example
+open (unit=3, ..., carriagecontrol='fortran')
+write (3, *) "hi"
+write (3, *) "there"
+...
+! Output is "hi\nthere\n":
+hi
+there
+@end example
+@example
+open (unit=3, ..., carriagecontrol='none')
+write (3, *) "hi"
+write (3, *) "there"
+...
+! Output is " hi there":
+ hi there
+@end example
+@end itemize
+
+@node Type prefixes to integer intrinsic functions
+@subsubsection Type prefixes to integer intrinsic functions
+@cindex intrinsics, integer
+
+Similar to the D/C prefixes to real functions to specify the input/output
+types, DEC offered B/I/J/K prefixes to integer functions to control their
+types. The types implied by each are:
+
+@example
+@code{B} - @code{INTEGER(kind=1)}
+@code{I} - @code{INTEGER(kind=2)}
+@code{J} - @code{INTEGER(kind=4)}
+@code{K} - @code{INTEGER(kind=8)}
+@end example
+
+GNU Fortran supports these with the flag @option{-fdec-intrinsic-ints}.
+Intrinsics for which prefixed versions are available and in what form are noted
+in @ref{Intrinsic Procedures}. The complete list of currently supported
+intrinsics is here:
+
+@multitable @columnfractions .2 .2 .2 .2 .2
+
+@headitem Intrinsic @tab B @tab I @tab J @tab K
+
+@item @code{@ref{ABS}}
+  @tab @code{BABS} @tab @code{IIABS} @tab @code{JIABS} @tab @code{KIABS}
+@item @code{@ref{BTEST}}
+  @tab @code{BBTEST} @tab @code{BITEST} @tab @code{BJTEST} @tab @code{BKTEST}
+@item @code{@ref{IAND}}
+  @tab @code{BIAND} @tab @code{IIAND} @tab @code{JIAND} @tab @code{KIAND}
+@item @code{@ref{IBCLR}}
+  @tab @code{BBCLR} @tab @code{IIBCLR} @tab @code{JIBCLR} @tab @code{KIBCLR}
+@item @code{@ref{IBITS}}
+  @tab @code{BBITS} @tab @code{IIBITS} @tab @code{JIBITS} @tab @code{KIBITS}
+@item @code{@ref{IBSET}}
+  @tab @code{BBSET} @tab @code{IIBSET} @tab @code{JIBSET} @tab @code{KIBSET}
+@item @code{@ref{IEOR}}
+  @tab @code{BIEOR} @tab @code{IIEOR} @tab @code{JIEOR} @tab @code{KIEOR}
+@item @code{@ref{IOR}}
+  @tab @code{BIOR} @tab @code{IIOR} @tab @code{JIOR} @tab @code{KIOR}
+@item @code{@ref{ISHFT}}
+  @tab @code{BSHFT} @tab @code{IISHFT} @tab @code{JISHFT} @tab @code{KISHFT}
+@item @code{@ref{ISHFTC}}
+  @tab @code{BSHFTC} @tab @code{IISHFTC} @tab @code{JISHFTC} @tab @code{KISHFTC}
+@item @code{@ref{MOD}}
+  @tab @code{BMOD} @tab @code{IMOD} @tab @code{JMOD} @tab @code{KMOD}
+@item @code{@ref{NOT}}
+  @tab @code{BNOT} @tab @code{INOT} @tab @code{JNOT} @tab @code{KNOT}
+@item @code{@ref{REAL}}
+  @tab @code{--} @tab @code{FLOATI} @tab @code{FLOATJ} @tab @code{FLOATK}
+@end multitable
+
+@node Extended math intrinsics
+@subsubsection Extended math intrinsics
+@cindex intrinsics, math
+@cindex intrinsics, trigonometric function
+@cindex trigonometric function, degrees
+
+GNU Fortran supports an extended list of mathematical intrinsics with
+@option{-fdec-math}. These intrinsics are listed completely in @ref{Intrinsic
+Procedures} and it is noted that they are optional DEC extensions. 
+
+This flag enables the @ref{COTAN} intrinsic.
+
+This flag also adds trigonometric intrinsics which accept or produce degrees
+instead of radians. The new intrinsics enabled by this option are listed here
+with the corresponding standard radian versions:
+
+@multitable @columnfractions .5 .5
+@headitem Radians @tab Degrees
+@item @code{@ref{ACOS}}  @tab @code{@ref{ACOSD}}
+@item @code{@ref{ASIN}}  @tab @code{@ref{ASIND}}
+@item @code{@ref{ATAN}}  @tab @code{@ref{ATAND}}
+@item @code{@ref{ATAN2}} @tab @code{@ref{ATAN2D}}
+@item @code{@ref{COS}}   @tab @code{@ref{COSD}}
+@item @code{@ref{COTAN}} @tab @code{@ref{COTAND}}
+@item @code{@ref{SIN}}   @tab @code{@ref{SIND}}
+@item @code{@ref{TAN}}   @tab @code{@ref{TAND}}
+@end multitable
+
+@node AUTOMATIC and STATIC attributes
+
+@subsubsection @code{AUTOMATIC} and @code{STATIC} attributes
+@cindex variable attributes
+@cindex @code{AUTOMATIC}
+@cindex @code{STATIC}
+
+With @option{-fdec-static} GNU Fortran supports the explicit specification of
+two additional variable attributes: @code{STATIC} and @code{AUTOMATIC}. These
+follow the syntax of the @code{SAVE} attribute.
+
+@code{STATIC} is exactly equivalent to @code{SAVE}.
+
+@code{AUTOMATIC} is the default for local variables smaller than
+@option{-fmax-stack-var-size}, unless @option{-fno-automatic} is given.
+Variables marked @code{AUTOMATIC} will be stack automatic variables whenever
+possible. This attribute overrides @option{-fno-automatic},
+@option{-fmax-stack-var-size}, and blanket @code{SAVE} statements.
+
+Examples:
+
+@example
+subroutine f
+  integer, automatic :: i  ! automatic variable
+  integer x, y             ! static variables
+  save
+  ...
+endsubroutine
+@end example
+@example
+subroutine f
+  integer a, b, c, x, y, z
+  static :: x
+  save y
+  automatic z, c
+  ! a, b, c, and z are automatic
+  ! x and y are static
+endsubroutine
+@end example
+@example
+! Compiled with -fno-automatic
+subroutine f
+  integer a, b, c, d
+  automatic :: a
+  ! a is automatic; b, c, and d are static
+endsubroutine
+@end example
+
+@node Form feed as whitespace
+@subsubsection Form feed as whitespace
+@cindex form feed
+
+Historically, DEC allowed insertion of form feed characters ('\f', ASCII 0x0C)
+at the beginning of lines for nice output to line printers. GNU Fortran
+supports the interpretation of form feed characters in source as whitespace
+with @option{-ffeed}.
+
+@node Legacy PARAMETER statements
+@subsubsection Legacy PARAMETER statements
+@cindex PARAMETER
+
+For compatibility, GNU Fortran supports legacy PARAMETER statements without
+parentheses with @option{-std=legacy}.  A warning is emitted if used with
+@option{-std=gnu}, and an error is acknowledged with a real Fortran standard
+flag (@option{-std=f95}, etc...).  These statements take the following form:
+
+@smallexample
+implicit real (E)
+paraneter e = 2.718282
+real c
+parameter c = 3.0e8
+@end smallexample
+
+
+@node Extensions not implemented in GNU Fortran
+@section Extensions not implemented in GNU Fortran
+@cindex extensions, not implemented
+
+The long history of the Fortran language, its wide use and broad
+userbase, the large number of different compiler vendors and the lack of
+some features crucial to users in the first standards have lead to the
+existence of a number of important extensions to the language.  While
+some of the most useful or popular extensions are supported by the GNU
+Fortran compiler, not all existing extensions are supported.  This section
+aims at listing these extensions and offering advice on how best make
+code that uses them running with the GNU Fortran compiler.
+
+@c More can be found here:
+@c   -- http://gcc.gnu.org/onlinedocs/gcc-3.4.6/g77/Missing-Features.html
+@c   -- the list of Fortran and libgfortran bugs closed as WONTFIX:
+@c      http://tinyurl.com/2u4h5y
+
+@menu
+* ENCODE and DECODE statements::
+* Variable FORMAT expressions::
+@c * Q edit descriptor::
+@c * TYPE and ACCEPT I/O Statements::
+@c * DEFAULTFILE, DISPOSE and RECORDTYPE I/O specifiers::
+@c * Omitted arguments in procedure call::
+* Alternate complex function syntax::
+@end menu
 
 
 @node ENCODE and DECODE statements
diff --git a/gcc/fortran/interface.c b/gcc/fortran/interface.c
index 2d739426e22..d4057b4b360 100644
--- a/gcc/fortran/interface.c
+++ b/gcc/fortran/interface.c
@@ -383,13 +383,150 @@ gfc_match_end_interface (void)
 }
 
 
+/* Return whether the component was defined anonymously.  */
+
+static bool
+is_anonymous_component (gfc_component *cmp)
+{
+  /* Only UNION and MAP components are anonymous.  In the case of a MAP,
+     the derived type symbol is FL_STRUCT and the component name looks like mM*.
+     This is the only case in which the second character of a component name is
+     uppercase.  */
+  return cmp->ts.type == BT_UNION
+    || (cmp->ts.type == BT_DERIVED
+        && cmp->ts.u.derived->attr.flavor == FL_STRUCT
+        && cmp->name[0] && cmp->name[1] && ISUPPER (cmp->name[1]));
+}
+
+
+/* Return whether the derived type was defined anonymously.  */
+
+static bool
+is_anonymous_dt (gfc_symbol *derived)
+{
+  /* UNION and MAP types are always anonymous. Otherwise, only nested STRUCTURE
+     types can be anonymous.  For anonymous MAP/STRUCTURE, we have FL_STRUCT
+     and the type name looks like XX*.  This is the only case in which the
+     second character of a type name is uppercase.  */
+  return derived->attr.flavor == FL_UNION
+    || (derived->attr.flavor == FL_STRUCT
+        && derived->name[0] && derived->name[1] && ISUPPER (derived->name[1]));
+}
+
+
+/* Compare components according to 4.4.2 of the Fortran standard.  */
+
+static int
+compare_components (gfc_component *cmp1, gfc_component *cmp2,
+    gfc_symbol *derived1, gfc_symbol *derived2)
+{
+  /* Compare names, but not for anonymous components such as UNION or MAP.  */
+  if (!is_anonymous_component (cmp1) && !is_anonymous_component (cmp1)
+      && strcmp (cmp1->name, cmp2->name) != 0)
+    return 0;
+
+  if (cmp1->attr.access != cmp2->attr.access)
+    return 0;
+
+  if (cmp1->attr.pointer != cmp2->attr.pointer)
+    return 0;
+
+  if (cmp1->attr.dimension != cmp2->attr.dimension)
+    return 0;
+
+  if (cmp1->attr.allocatable != cmp2->attr.allocatable)
+    return 0;
+
+  if (cmp1->attr.dimension && gfc_compare_array_spec (cmp1->as, cmp2->as) == 0)
+    return 0;
+
+  /* Make sure that link lists do not put this function into an
+     endless recursive loop!  */
+  if (!(cmp1->ts.type == BT_DERIVED && derived1 == cmp1->ts.u.derived)
+      && !(cmp2->ts.type == BT_DERIVED && derived2 == cmp2->ts.u.derived)
+      && gfc_compare_types (&cmp1->ts, &cmp2->ts) == 0)
+    return 0;
+
+  else if ( (cmp1->ts.type == BT_DERIVED && derived1 == cmp1->ts.u.derived)
+        && !(cmp2->ts.type == BT_DERIVED && derived2 == cmp2->ts.u.derived))
+    return 0;
+
+  else if (!(cmp1->ts.type == BT_DERIVED && derived1 == cmp1->ts.u.derived)
+        &&  (cmp2->ts.type == BT_DERIVED && derived2 == cmp2->ts.u.derived))
+    return 0;
+
+  return 1;
+}
+
+
+/* Compare two union types by comparing the components of their maps.
+   Because unions and maps are anonymous their types get special internal
+   names; therefore the usual derived type comparison will fail on them.
+
+   Returns nonzero if equal, as with gfc_compare_derived_types. Also as with
+   gfc_compare_derived_types, 'equal' is closer to meaning 'duplicate
+   definitions' than 'equivalent structure'. */
+
+int
+gfc_compare_union_types (gfc_symbol *un1, gfc_symbol *un2)
+{
+  gfc_component *map1, *map2, *cmp1, *cmp2;
+
+  if (un1->attr.flavor != FL_UNION || un2->attr.flavor != FL_UNION)
+    return 0;
+
+  map1 = un1->components;
+  map2 = un2->components;
+
+  /* In terms of 'equality' here we are worried about types which are
+     declared the same in two places, not types that represent equivalent
+     structures. (This is common because of FORTRAN's weird scoping rules.)
+     Though two unions with their maps in different orders could be equivalent,
+     we will say they are not equal for the purposes of this test; therefore
+     we compare the maps sequentially. */
+  for (;;)
+  {
+    cmp1 = map1->ts.u.derived->components;
+    cmp2 = map2->ts.u.derived->components;
+    for (;;)
+    {
+      /* No two fields will ever point to the same map type unless they are
+         the same component, because one map field is created with its type
+         declaration. Therefore don't worry about recursion here. */
+      /* TODO: worry about recursion into parent types of the unions? */
+      if (compare_components (cmp1, cmp2,
+            map1->ts.u.derived, map2->ts.u.derived) == 0)
+        return 0;
+
+      cmp1 = cmp1->next;
+      cmp2 = cmp2->next;
+
+      if (cmp1 == NULL && cmp2 == NULL)
+        break;
+      if (cmp1 == NULL || cmp2 == NULL)
+        return 0;
+    }
+
+    map1 = map1->next;
+    map2 = map2->next;
+
+    if (map1 == NULL && map2 == NULL)
+      break;
+    if (map1 == NULL || map2 == NULL)
+      return 0;
+  }
+
+  return 1;
+}
+
+
 /* Compare two derived types using the criteria in 4.4.2 of the standard,
    recursing through gfc_compare_types for the components.  */
 
 int
 gfc_compare_derived_types (gfc_symbol *derived1, gfc_symbol *derived2)
 {
-  gfc_component *dt1, *dt2;
+  gfc_component *cmp1, *cmp2;
 
   if (derived1 == derived2)
     return 1;
@@ -404,12 +541,14 @@ gfc_compare_derived_types (gfc_symbol *derived1, gfc_symbol *derived2)
       && strcmp (derived1->module, derived2->module) == 0)
     return 1;
 
+  /* Compare names, but not for anonymous types such as UNION or MAP.  */
+  if (!is_anonymous_dt (derived1) && !is_anonymous_dt (derived2)
+      && strcmp (derived1->name, derived2->name) != 0)
+    return 0;
+
   /* Compare type via the rules of the standard.  Both types must have
      the SEQUENCE or BIND(C) attribute to be equal.  */
 
-  if (strcmp (derived1->name, derived2->name))
-    return 0;
-
   if (derived1->component_access == ACCESS_PRIVATE
       || derived2->component_access == ACCESS_PRIVATE)
     return 0;
@@ -418,53 +557,42 @@ gfc_compare_derived_types (gfc_symbol *derived1, gfc_symbol *derived2)
       && !(derived1->attr.is_bind_c && derived2->attr.is_bind_c))
     return 0;
 
-  dt1 = derived1->components;
-  dt2 = derived2->components;
+  if ((derived1->attr.zero_comp && !derived2->attr.zero_comp)
+      || (!derived1->attr.zero_comp && derived2->attr.zero_comp))
+    return 0;
+
+  if (derived1->attr.zero_comp || derived2->attr.zero_comp)
+    return 1;
+
+  cmp1 = derived1->components;
+  cmp2 = derived2->components;
 
   /* Since subtypes of SEQUENCE types must be SEQUENCE types as well, a
      simple test can speed things up.  Otherwise, lots of things have to
      match.  */
   for (;;)
     {
-      if (strcmp (dt1->name, dt2->name) != 0)
-	return 0;
-
-      if (dt1->attr.access != dt2->attr.access)
-	return 0;
-
-      if (dt1->attr.pointer != dt2->attr.pointer)
-	return 0;
-
-      if (dt1->attr.dimension != dt2->attr.dimension)
-	return 0;
-
-     if (dt1->attr.allocatable != dt2->attr.allocatable)
-	return 0;
-
-      if (dt1->attr.dimension && gfc_compare_array_spec (dt1->as, dt2->as) == 0)
-	return 0;
-
       /* Make sure that link lists do not put this function into an
 	 endless recursive loop!  */
-      if (!(dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.u.derived)
-	    && !(dt2->ts.type == BT_DERIVED && derived2 == dt2->ts.u.derived)
-	    && gfc_compare_types (&dt1->ts, &dt2->ts) == 0)
+      if (     !(cmp1->ts.type == BT_DERIVED && derived1 == cmp1->ts.u.derived)
+            && !(cmp2->ts.type == BT_DERIVED && derived2 == cmp2->ts.u.derived)
+            && compare_components (cmp1, cmp2, derived1, derived2) == 0)
 	return 0;
 
-      else if ((dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.u.derived)
-		&& !(dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.u.derived))
+      else if ( (cmp1->ts.type == BT_DERIVED && derived1 == cmp1->ts.u.derived)
+            && !(cmp2->ts.type == BT_DERIVED && derived2 == cmp2->ts.u.derived))
 	return 0;
 
-      else if (!(dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.u.derived)
-		&& (dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.u.derived))
+      else if (!(cmp1->ts.type == BT_DERIVED && derived1 == cmp1->ts.u.derived)
+            &&  (cmp2->ts.type == BT_DERIVED && derived2 == cmp2->ts.u.derived))
 	return 0;
 
-      dt1 = dt1->next;
-      dt2 = dt2->next;
+      cmp1 = cmp1->next;
+      cmp2 = cmp2->next;
 
-      if (dt1 == NULL && dt2 == NULL)
+      if (cmp1 == NULL && cmp2 == NULL)
 	break;
-      if (dt1 == NULL || dt2 == NULL)
+      if (cmp1 == NULL || cmp2 == NULL)
 	return 0;
     }
 
@@ -494,10 +622,14 @@ gfc_compare_types (gfc_typespec *ts1, gfc_typespec *ts2)
       && (ts1->u.derived->attr.sequence || ts1->u.derived->attr.is_bind_c))
     return 1;
 
+  if (ts1->type == BT_UNION && ts2->type == BT_UNION)
+    return gfc_compare_union_types (ts1->u.derived, ts2->u.derived);
+
   if (ts1->type != ts2->type
-      && ((ts1->type != BT_DERIVED && ts1->type != BT_CLASS)
-	  || (ts2->type != BT_DERIVED && ts2->type != BT_CLASS)))
+      && (   (ts1->type != BT_DERIVED && ts1->type != BT_CLASS)
+          || (ts2->type != BT_DERIVED && ts2->type != BT_CLASS)))
     return 0;
+
   if (ts1->type != BT_DERIVED && ts1->type != BT_CLASS)
     return (ts1->kind == ts2->kind);
 
@@ -505,7 +637,7 @@ gfc_compare_types (gfc_typespec *ts1, gfc_typespec *ts2)
   if (gfc_type_compatible (ts1, ts2))
     return 1;
 
-  return gfc_compare_derived_types (ts1->u.derived ,ts2->u.derived);
+  return 0;
 }
 
 
@@ -1467,7 +1599,7 @@ check_interface0 (gfc_interface *p, const char *interface_name)
 	 functions or subroutines.  */
       if (((!p->sym->attr.function && !p->sym->attr.subroutine)
 	   || !p->sym->attr.if_source)
-	  && p->sym->attr.flavor != FL_DERIVED)
+	  && !gfc_fl_struct (p->sym->attr.flavor))
 	{
 	  if (p->sym->attr.external)
 	    gfc_error ("Procedure '%s' in %s at %L has no explicit interface",
@@ -1481,17 +1613,21 @@ check_interface0 (gfc_interface *p, const char *interface_name)
 
       /* Verify that procedures are either all SUBROUTINEs or all FUNCTIONs.  */
       if ((psave->sym->attr.function && !p->sym->attr.function
-	   && p->sym->attr.flavor != FL_DERIVED)
+	   && !gfc_fl_struct (p->sym->attr.flavor))
 	  || (psave->sym->attr.subroutine && !p->sym->attr.subroutine))
 	{
-	  if (p->sym->attr.flavor != FL_DERIVED)
+	  if (!gfc_fl_struct (p->sym->attr.flavor))
 	    gfc_error ("In %s at %L procedures must be either all SUBROUTINEs"
 		       " or all FUNCTIONs", interface_name,
 		       &p->sym->declared_at);
-	  else
+	  else if (p->sym->attr.flavor == FL_DERIVED)
 	    gfc_error ("In %s at %L procedures must be all FUNCTIONs as the "
 		       "generic name is also the name of a derived type",
 		       interface_name, &p->sym->declared_at);
+          else
+            gfc_error ("In %s at %L procedures must be all FUNCTIONs as the "
+                       "generic name is also the name of a structure type",
+                       interface_name, &p->sym->declared_at);
 	  return 1;
 	}
 
@@ -1548,8 +1684,8 @@ check_interface1 (gfc_interface *p, gfc_interface *q0,
 	if (p->sym->name == q->sym->name && p->sym->module == q->sym->module)
 	  continue;
 
-	if (p->sym->attr.flavor != FL_DERIVED
-	    && q->sym->attr.flavor != FL_DERIVED
+	if (!gfc_fl_struct (p->sym->attr.flavor)
+	    && !gfc_fl_struct (q->sym->attr.flavor)
 	    && gfc_compare_interfaces (p->sym, q->sym, q->sym->name,
 				       generic_flag, 0, NULL, 0, NULL, NULL))
 	  {
@@ -2463,7 +2599,8 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,
 	  return 0;
 	}
 
-      if (f->sym == NULL && a->expr == NULL)
+      if (!gfc_option.warn_argument_mismatch
+          || (f->sym == NULL && a->expr == NULL))
 	goto match;
 
       if (f->sym == NULL)
@@ -2514,7 +2651,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,
 	}
 
       if (!compare_parameter (f->sym, a->expr, ranks_must_agree,
-			      is_elemental, where))
+                              is_elemental, where))
 	return 0;
 
       /* TS 29113, 6.3p2.  */
@@ -3328,7 +3465,7 @@ gfc_search_interface (gfc_interface *intr, int sub_flag,
 
   for (; intr; intr = intr->next)
     {
-      if (intr->sym->attr.flavor == FL_DERIVED)
+      if (gfc_fl_struct (intr->sym->attr.flavor))
 	continue;
       if (sub_flag && intr->sym->attr.function)
 	continue;
diff --git a/gcc/fortran/intrinsic.c b/gcc/fortran/intrinsic.c
index 7d78419a76d..8cf89c7dfee 100644
--- a/gcc/fortran/intrinsic.c
+++ b/gcc/fortran/intrinsic.c
@@ -1108,6 +1108,25 @@ add_functions (void)
 	     NULL, gfc_simplify_abs, gfc_resolve_abs,
 	     a, BT_INTEGER, di, REQUIRED);
 
+  if (gfc_option.flag_dec_intrinsic_ints)
+  {
+  add_sym_1 ("babs", GFC_ISYM_ABS, CLASS_ELEMENTAL, ACTUAL_YES, BT_INTEGER, 1,
+      GFC_STD_GNU, NULL, gfc_simplify_abs, gfc_resolve_abs,
+      a, BT_INTEGER, 1, REQUIRED);
+
+  add_sym_1 ("iiabs", GFC_ISYM_ABS, CLASS_ELEMENTAL, ACTUAL_YES, BT_INTEGER, 2,
+      GFC_STD_GNU, NULL, gfc_simplify_abs, gfc_resolve_abs,
+      a, BT_INTEGER, 2, REQUIRED);
+
+  add_sym_1 ("jiabs", GFC_ISYM_ABS, CLASS_ELEMENTAL, ACTUAL_YES, BT_INTEGER, 4,
+      GFC_STD_GNU, NULL, gfc_simplify_abs, gfc_resolve_abs,
+      a, BT_INTEGER, 4, REQUIRED);
+
+  add_sym_1 ("kiabs", GFC_ISYM_ABS, CLASS_ELEMENTAL, ACTUAL_YES, BT_INTEGER, 8,
+      GFC_STD_GNU, NULL, gfc_simplify_abs, gfc_resolve_abs,
+      a, BT_INTEGER, 8, REQUIRED);
+  }
+
   add_sym_1 ("dabs", GFC_ISYM_ABS, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dd, GFC_STD_F77,
 	     gfc_check_fn_d, gfc_simplify_abs, gfc_resolve_abs,
 	     a, BT_REAL, dd, REQUIRED);
@@ -1231,7 +1250,7 @@ add_functions (void)
 	     x, BT_REAL, dd, REQUIRED);
 
   make_generic ("asin", GFC_ISYM_ASIN, GFC_STD_F77);
-  
+
   add_sym_1 ("asinh", GFC_ISYM_ASINH, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dr,
 	     GFC_STD_F2008, gfc_check_fn_rc2008, gfc_simplify_asinh,
 	     gfc_resolve_asinh, x, BT_REAL, dr, REQUIRED);
@@ -1262,7 +1281,7 @@ add_functions (void)
 	     y, BT_REAL, dr, REQUIRED, x, BT_REAL, dr, REQUIRED);
 
   make_generic ("atan", GFC_ISYM_ATAN, GFC_STD_F77);
-  
+
   add_sym_1 ("atanh", GFC_ISYM_ATANH, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dr,
 	     GFC_STD_F2008, gfc_check_fn_rc2008, gfc_simplify_atanh,
 	     gfc_resolve_atanh, x, BT_REAL, dr, REQUIRED);
@@ -1282,7 +1301,7 @@ add_functions (void)
 	     y, BT_REAL, dd, REQUIRED, x, BT_REAL, dd, REQUIRED);
 
   make_generic ("atan2", GFC_ISYM_ATAN2, GFC_STD_F77);
-  
+
   /* Bessel and Neumann functions for G77 compatibility.  */
   add_sym_1 ("besj0", GFC_ISYM_J0, CLASS_ELEMENTAL, ACTUAL_NO, BT_REAL, dr, GFC_STD_GNU,
 	     gfc_check_fn_r, gfc_simplify_bessel_j0, gfc_resolve_g77_math1,
@@ -1406,6 +1425,25 @@ add_functions (void)
 	     gfc_check_bitfcn, gfc_simplify_btest, gfc_resolve_btest,
 	     i, BT_INTEGER, di, REQUIRED, pos, BT_INTEGER, di, REQUIRED);
 
+  if (gfc_option.flag_dec_intrinsic_ints)
+  {
+  add_sym_2 ("bbtest", GFC_ISYM_BTEST, CLASS_ELEMENTAL, ACTUAL_NO, BT_LOGICAL,
+      1, GFC_STD_GNU, gfc_check_bitfcn, gfc_simplify_btest, gfc_resolve_btest,
+      i, BT_INTEGER, 1, REQUIRED, pos, BT_INTEGER, 1, REQUIRED);
+
+  add_sym_2 ("bitest", GFC_ISYM_BTEST, CLASS_ELEMENTAL, ACTUAL_NO, BT_LOGICAL,
+      2, GFC_STD_GNU, gfc_check_bitfcn, gfc_simplify_btest, gfc_resolve_btest,
+      i, BT_INTEGER, 2, REQUIRED, pos, BT_INTEGER, 2, REQUIRED);
+
+  add_sym_2 ("bjtest", GFC_ISYM_BTEST, CLASS_ELEMENTAL, ACTUAL_NO, BT_LOGICAL,
+      4, GFC_STD_GNU, gfc_check_bitfcn, gfc_simplify_btest, gfc_resolve_btest,
+      i, BT_INTEGER, 4, REQUIRED, pos, BT_INTEGER, 4, REQUIRED);
+
+  add_sym_2 ("bktest", GFC_ISYM_BTEST, CLASS_ELEMENTAL, ACTUAL_NO, BT_LOGICAL,
+      8, GFC_STD_GNU, gfc_check_bitfcn, gfc_simplify_btest, gfc_resolve_btest,
+      i, BT_INTEGER, 8, REQUIRED, pos, BT_INTEGER, 8, REQUIRED);
+  }
+
   make_generic ("btest", GFC_ISYM_BTEST, GFC_STD_F95);
 
   add_sym_2 ("ceiling", GFC_ISYM_CEILING, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, di, GFC_STD_F95,
@@ -1797,6 +1835,25 @@ add_functions (void)
 	     gfc_check_iand, gfc_simplify_iand, gfc_resolve_iand,
 	     i, BT_INTEGER, di, REQUIRED, j, BT_INTEGER, di, REQUIRED);
 
+  if (gfc_option.flag_dec_intrinsic_ints)
+  {
+  add_sym_2 ("biand", GFC_ISYM_IAND, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, 1,
+      GFC_STD_GNU, gfc_check_iand, gfc_simplify_iand, gfc_resolve_iand,
+      i, BT_INTEGER, 1, REQUIRED, j, BT_INTEGER, 1, REQUIRED);
+
+  add_sym_2 ("iiand", GFC_ISYM_IAND, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, 2,
+      GFC_STD_GNU, gfc_check_iand, gfc_simplify_iand, gfc_resolve_iand,
+      i, BT_INTEGER, 2, REQUIRED, j, BT_INTEGER, 2, REQUIRED);
+
+  add_sym_2 ("jiand", GFC_ISYM_IAND, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, 4,
+      GFC_STD_GNU, gfc_check_iand, gfc_simplify_iand, gfc_resolve_iand,
+      i, BT_INTEGER, 4, REQUIRED, j, BT_INTEGER, 4, REQUIRED);
+
+  add_sym_2 ("kiand", GFC_ISYM_IAND, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, 8,
+      GFC_STD_GNU, gfc_check_iand, gfc_simplify_iand, gfc_resolve_iand,
+      i, BT_INTEGER, 8, REQUIRED, j, BT_INTEGER, 8, REQUIRED);
+  }
+
   make_generic ("iand", GFC_ISYM_IAND, GFC_STD_F95);
 
   add_sym_2 ("and", GFC_ISYM_AND, CLASS_IMPURE, ACTUAL_NO, BT_LOGICAL,
@@ -1828,6 +1885,25 @@ add_functions (void)
 	     gfc_check_bitfcn, gfc_simplify_ibclr, gfc_resolve_ibclr,
 	     i, BT_INTEGER, di, REQUIRED, pos, BT_INTEGER, di, REQUIRED);
 
+  if (gfc_option.flag_dec_intrinsic_ints)
+  {
+  add_sym_2 ("bbclr", GFC_ISYM_IBCLR, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      1, GFC_STD_GNU, gfc_check_bitfcn, gfc_simplify_ibclr, gfc_resolve_ibclr,
+      i, BT_INTEGER, 1, REQUIRED, pos, BT_INTEGER, 1, REQUIRED);
+
+  add_sym_2 ("iibclr", GFC_ISYM_IBCLR, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      2, GFC_STD_GNU, gfc_check_bitfcn, gfc_simplify_ibclr, gfc_resolve_ibclr,
+      i, BT_INTEGER, 2, REQUIRED, pos, BT_INTEGER, 2, REQUIRED);
+
+  add_sym_2 ("jibclr", GFC_ISYM_IBCLR, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      4, GFC_STD_GNU, gfc_check_bitfcn, gfc_simplify_ibclr, gfc_resolve_ibclr,
+      i, BT_INTEGER, 4, REQUIRED, pos, BT_INTEGER, 4, REQUIRED);
+
+  add_sym_2 ("kibclr", GFC_ISYM_IBCLR, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      8, GFC_STD_GNU, gfc_check_bitfcn, gfc_simplify_ibclr, gfc_resolve_ibclr,
+      i, BT_INTEGER, 8, REQUIRED, pos, BT_INTEGER, 8, REQUIRED);
+  }
+
   make_generic ("ibclr", GFC_ISYM_IBCLR, GFC_STD_F95);
 
   add_sym_3 ("ibits", GFC_ISYM_IBITS, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, di, GFC_STD_F95,
@@ -1835,12 +1911,54 @@ add_functions (void)
 	     i, BT_INTEGER, di, REQUIRED, pos, BT_INTEGER, di, REQUIRED,
 	     ln, BT_INTEGER, di, REQUIRED);
 
+  if (gfc_option.flag_dec_intrinsic_ints)
+  {
+  add_sym_3 ("bbits", GFC_ISYM_IBITS, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      1, GFC_STD_GNU, gfc_check_ibits, gfc_simplify_ibits, gfc_resolve_ibits,
+      i, BT_INTEGER, 1, REQUIRED, pos, BT_INTEGER, 1, REQUIRED,
+      ln, BT_INTEGER, 1, REQUIRED);
+
+  add_sym_3 ("iibits", GFC_ISYM_IBITS, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      2, GFC_STD_GNU, gfc_check_ibits, gfc_simplify_ibits, gfc_resolve_ibits,
+      i, BT_INTEGER, 2, REQUIRED, pos, BT_INTEGER, 2, REQUIRED,
+      ln, BT_INTEGER, 2, REQUIRED);
+
+  add_sym_3 ("jibits", GFC_ISYM_IBITS, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      4, GFC_STD_GNU, gfc_check_ibits, gfc_simplify_ibits, gfc_resolve_ibits,
+      i, BT_INTEGER, 4, REQUIRED, pos, BT_INTEGER, 4, REQUIRED,
+      ln, BT_INTEGER, 4, REQUIRED);
+
+  add_sym_3 ("kibits", GFC_ISYM_IBITS, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      8, GFC_STD_GNU, gfc_check_ibits, gfc_simplify_ibits, gfc_resolve_ibits,
+      i, BT_INTEGER, 8, REQUIRED, pos, BT_INTEGER, 8, REQUIRED,
+      ln, BT_INTEGER, 8, REQUIRED);
+  }
+
   make_generic ("ibits", GFC_ISYM_IBITS, GFC_STD_F95);
 
   add_sym_2 ("ibset", GFC_ISYM_IBSET, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, di, GFC_STD_F95,
 	     gfc_check_bitfcn, gfc_simplify_ibset, gfc_resolve_ibset,
 	     i, BT_INTEGER, di, REQUIRED, pos, BT_INTEGER, di, REQUIRED);
 
+  if (gfc_option.flag_dec_intrinsic_ints)
+  {
+  add_sym_2 ("bbset", GFC_ISYM_IBSET, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      1, GFC_STD_GNU, gfc_check_bitfcn, gfc_simplify_ibset, gfc_resolve_ibset,
+      i, BT_INTEGER, 1, REQUIRED, pos, BT_INTEGER, 1, REQUIRED);
+
+  add_sym_2 ("iibset", GFC_ISYM_IBSET, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      2, GFC_STD_GNU, gfc_check_bitfcn, gfc_simplify_ibset, gfc_resolve_ibset,
+      i, BT_INTEGER, 2, REQUIRED, pos, BT_INTEGER, 2, REQUIRED);
+
+  add_sym_2 ("jibset", GFC_ISYM_IBSET, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      4, GFC_STD_GNU, gfc_check_bitfcn, gfc_simplify_ibset, gfc_resolve_ibset,
+      i, BT_INTEGER, 4, REQUIRED, pos, BT_INTEGER, 4, REQUIRED);
+
+  add_sym_2 ("kibset", GFC_ISYM_IBSET, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      8, GFC_STD_GNU, gfc_check_bitfcn, gfc_simplify_ibset, gfc_resolve_ibset,
+      i, BT_INTEGER, 8, REQUIRED, pos, BT_INTEGER, 8, REQUIRED);
+  }
+
   make_generic ("ibset", GFC_ISYM_IBSET, GFC_STD_F95);
 
   add_sym_2 ("ichar", GFC_ISYM_ICHAR, CLASS_ELEMENTAL, ACTUAL_NO,
@@ -1854,6 +1972,25 @@ add_functions (void)
 	     gfc_check_ieor, gfc_simplify_ieor, gfc_resolve_ieor,
 	     i, BT_INTEGER, di, REQUIRED, j, BT_INTEGER, di, REQUIRED);
 
+  if (gfc_option.flag_dec_intrinsic_ints)
+  {
+  add_sym_2 ("bieor", GFC_ISYM_IEOR, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, 1,
+      GFC_STD_GNU, gfc_check_ieor, gfc_simplify_ieor, gfc_resolve_ieor,
+      i, BT_INTEGER, 1, REQUIRED, j, BT_INTEGER, 1, REQUIRED);
+
+  add_sym_2 ("iieor", GFC_ISYM_IEOR, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, 2,
+      GFC_STD_GNU, gfc_check_ieor, gfc_simplify_ieor, gfc_resolve_ieor,
+      i, BT_INTEGER, 2, REQUIRED, j, BT_INTEGER, 2, REQUIRED);
+
+  add_sym_2 ("jieor", GFC_ISYM_IEOR, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, 4,
+      GFC_STD_GNU, gfc_check_ieor, gfc_simplify_ieor, gfc_resolve_ieor,
+      i, BT_INTEGER, 4, REQUIRED, j, BT_INTEGER, 4, REQUIRED);
+
+  add_sym_2 ("kieor", GFC_ISYM_IEOR, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, 8,
+      GFC_STD_GNU, gfc_check_ieor, gfc_simplify_ieor, gfc_resolve_ieor,
+      i, BT_INTEGER, 8, REQUIRED, j, BT_INTEGER, 8, REQUIRED);
+  }
+
   make_generic ("ieor", GFC_ISYM_IEOR, GFC_STD_F95);
 
   add_sym_2 ("xor", GFC_ISYM_XOR, CLASS_IMPURE, ACTUAL_NO, BT_LOGICAL,
@@ -1919,6 +2056,25 @@ add_functions (void)
 	     gfc_check_ior, gfc_simplify_ior, gfc_resolve_ior,
 	     i, BT_INTEGER, di, REQUIRED, j, BT_INTEGER, di, REQUIRED);
 
+  if (gfc_option.flag_dec_intrinsic_ints)
+  {
+  add_sym_2 ("bior", GFC_ISYM_IOR, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, 1,
+      GFC_STD_GNU, gfc_check_ior, gfc_simplify_ior, gfc_resolve_ior,
+      i, BT_INTEGER, 1, REQUIRED, j, BT_INTEGER, 1, REQUIRED);
+
+  add_sym_2 ("iior", GFC_ISYM_IOR, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, 2,
+      GFC_STD_GNU, gfc_check_ior, gfc_simplify_ior, gfc_resolve_ior,
+      i, BT_INTEGER, 2, REQUIRED, j, BT_INTEGER, 2, REQUIRED);
+
+  add_sym_2 ("jior", GFC_ISYM_IOR, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, 4,
+      GFC_STD_GNU, gfc_check_ior, gfc_simplify_ior, gfc_resolve_ior,
+      i, BT_INTEGER, 4, REQUIRED, j, BT_INTEGER, 4, REQUIRED);
+
+  add_sym_2 ("kior", GFC_ISYM_IOR, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, 8,
+      GFC_STD_GNU, gfc_check_ior, gfc_simplify_ior, gfc_resolve_ior,
+      i, BT_INTEGER, 8, REQUIRED, j, BT_INTEGER, 8, REQUIRED);
+  }
+
   make_generic ("ior", GFC_ISYM_IOR, GFC_STD_F95);
 
   add_sym_2 ("or", GFC_ISYM_OR, CLASS_IMPURE, ACTUAL_NO, BT_LOGICAL,
@@ -1986,6 +2142,25 @@ add_functions (void)
 	     gfc_check_ishft, gfc_simplify_ishft, gfc_resolve_ishft,
 	     i, BT_INTEGER, di, REQUIRED, sh, BT_INTEGER, di, REQUIRED);
 
+  if (gfc_option.flag_dec_intrinsic_ints)
+  {
+  add_sym_2 ("bshft", GFC_ISYM_ISHFT, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      1, GFC_STD_GNU, gfc_check_ishft, gfc_simplify_ishft, gfc_resolve_ishft,
+      i, BT_INTEGER, 1, REQUIRED, sh, BT_INTEGER, 1, REQUIRED);
+
+  add_sym_2 ("iishft", GFC_ISYM_ISHFT, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      2, GFC_STD_GNU, gfc_check_ishft, gfc_simplify_ishft, gfc_resolve_ishft,
+      i, BT_INTEGER, 2, REQUIRED, sh, BT_INTEGER, 2, REQUIRED);
+
+  add_sym_2 ("jishft", GFC_ISYM_ISHFT, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      4, GFC_STD_GNU, gfc_check_ishft, gfc_simplify_ishft, gfc_resolve_ishft,
+      i, BT_INTEGER, 4, REQUIRED, sh, BT_INTEGER, 4, REQUIRED);
+
+  add_sym_2 ("kishft", GFC_ISYM_ISHFT, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      8, GFC_STD_GNU, gfc_check_ishft, gfc_simplify_ishft, gfc_resolve_ishft,
+      i, BT_INTEGER, 8, REQUIRED, sh, BT_INTEGER, 8, REQUIRED);
+  }
+
   make_generic ("ishft", GFC_ISYM_ISHFT, GFC_STD_F95);
 
   add_sym_3 ("ishftc", GFC_ISYM_ISHFTC, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, di, GFC_STD_F95,
@@ -1993,6 +2168,29 @@ add_functions (void)
 	     i, BT_INTEGER, di, REQUIRED, sh, BT_INTEGER, di, REQUIRED,
 	     sz, BT_INTEGER, di, OPTIONAL);
 
+  if (gfc_option.flag_dec_intrinsic_ints)
+  {
+  add_sym_3 ("bshftc", GFC_ISYM_ISHFTC, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      1, GFC_STD_GNU, gfc_check_ishftc, gfc_simplify_ishftc, gfc_resolve_ishftc,
+      i, BT_INTEGER, 1, REQUIRED, sh, BT_INTEGER, 1, REQUIRED,
+      sz, BT_INTEGER, 1, OPTIONAL);
+
+  add_sym_3 ("iishftc", GFC_ISYM_ISHFTC, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      2, GFC_STD_GNU, gfc_check_ishftc, gfc_simplify_ishftc, gfc_resolve_ishftc,
+      i, BT_INTEGER, 2, REQUIRED, sh, BT_INTEGER, 2, REQUIRED,
+      sz, BT_INTEGER, 2, OPTIONAL);
+
+  add_sym_3 ("jishftc", GFC_ISYM_ISHFTC, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      4, GFC_STD_GNU, gfc_check_ishftc, gfc_simplify_ishftc, gfc_resolve_ishftc,
+      i, BT_INTEGER, 4, REQUIRED, sh, BT_INTEGER, 4, REQUIRED,
+      sz, BT_INTEGER, 4, OPTIONAL);
+
+  add_sym_3 ("kishftc", GFC_ISYM_ISHFTC, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      8, GFC_STD_GNU, gfc_check_ishftc, gfc_simplify_ishftc, gfc_resolve_ishftc,
+      i, BT_INTEGER, 8, REQUIRED, sh, BT_INTEGER, 8, REQUIRED,
+      sz, BT_INTEGER, 8, OPTIONAL);
+  }
+
   make_generic ("ishftc", GFC_ISYM_ISHFTC, GFC_STD_F95);
 
   add_sym_2 ("kill", GFC_ISYM_KILL, CLASS_IMPURE, ACTUAL_NO, BT_INTEGER,
@@ -2311,6 +2509,25 @@ add_functions (void)
 	     gfc_check_x_yd, gfc_simplify_mod, gfc_resolve_mod,
 	     a, BT_REAL, dd, REQUIRED, p, BT_REAL, dd, REQUIRED);
 
+  if (gfc_option.flag_dec_intrinsic_ints)
+  {
+  add_sym_2 ("bmod", GFC_ISYM_MOD, CLASS_ELEMENTAL, ACTUAL_YES, BT_INTEGER, 1,
+      GFC_STD_GNU, gfc_check_a_p, gfc_simplify_mod, gfc_resolve_mod,
+      a, BT_INTEGER, 1, REQUIRED, p, BT_INTEGER, 1, REQUIRED);
+
+  add_sym_2 ("imod", GFC_ISYM_MOD, CLASS_ELEMENTAL, ACTUAL_YES, BT_INTEGER, 2,
+      GFC_STD_GNU, gfc_check_a_p, gfc_simplify_mod, gfc_resolve_mod,
+      a, BT_INTEGER, 2, REQUIRED, p, BT_INTEGER, 2, REQUIRED);
+
+  add_sym_2 ("jmod", GFC_ISYM_MOD, CLASS_ELEMENTAL, ACTUAL_YES, BT_INTEGER, 4,
+      GFC_STD_GNU, gfc_check_a_p, gfc_simplify_mod, gfc_resolve_mod,
+      a, BT_INTEGER, 4, REQUIRED, p, BT_INTEGER, 4, REQUIRED);
+
+  add_sym_2 ("kmod", GFC_ISYM_MOD, CLASS_ELEMENTAL, ACTUAL_YES, BT_INTEGER, 8,
+      GFC_STD_GNU, gfc_check_a_p, gfc_simplify_mod, gfc_resolve_mod,
+      a, BT_INTEGER, 8, REQUIRED, p, BT_INTEGER, 8, REQUIRED);
+  }
+
   make_generic ("mod", GFC_ISYM_MOD, GFC_STD_F77);
 
   add_sym_2 ("modulo", GFC_ISYM_MODULO, CLASS_ELEMENTAL, ACTUAL_NO, BT_REAL, di, GFC_STD_F95,
@@ -2345,6 +2562,25 @@ add_functions (void)
 	     gfc_check_i, gfc_simplify_not, gfc_resolve_not,
 	     i, BT_INTEGER, di, REQUIRED);
 
+  if (gfc_option.flag_dec_intrinsic_ints)
+  {
+  add_sym_1 ("bnot", GFC_ISYM_NOT, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, 1,
+      GFC_STD_GNU, gfc_check_i, gfc_simplify_not, gfc_resolve_not,
+      i, BT_INTEGER, 1, REQUIRED);
+
+  add_sym_1 ("inot", GFC_ISYM_NOT, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, 2,
+      GFC_STD_GNU, gfc_check_i, gfc_simplify_not, gfc_resolve_not,
+      i, BT_INTEGER, 2, REQUIRED);
+
+  add_sym_1 ("jnot", GFC_ISYM_NOT, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, 4,
+      GFC_STD_GNU, gfc_check_i, gfc_simplify_not, gfc_resolve_not,
+      i, BT_INTEGER, 4, REQUIRED);
+
+  add_sym_1 ("knot", GFC_ISYM_NOT, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, 8,
+      GFC_STD_GNU, gfc_check_i, gfc_simplify_not, gfc_resolve_not,
+      i, BT_INTEGER, 8, REQUIRED);
+  }
+
   make_generic ("not", GFC_ISYM_NOT, GFC_STD_F95);
 
   add_sym_2 ("norm2", GFC_ISYM_NORM2, CLASS_TRANSFORMATIONAL, ACTUAL_NO, BT_REAL, dr,
@@ -2453,6 +2689,21 @@ add_functions (void)
 	     gfc_check_float, gfc_simplify_float, NULL,
 	     a, BT_INTEGER, di, REQUIRED);
 
+  if (gfc_option.flag_dec_intrinsic_ints)
+  {
+  add_sym_1 ("floati", GFC_ISYM_REAL, CLASS_ELEMENTAL, ACTUAL_NO, BT_REAL, dr,
+      GFC_STD_GNU, gfc_check_float, gfc_simplify_float, NULL,
+      a, BT_INTEGER, 2, REQUIRED);
+
+  add_sym_1 ("floatj", GFC_ISYM_REAL, CLASS_ELEMENTAL, ACTUAL_NO, BT_REAL, dr,
+      GFC_STD_GNU, gfc_check_float, gfc_simplify_float, NULL,
+      a, BT_INTEGER, 4, REQUIRED);
+
+  add_sym_1 ("floatk", GFC_ISYM_REAL, CLASS_ELEMENTAL, ACTUAL_NO, BT_REAL, dr,
+      GFC_STD_GNU, gfc_check_float, gfc_simplify_float, NULL,
+      a, BT_INTEGER, 8, REQUIRED);
+  }
+
   add_sym_1 ("dfloat", GFC_ISYM_REAL, CLASS_ELEMENTAL, ACTUAL_NO, BT_REAL, dd, GFC_STD_GNU,
 	     gfc_check_float, gfc_simplify_dble, gfc_resolve_dble,
 	     a, BT_REAL, dr, REQUIRED);
@@ -2857,6 +3108,119 @@ add_functions (void)
 	     x, BT_UNKNOWN, 0, REQUIRED);
 		
   make_generic ("loc", GFC_ISYM_LOC, GFC_STD_GNU);
+
+  /* Extended math functions provided as DEC extensions. */
+
+  if (gfc_option.flag_dec_math)
+  {
+    add_sym_1 ("acosd", GFC_ISYM_ACOS, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,
+        dr, GFC_STD_GNU,
+        gfc_check_fn_r, gfc_simplify_atrigd, gfc_resolve_atrigd,
+        x, BT_REAL, dr, REQUIRED);
+
+    add_sym_1 ("dacosd", GFC_ISYM_ACOS, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,
+        dd, GFC_STD_GNU,
+        gfc_check_fn_d, gfc_simplify_atrigd, gfc_resolve_atrigd,
+        x, BT_REAL, dd, REQUIRED);
+
+    make_generic ("acosd", GFC_ISYM_ACOS, GFC_STD_GNU);
+
+    add_sym_1 ("asind", GFC_ISYM_ASIN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,
+        dr, GFC_STD_GNU,
+        gfc_check_fn_r, gfc_simplify_atrigd, gfc_resolve_atrigd,
+        x, BT_REAL, dr, REQUIRED);
+
+    add_sym_1 ("dasind", GFC_ISYM_ASIN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,
+        dd, GFC_STD_GNU,
+        gfc_check_fn_d, gfc_simplify_atrigd, gfc_resolve_atrigd,
+        x, BT_REAL, dd, REQUIRED);
+
+    make_generic ("asind", GFC_ISYM_ASIN, GFC_STD_GNU);
+
+    add_sym_1 ("atand", GFC_ISYM_ATAN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,
+        dr, GFC_STD_GNU,
+        gfc_check_fn_r, gfc_simplify_atrigd, gfc_resolve_atrigd,
+        x, BT_REAL, dr, REQUIRED);
+
+    add_sym_1 ("datand", GFC_ISYM_ATAN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,
+        dd, GFC_STD_GNU,
+        gfc_check_fn_d, gfc_simplify_atrigd, gfc_resolve_atrigd,
+        x, BT_REAL, dd, REQUIRED);
+
+    make_generic ("atand", GFC_ISYM_ATAN, GFC_STD_GNU);
+
+    add_sym_2 ("atan2d",GFC_ISYM_ATAN2,CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,
+        dr, GFC_STD_GNU,
+        gfc_check_atan2, gfc_simplify_atan2d, gfc_resolve_atan2d,
+        y, BT_REAL, dr, REQUIRED, x, BT_REAL, dr, REQUIRED);
+
+    add_sym_2 ("datan2d",GFC_ISYM_ATAN2,CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,
+        dd, GFC_STD_GNU,
+        gfc_check_datan2, gfc_simplify_atan2d, gfc_resolve_atan2d,
+        y, BT_REAL, dd, REQUIRED, x, BT_REAL, dd, REQUIRED);
+
+    make_generic ("atan2d", GFC_ISYM_ATAN2, GFC_STD_GNU);
+
+    add_sym_1 ("cosd", GFC_ISYM_COS, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,
+        dr, GFC_STD_GNU,
+        gfc_check_fn_r, gfc_simplify_trigd, gfc_resolve_trigd,
+        x, BT_REAL, dr, REQUIRED);
+
+    add_sym_1 ("dcosd", GFC_ISYM_COS, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,
+        dd, GFC_STD_GNU,
+        gfc_check_fn_d, gfc_simplify_trigd, gfc_resolve_trigd,
+        x, BT_REAL, dd, REQUIRED);
+
+    make_generic ("cosd", GFC_ISYM_COS, GFC_STD_GNU);
+
+    add_sym_1 ("cotan", GFC_ISYM_COTAN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,
+        dr, GFC_STD_GNU,
+        gfc_check_fn_rc2008, gfc_simplify_cotan, gfc_resolve_cotan,
+        x, BT_REAL, dr, REQUIRED);
+
+    add_sym_1 ("dcotan", GFC_ISYM_COTAN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,
+        dd, GFC_STD_GNU,
+        gfc_check_fn_d, gfc_simplify_cotan, gfc_resolve_cotan,
+        x, BT_REAL, dd, REQUIRED);
+
+    make_generic ("cotan", GFC_ISYM_COTAN, GFC_STD_GNU);
+
+    add_sym_1 ("cotand", GFC_ISYM_COTAN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,
+        dr, GFC_STD_GNU,
+        gfc_check_fn_r, gfc_simplify_trigd, gfc_resolve_trigd,
+        x, BT_REAL, dr, REQUIRED);
+
+    add_sym_1 ("dcotand",GFC_ISYM_COTAN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,
+        dd, GFC_STD_GNU,
+        gfc_check_fn_d, gfc_simplify_trigd, gfc_resolve_trigd,
+        x, BT_REAL, dd, REQUIRED);
+
+    make_generic ("cotand", GFC_ISYM_COTAN, GFC_STD_GNU);
+
+    add_sym_1 ("sind", GFC_ISYM_SIN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,
+        dr, GFC_STD_GNU,
+        gfc_check_fn_r, gfc_simplify_trigd, gfc_resolve_trigd,
+        x, BT_REAL, dr, REQUIRED);
+
+    add_sym_1 ("dsind", GFC_ISYM_SIN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,
+        dd, GFC_STD_GNU,
+        gfc_check_fn_d, gfc_simplify_trigd, gfc_resolve_trigd,
+        x, BT_REAL, dd, REQUIRED);
+
+    make_generic ("sind", GFC_ISYM_SIN, GFC_STD_GNU);
+
+    add_sym_1 ("tand", GFC_ISYM_TAN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,
+        dr, GFC_STD_GNU,
+        gfc_check_fn_r, gfc_simplify_trigd, gfc_resolve_trigd,
+        x, BT_REAL, dr, REQUIRED);
+    
+    add_sym_1 ("dtand", GFC_ISYM_TAN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL,
+        dd, GFC_STD_GNU,
+        gfc_check_fn_d, gfc_simplify_trigd, gfc_resolve_trigd,
+        x, BT_REAL, dd, REQUIRED);
+
+    make_generic ("tand", GFC_ISYM_TAN, GFC_STD_GNU);
+  }
 }
 
 
@@ -3044,6 +3408,42 @@ add_subroutines (void)
 	      t, BT_INTEGER, di, REQUIRED, INTENT_INOUT,
 	      tp, BT_INTEGER, di, REQUIRED, INTENT_IN);
 
+  add_sym_5s ("bmvbits", GFC_ISYM_MVBITS, CLASS_ELEMENTAL, BT_UNKNOWN, 0,
+	      GFC_STD_F95, gfc_check_mvbits, gfc_simplify_mvbits,
+	      gfc_resolve_mvbits,
+	      f, BT_INTEGER, 1, REQUIRED, INTENT_IN,
+	      fp, BT_INTEGER, di, REQUIRED, INTENT_IN,
+	      ln, BT_INTEGER, di, REQUIRED, INTENT_IN,
+	      t, BT_INTEGER, 1, REQUIRED, INTENT_INOUT,
+	      tp, BT_INTEGER, di, REQUIRED, INTENT_IN);
+
+  add_sym_5s ("imvbits", GFC_ISYM_MVBITS, CLASS_ELEMENTAL, BT_UNKNOWN, 0,
+	      GFC_STD_F95, gfc_check_mvbits, gfc_simplify_mvbits,
+	      gfc_resolve_mvbits,
+	      f, BT_INTEGER, 2, REQUIRED, INTENT_IN,
+	      fp, BT_INTEGER, di, REQUIRED, INTENT_IN,
+	      ln, BT_INTEGER, di, REQUIRED, INTENT_IN,
+	      t, BT_INTEGER, 2, REQUIRED, INTENT_INOUT,
+	      tp, BT_INTEGER, di, REQUIRED, INTENT_IN);
+
+  add_sym_5s ("jmvbits", GFC_ISYM_MVBITS, CLASS_ELEMENTAL, BT_UNKNOWN, 0,
+	      GFC_STD_F95, gfc_check_mvbits, gfc_simplify_mvbits,
+	      gfc_resolve_mvbits,
+	      f, BT_INTEGER, 4, REQUIRED, INTENT_IN,
+	      fp, BT_INTEGER, di, REQUIRED, INTENT_IN,
+	      ln, BT_INTEGER, di, REQUIRED, INTENT_IN,
+	      t, BT_INTEGER, 4, REQUIRED, INTENT_INOUT,
+	      tp, BT_INTEGER, di, REQUIRED, INTENT_IN);
+
+  add_sym_5s ("kmvbits", GFC_ISYM_MVBITS, CLASS_ELEMENTAL, BT_UNKNOWN, 0,
+	      GFC_STD_F95, gfc_check_mvbits, gfc_simplify_mvbits,
+	      gfc_resolve_mvbits,
+	      f, BT_INTEGER, 8, REQUIRED, INTENT_IN,
+	      fp, BT_INTEGER, di, REQUIRED, INTENT_IN,
+	      ln, BT_INTEGER, di, REQUIRED, INTENT_IN,
+	      t, BT_INTEGER, 8, REQUIRED, INTENT_INOUT,
+	      tp, BT_INTEGER, di, REQUIRED, INTENT_IN);
+
   add_sym_1s ("random_number", GFC_ISYM_RANDOM_NUMBER, CLASS_IMPURE,
 	      BT_UNKNOWN, 0, GFC_STD_F95,
 	      gfc_check_random_number, NULL, gfc_resolve_random_number,
@@ -3249,6 +3649,7 @@ add_conv (bt from_type, int from_kind, bt to_type, int to_kind, int standard)
 static void
 add_conversions (void)
 {
+  int std;
   int i, j;
 
   /* Integer-Integer conversions.  */
@@ -3336,14 +3737,18 @@ add_conversions (void)
       }
 
   /* Integer-Logical and Logical-Integer conversions.  */
-  if ((gfc_option.allow_std & GFC_STD_LEGACY) != 0)
+  std = GFC_STD_LEGACY;
+  if (gfc_option.flag_lazy_logicals)
+    std = GFC_STD_GNU;
+  if (gfc_option.flag_lazy_logicals
+      || (gfc_option.allow_std & GFC_STD_LEGACY) != 0)
     for (i=0; gfc_integer_kinds[i].kind; i++)
       for (j=0; gfc_logical_kinds[j].kind; j++)
 	{
 	  add_conv (BT_INTEGER, gfc_integer_kinds[i].kind,
-		    BT_LOGICAL, gfc_logical_kinds[j].kind, GFC_STD_LEGACY);
+		    BT_LOGICAL, gfc_logical_kinds[j].kind, std);
 	  add_conv (BT_LOGICAL, gfc_logical_kinds[j].kind,
-		    BT_INTEGER, gfc_integer_kinds[i].kind, GFC_STD_LEGACY);
+		    BT_INTEGER, gfc_integer_kinds[i].kind, std);
 	}
 }
 
@@ -3775,6 +4180,26 @@ do_simplify (gfc_intrinsic_sym *specific, gfc_expr *e)
       goto finish;
     }
 
+  /* Degree trig functions just wrap trig builtins with deg/rad conversions. */
+  if (specific->simplify.f1 == gfc_simplify_trigd)
+    {
+      result = gfc_simplify_trigd (e);
+      goto finish;
+    }
+
+  if (specific->simplify.f1 == gfc_simplify_atrigd)
+    {
+      result = gfc_simplify_atrigd (e);
+      goto finish;
+    }
+
+  /* Some other functions needs to know e to wrap the original call */
+  if (specific->simplify.f1 == gfc_simplify_cotan)
+    {
+      result = gfc_simplify_cotan (e);
+      goto finish;
+    }
+
   if (specific->simplify.f1 == NULL)
     {
       result = NULL;
@@ -4304,8 +4729,12 @@ gfc_convert_type_warn (gfc_expr *expr, gfc_typespec *ts, int eflag, int wflag)
   if (sym == NULL)
     goto bad;
 
-  /* At this point, a conversion is necessary. A warning may be needed.  */
-  if ((gfc_option.warn_std & sym->standard) != 0)
+  /* At this point, a conversion is necessary. A warning may be needed.
+     With -flazy-logicals, don't warn between integers and logicals.  */
+  if ((gfc_option.warn_std & sym->standard) != 0
+      && !(gfc_option.flag_lazy_logicals 
+           && (from_ts.type == BT_INTEGER || from_ts.type == BT_LOGICAL)
+           && (    ts->type == BT_INTEGER ||     ts->type == BT_LOGICAL)))
     {
       gfc_warning_now ("Extension: Conversion from %s to %s at %L",
 		       gfc_typename (&from_ts), gfc_typename (ts),
diff --git a/gcc/fortran/intrinsic.h b/gcc/fortran/intrinsic.h
index 5d502855269..24e87150a63 100644
--- a/gcc/fortran/intrinsic.h
+++ b/gcc/fortran/intrinsic.h
@@ -67,6 +67,7 @@ gfc_try gfc_check_float (gfc_expr *);
 gfc_try gfc_check_fstat (gfc_expr *, gfc_expr *);
 gfc_try gfc_check_ftell (gfc_expr *);
 gfc_try gfc_check_fn_c (gfc_expr *);
+gfc_try gfc_check_fn_q (gfc_expr *);
 gfc_try gfc_check_fn_d (gfc_expr *);
 gfc_try gfc_check_fn_r (gfc_expr *);
 gfc_try gfc_check_fn_rc (gfc_expr *);
@@ -221,6 +222,7 @@ gfc_expr *gfc_simplify_adjustr (gfc_expr *);
 gfc_expr *gfc_simplify_aimag (gfc_expr *);
 gfc_expr *gfc_simplify_aint (gfc_expr *, gfc_expr *);
 gfc_expr *gfc_simplify_all (gfc_expr *, gfc_expr *);
+gfc_expr *gfc_simplify_atrigd (gfc_expr *);
 gfc_expr *gfc_simplify_dint (gfc_expr *);
 gfc_expr *gfc_simplify_anint (gfc_expr *, gfc_expr *);
 gfc_expr *gfc_simplify_dnint (gfc_expr *);
@@ -231,6 +233,7 @@ gfc_expr *gfc_simplify_asinh (gfc_expr *);
 gfc_expr *gfc_simplify_atan (gfc_expr *);
 gfc_expr *gfc_simplify_atanh (gfc_expr *);
 gfc_expr *gfc_simplify_atan2 (gfc_expr *, gfc_expr *);
+gfc_expr *gfc_simplify_atan2d (gfc_expr *, gfc_expr *);
 gfc_expr *gfc_simplify_bessel_j0 (gfc_expr *);
 gfc_expr *gfc_simplify_bessel_j1 (gfc_expr *);
 gfc_expr *gfc_simplify_bessel_jn (gfc_expr *, gfc_expr *);
@@ -254,6 +257,7 @@ gfc_expr *gfc_simplify_complex (gfc_expr *, gfc_expr *);
 gfc_expr *gfc_simplify_conjg (gfc_expr *);
 gfc_expr *gfc_simplify_cos (gfc_expr *);
 gfc_expr *gfc_simplify_cosh (gfc_expr *);
+gfc_expr *gfc_simplify_cotan (gfc_expr *);
 gfc_expr *gfc_simplify_count (gfc_expr *, gfc_expr *, gfc_expr *);
 gfc_expr *gfc_simplify_dcmplx (gfc_expr *, gfc_expr *);
 gfc_expr *gfc_simplify_dble (gfc_expr *);
@@ -383,6 +387,7 @@ gfc_expr *gfc_simplify_tiny (gfc_expr *);
 gfc_expr *gfc_simplify_trailz (gfc_expr *);
 gfc_expr *gfc_simplify_transfer (gfc_expr *, gfc_expr *, gfc_expr *);
 gfc_expr *gfc_simplify_transpose (gfc_expr *);
+gfc_expr *gfc_simplify_trigd (gfc_expr *);
 gfc_expr *gfc_simplify_trim (gfc_expr *);
 gfc_expr *gfc_simplify_ubound (gfc_expr *, gfc_expr *, gfc_expr *);
 gfc_expr *gfc_simplify_ucobound (gfc_expr *, gfc_expr *, gfc_expr *);
@@ -416,6 +421,7 @@ void gfc_resolve_asinh (gfc_expr *, gfc_expr *);
 void gfc_resolve_atan (gfc_expr *, gfc_expr *);
 void gfc_resolve_atanh (gfc_expr *, gfc_expr *);
 void gfc_resolve_atan2 (gfc_expr *, gfc_expr *, gfc_expr *);
+void gfc_resolve_atan2d (gfc_expr *, gfc_expr *, gfc_expr *);
 void gfc_resolve_atomic_def (gfc_code *);
 void gfc_resolve_atomic_ref (gfc_code *);
 void gfc_resolve_besn (gfc_expr *, gfc_expr *, gfc_expr *);
@@ -432,6 +438,7 @@ void gfc_resolve_conjg (gfc_expr *, gfc_expr *);
 void gfc_resolve_cos (gfc_expr *, gfc_expr *);
 void gfc_resolve_cosh (gfc_expr *, gfc_expr *);
 void gfc_resolve_count (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);
+void gfc_resolve_cotan (gfc_expr *, gfc_expr *);
 void gfc_resolve_cshift (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);
 void gfc_resolve_ctime (gfc_expr *, gfc_expr *);
 void gfc_resolve_dble (gfc_expr *, gfc_expr *);
@@ -562,6 +569,8 @@ void gfc_resolve_time (gfc_expr *);
 void gfc_resolve_time8 (gfc_expr *);
 void gfc_resolve_transfer (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);
 void gfc_resolve_transpose (gfc_expr *, gfc_expr *);
+void gfc_resolve_trigd (gfc_expr *, gfc_expr *);
+void gfc_resolve_atrigd (gfc_expr *, gfc_expr *);
 void gfc_resolve_trim (gfc_expr *, gfc_expr *);
 void gfc_resolve_ttynam (gfc_expr *, gfc_expr *);
 void gfc_resolve_ubound (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);
diff --git a/gcc/fortran/intrinsic.texi b/gcc/fortran/intrinsic.texi
index a3b80aa779c..fa2080ef0d2 100644
--- a/gcc/fortran/intrinsic.texi
+++ b/gcc/fortran/intrinsic.texi
@@ -23,6 +23,9 @@ Some basic guidelines for editing this document:
 @end ignore
 
 @tex
+\gdef\acosd{\mathop{\rm acosd}\nolimits}
+\gdef\asind{\mathop{\rm asind}\nolimits}
+\gdef\atand{\mathop{\rm atand}\nolimits}
 \gdef\acos{\mathop{\rm acos}\nolimits}
 \gdef\asin{\mathop{\rm asin}\nolimits}
 \gdef\atan{\mathop{\rm atan}\nolimits}
@@ -43,6 +46,7 @@ Some basic guidelines for editing this document:
 * @code{ACCESS}:        ACCESS,    Checks file access modes
 * @code{ACHAR}:         ACHAR,     Character in @acronym{ASCII} collating sequence
 * @code{ACOS}:          ACOS,      Arccosine function
+* @code{ACOSD}:         ACOSD,     Arccosine function in degrees
 * @code{ACOSH}:         ACOSH,     Inverse hyperbolic cosine function
 * @code{ADJUSTL}:       ADJUSTL,   Left adjust a string
 * @code{ADJUSTR}:       ADJUSTR,   Right adjust a string
@@ -55,10 +59,13 @@ Some basic guidelines for editing this document:
 * @code{ANINT}:         ANINT,     Nearest whole number
 * @code{ANY}:           ANY,       Determine if any values are true
 * @code{ASIN}:          ASIN,      Arcsine function
+* @code{ASIND}:         ASIND,     Arcsine function in degrees
 * @code{ASINH}:         ASINH,     Inverse hyperbolic sine function
 * @code{ASSOCIATED}:    ASSOCIATED, Status of a pointer or pointer/target pair
 * @code{ATAN}:          ATAN,      Arctangent function
+* @code{ATAND}:         ATAND,     Arctangent function in degrees
 * @code{ATAN2}:         ATAN2,     Arctangent function
+* @code{ATAN2D}:        ATAN2D,    Arctangent function in degrees
 * @code{ATANH}:         ATANH,     Inverse hyperbolic tangent function
 * @code{ATOMIC_DEFINE}: ATOMIC_DEFINE, Setting a variable atomically
 * @code{ATOMIC_REF}:    ATOMIC_REF, Obtaining the value of a variable atomically
@@ -92,7 +99,10 @@ Some basic guidelines for editing this document:
 * @code{COMPLEX}:       COMPLEX,   Complex conversion function
 * @code{CONJG}:         CONJG,     Complex conjugate function
 * @code{COS}:           COS,       Cosine function
+* @code{COSD}:          COSD,      Cosine function, degree-valued paratemer
 * @code{COSH}:          COSH,      Hyperbolic cosine function
+* @code{COTAN}:         COTAN,     Cotangent function
+* @code{COTAND}:        COTAND,    Cotangent function, degree-valued parameter
 * @code{COUNT}:         COUNT,     Count occurrences of TRUE in an array
 * @code{CPU_TIME}:      CPU_TIME,  CPU time subroutine
 * @code{CSHIFT}:        CSHIFT,    Circular shift elements of an array
@@ -262,6 +272,7 @@ Some basic guidelines for editing this document:
 * @code{SIGN}:          SIGN,      Sign copying function
 * @code{SIGNAL}:        SIGNAL,    Signal handling subroutine (or function)
 * @code{SIN}:           SIN,       Sine function
+* @code{SIND}:          SIND,      Sine function, degree-valued parameter
 * @code{SINH}:          SINH,      Hyperbolic sine function
 * @code{SIZE}:          SIZE,      Function to determine the size of an array
 * @code{SIZEOF}:        SIZEOF,    Determine the size in bytes of an expression
@@ -277,6 +288,7 @@ Some basic guidelines for editing this document:
 * @code{SYSTEM}:        SYSTEM,    Execute a shell command
 * @code{SYSTEM_CLOCK}:  SYSTEM_CLOCK, Time function
 * @code{TAN}:           TAN,       Tangent function
+* @code{TAND}:          TAND,      Tangent function, degree-valued parameter
 * @code{TANH}:          TANH,      Hyperbolic tangent function
 * @code{THIS_IMAGE}:    THIS_IMAGE, Cosubscript index of this image
 * @code{TIME}:          TIME,      Time function
@@ -384,6 +396,10 @@ end program test_abort
 @fnindex CABS
 @fnindex DABS
 @fnindex IABS
+@fnindex BABS
+@fnindex IIABS
+@fnindex JIABS
+@fnindex KIABS
 @fnindex ZABS
 @fnindex CDABS
 @cindex absolute value
@@ -433,6 +449,14 @@ end program test_abs
 @item @code{IABS(A)}  @tab @code{INTEGER(4) A} @tab @code{INTEGER(4)} @tab Fortran 77 and later
 @item @code{ZABS(A)}  @tab @code{COMPLEX(8) A} @tab @code{COMPLEX(8)} @tab GNU extension
 @item @code{CDABS(A)} @tab @code{COMPLEX(8) A} @tab @code{COMPLEX(8)} @tab GNU extension
+@item @code{BABS(A)}  @tab @code{INTEGER(1) A} @tab @code{INTEGER(1)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{IIABS(A)}  @tab @code{INTEGER(2) A} @tab @code{INTEGER(2)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{JIABS(A)}  @tab @code{INTEGER(4) A} @tab @code{INTEGER(4)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{KIABS(A)}  @tab @code{INTEGER(8) A} @tab @code{INTEGER(8)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
 @end multitable
 @end table
 
@@ -596,6 +620,62 @@ end program test_acos
 
 @item @emph{See also}:
 Inverse function: @ref{COS}
+Degree version: @ref{ACOSD}
+
+@end table
+
+
+
+@node ACOSD
+@section @code{ACOSD} --- Arccosine function in degrees
+@fnindex ACOSD
+@fnindex DACOSD
+@cindex trigonometric function, cosine, inverse, degrees
+@cindex cosine, inverse, degrees
+
+@table @asis
+@item @emph{Description}:
+@code{ACOSD(X)} computes the arccosine of @var{X} in degrees (inverse of
+@code{COSD(X)}).
+
+@item @emph{Standard}:
+None. Enabled with @option{-fdec-math}
+
+@item @emph{Class}:
+Elemental function
+
+@item @emph{Syntax}:
+@code{RESULT = ACOSD(X)}
+
+@item @emph{Arguments}:
+@multitable @columnfractions .15 .70
+@item @var{X} @tab The type shall be @code{REAL} with a magnitude that is
+less than or equal to one.
+@end multitable
+
+@item @emph{Return value}:
+The return value is of the same type and kind as @var{X}.
+The result is in degrees and lies in the range
+-90 @leq{} @math{\acosd(x)} @leq{} 90.
+
+@item @emph{Example}:
+@smallexample
+program test_acosd
+  real(8) :: x = 0.866_8
+  x = acosd(x) ! => 30.0
+end program test_acosd
+@end smallexample
+
+@item @emph{Specific names}:
+@multitable @columnfractions .20 .20 .20 .25
+@item Name            @tab Argument         @tab Return type     @tab Standard
+@item @code{ACOSD(X)}  @tab @code{REAL(4) X} @tab @code{REAL(4)}  @tab None
+@item @code{DACOSD(X)} @tab @code{REAL(8) X} @tab @code{REAL(8)}  @tab None
+@end multitable
+
+@item @emph{See also}:
+Inverse function: @ref{COSD}
+Radian version: @ref{ACOS}
 
 @end table
 
@@ -1246,6 +1326,62 @@ end program test_asin
 
 @item @emph{See also}:
 Inverse function: @ref{SIN}
+Degree version: @ref{ASIND}
+
+@end table
+
+
+
+@node ASIND
+@section @code{ASIND} --- Arcsine function in degrees
+@fnindex ASIND
+@fnindex DASIND
+@cindex trigonometric function, sine, inverse, degrees
+@cindex sine, inverse, degrees
+
+@table @asis
+@item @emph{Description}:
+@code{ASIND(X)} computes the arcsine of its @var{X} in degrees (inverse of
+@code{SIND(X)}).
+
+@item @emph{Standard}:
+None. Enabled with @option{-fdec-math}
+
+@item @emph{Class}:
+Elemental function
+
+@item @emph{Syntax}:
+@code{RESULT = ASIND(X)}
+
+@item @emph{Arguments}:
+@multitable @columnfractions .15 .70
+@item @var{X} @tab The type shall be @code{REAL} and a magnitude that is
+less than or equal to one.
+@end multitable
+
+@item @emph{Return value}:
+The return value is of the same type and kind as @var{X}.
+The result is in degrees and lies in the range
+-90 @leq{} @math{\asind(x)} @leq{} 90.
+
+@item @emph{Example}:
+@smallexample
+program test_asind
+  real(8) :: x = 0.866_8
+  x = asind(x) ! => 60.0
+end program test_asind
+@end smallexample
+
+@item @emph{Specific names}:
+@multitable @columnfractions .20 .20 .20 .25
+@item Name            @tab Argument          @tab Return type       @tab Standard
+@item @code{ASIND(X)}  @tab @code{REAL(4) X}  @tab @code{REAL(4)}    @tab None
+@item @code{DASIND(X)} @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab None
+@end multitable
+
+@item @emph{See also}:
+Inverse function: @ref{SIND}
+Radian version: @ref{ASIN}
 
 @end table
 
@@ -1435,6 +1571,63 @@ end program test_atan
 
 @item @emph{See also}:
 Inverse function: @ref{TAN}
+Degree version: @ref{ATAND}
+
+@end table
+
+
+
+@node ATAND
+@section @code{ATAND} --- Arctangent function in degrees
+@fnindex ATAND
+@fnindex DATAND
+@cindex trigonometric function, tangent, inverse, degrees
+@cindex tangent, inverse, degrees
+
+@table @asis
+@item @emph{Description}:
+@code{ATAND(X)} computes the arctangent of @var{X} in degrees.
+
+@item @emph{Standard}:
+None. Enabled with @option{-fdec-math}
+
+@item @emph{Class}:
+Elemental function
+
+@item @emph{Syntax}:
+@multitable @columnfractions .80
+@item @code{RESULT = ATAND(X)}
+@end multitable
+
+@item @emph{Arguments}:
+@multitable @columnfractions .15 .70
+@item @var{X} @tab The type shall be @code{REAL}. The value must be greater
+than or equal to zero.
+@end multitable
+
+@item @emph{Return value}:
+The return value is of the same type and kind as @var{X}.
+The result is in degrees and lies in the range
+-90 @leq{} @math{\asind(x)} @leq{} 90.
+
+@item @emph{Example}:
+@smallexample
+program test_atand
+  real(8) :: x = 1.0_8
+  x = atand(x) ! => 45.0
+end program test_atand
+@end smallexample
+
+@item @emph{Specific names}:
+@multitable @columnfractions .20 .20 .20 .25
+@item Name            @tab Argument          @tab Return type       @tab Standard
+@item @code{ATAND(X)}  @tab @code{REAL(4) X}  @tab @code{REAL(4)}    @tab None.
+@item @code{DATAND(X)} @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab None.
+@end multitable
+
+@item @emph{See also}:
+Inverse function: @ref{TAND}
+Radian version: @ref{ATAN}
 
 @end table
 
@@ -1495,6 +1688,75 @@ end program test_atan2
 @item @code{ATAN2(X, Y)}  @tab @code{REAL(4) X, Y} @tab @code{REAL(4)} @tab Fortran 77 and later
 @item @code{DATAN2(X, Y)} @tab @code{REAL(8) X, Y} @tab @code{REAL(8)} @tab Fortran 77 and later
 @end multitable
+
+@item @emph{See also}:
+Degree version: @ref{ATAN2D}
+
+@end table
+
+
+
+@node ATAN2D
+@section @code{ATAN2D} --- Arctangent function in degrees
+@fnindex ATAN2D
+@fnindex DATAN2D
+@cindex trigonometric function, tangent, inverse, degrees
+@cindex tangent, inverse, degrees
+
+@table @asis
+@item @emph{Description}:
+@code{ATAN2D(Y, X)} computes the principal value of the argument
+function of the complex number @math{X + i Y} in degrees. This function can
+be used to transform from Cartesian into polar coordinates and
+allows to determine the angle in the correct quadrant.
+
+@item @emph{Standard}:
+None. Enabled with @option{-fdec-math}
+
+@item @emph{Class}:
+Elemental function
+
+@item @emph{Syntax}:
+@code{RESULT = ATAN2D(Y, X)}
+
+@item @emph{Arguments}:
+@multitable @columnfractions .15 .70
+@item @var{Y} @tab The type shall be @code{REAL}.
+@item @var{X} @tab The type and kind type parameter shall be the same as @var{Y}.
+If @var{Y} is zero, then @var{X} must be nonzero.
+@end multitable
+
+@item @emph{Return value}:
+The return value has the same type and kind type parameter as @var{Y} and is
+expressed in degrees. It
+is the principal value of the complex number @math{X + i Y}.  If @var{X}
+is nonzero, then it lies in the range
+@math{-180.0} @leq{} @math{\atan (x)} @leq{} @math{180.0}.
+The sign is positive if @var{Y} is positive.  If @var{Y} is zero, then
+the return value is zero if @var{X} is strictly positive, @math{180.0} if
+@var{X} is negative and @var{Y} is positive zero (or the processor does
+not handle signed zeros), and @math{-180.0} if @var{X} is negative and
+@var{Y} is negative zero.  Finally, if @var{X} is zero, then the
+magnitude of the result is @math{90.0}.
+
+@item @emph{Example}:
+@smallexample
+program test_atan2d
+  real(4) :: x = 1.e0_4, y = 2.679676_4
+  x = atan2d(y,x) ! => 69.53546
+end program test_atan2d
+@end smallexample
+
+@item @emph{Specific names}:
+@multitable @columnfractions .20 .20 .20 .25
+@item Name                @tab Argument            @tab Return type    @tab Standard
+@item @code{ATAN2D(X, Y)}  @tab @code{REAL(4) X, Y} @tab @code{REAL(4)} @tab None
+@item @code{DATAN2D(X, Y)} @tab @code{REAL(8) X, Y} @tab @code{REAL(8)} @tab None
+@end multitable
+
+@item @emph{See also}:
+Radian version: @ref{ATAN2}
+
 @end table
 
 
@@ -2183,6 +2445,10 @@ The return value is of type @code{LOGICAL} and of the default kind.
 @node BTEST
 @section @code{BTEST} --- Bit test function
 @fnindex BTEST
+@fnindex BBTEST
+@fnindex BITEST
+@fnindex BJTEST
+@fnindex BKTEST
 @cindex bits, testing
 
 @table @asis
@@ -2220,6 +2486,21 @@ program test_btest
     end do
 end program test_btest
 @end smallexample
+
+@item @emph{Specific names}:
+@multitable @columnfractions .20 .20 .20 .25
+@item Name            @tab Argument            @tab Return type       @tab Standard
+@item @code{BTEST} @tab @code{INTEGER I} @tab @code{INTEGER(4)}
+  @tab Fortran 77 and later
+@item @code{BBTEST} @tab @code{INTEGER(1) I} @tab @code{INTEGER(1)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{BITEST} @tab @code{INTEGER(2) I} @tab @code{INTEGER(2)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{BJTEST} @tab @code{INTEGER(4) I} @tab @code{INTEGER(4)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{BKTEST} @tab @code{INTEGER(8) I} @tab @code{INTEGER(8)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@end multitable
 @end table
 
 
@@ -3096,6 +3377,61 @@ end program test_cos
 
 @item @emph{See also}:
 Inverse function: @ref{ACOS}
+Degree version: @ref{COSD}
+
+@end table
+
+
+
+@node COSD
+@section @code{COSD} --- Cosine function, degree-valued parameter
+@fnindex COSD
+@fnindex DCOSD
+@cindex trigonometric function, cosine, degrees
+@cindex cosine, degrees
+
+@table @asis
+@item @emph{Description}:
+@code{COSD(X)} computes the cosine of @var{X}, which is in degrees.
+
+@item @emph{Standard}:
+None. Enabled with @option{-fdec-math}
+
+@item @emph{Class}:
+Elemental function
+
+@item @emph{Syntax}:
+@code{RESULT = COSD(X)}
+
+@item @emph{Arguments}:
+@multitable @columnfractions .15 .70
+@item @var{X} @tab The type shall be @code{REAL}. The value is in degrees and
+is treated as modulo 360.
+@end multitable
+
+@item @emph{Return value}:
+The return value is of the same type and kind as @var{X}. The result is in
+radians. The return value lies in the range
+@math{-1} @leq{} @math{\cos (x)} @leq{} @math{1}.
+
+@item @emph{Example}:
+@smallexample
+program test_cosd
+  real :: x = 45.0
+  x = cos(x) ! => 0.707
+end program test_cosd
+@end smallexample
+
+@item @emph{Specific names}:
+@multitable @columnfractions .20 .20 .20 .25
+@item Name            @tab Argument            @tab Return type       @tab Standard
+@item @code{COSD(X)}   @tab @code{REAL(4) X}    @tab @code{REAL(4)}    @tab None
+@item @code{DCOSD(X)}  @tab @code{REAL(8) X}    @tab @code{REAL(8)}    @tab None
+@end multitable
+
+@item @emph{See also}:
+Inverse function: @ref{ACOSD}
+Radian version: @ref{COS}
 
 @end table
 
@@ -3155,6 +3491,109 @@ Inverse function: @ref{ACOSH}
 
 
 
+@node COTAN
+@section @code{COTAN} --- Tangent function
+@fnindex COTAN
+@fnindex DCOTAN
+@cindex trigonometric function, cotangent
+@cindex cotangent
+
+@table @asis
+@item @emph{Description}:
+@code{COTAN(X)} computes the multiplicative inverse of the tangent of @var{X}.
+
+@item @emph{Standard}:
+None. Enabled with @option{-fdec-math}
+
+@item @emph{Class}:
+Elemental function
+
+@item @emph{Syntax}:
+@code{RESULT = COTAN(X)}
+
+@item @emph{Arguments}:
+@multitable @columnfractions .15 .70
+@item @var{X} @tab The type shall be @code{REAL}. The value must be non-zero,
+is in radians and is treated as modulo @math{2*\pi}.
+@end multitable
+
+@item @emph{Return value}:
+The return value has same type and kind as @var{X}.
+
+@item @emph{Example}:
+@smallexample
+program test_cotan
+  real(8) :: x = 0.6_8
+  x = cotan(x) ! => 1.461696
+end program test_cotan
+@end smallexample
+
+@item @emph{Specific names}:
+@multitable @columnfractions .20 .20 .20 .25
+@item Name            @tab Argument          @tab Return type     @tab Standard
+@item @code{COTAN(X)}   @tab @code{REAL(4) X}  @tab @code{REAL(4)}  @tab None
+@item @code{DCOTAN(X)}  @tab @code{REAL(8) X}  @tab @code{REAL(8)}  @tab None
+@end multitable
+
+@item @emph{See also}:
+Multiplicative inverse: @ref{TAN}
+Degree version: @ref{COTAND}
+@end table
+
+
+
+@node COTAND
+@section @code{COTAND} --- Tangent function
+@fnindex COTAND
+@fnindex DCOTAND
+@cindex trigonometric function, cotangent, degrees
+@cindex cotangent, degrees
+
+@table @asis
+@item @emph{Description}:
+@code{COTAND(X)} computes the multiplicative inverse of the tangent of @var{X},
+which is in degrees.
+
+@item @emph{Standard}:
+None. Enabled with @option{-fdec-math}
+
+@item @emph{Class}:
+Elemental function
+
+@item @emph{Syntax}:
+@code{RESULT = COTAND(X)}
+
+@item @emph{Arguments}:
+@multitable @columnfractions .15 .70
+@item @var{X} @tab The type shall be @code{REAL}. The value must be non-zero,
+is in degrees and is treated as modulo @math{360}.
+@end multitable
+
+@item @emph{Return value}:
+The return value has same type and kind as @var{X}.
+
+@item @emph{Example}:
+@smallexample
+program test_cotand
+  real(8) :: x = 0.6_8
+  x = cotan(x) ! => 95.4895
+end program test_cotand
+@end smallexample
+
+@item @emph{Specific names}:
+@multitable @columnfractions .20 .20 .20 .25
+@item Name            @tab Argument          @tab Return type     @tab Standard
+@item @code{COTAND(X)}   @tab @code{REAL(4) X}  @tab @code{REAL(4)}  @tab None
+@item @code{DCOTAND(X)}  @tab @code{REAL(8) X}  @tab @code{REAL(8)}  @tab None
+@end multitable
+
+@item @emph{See also}:
+Multiplicative inverse: @ref{TAND}
+Radian version: @ref{COTAN}
+@end table
+
+
+
 @node COUNT
 @section @code{COUNT} --- Count function
 @fnindex COUNT
@@ -6181,6 +6620,21 @@ PROGRAM test_iand
 END PROGRAM
 @end smallexample
 
+@item @emph{Specific names}:
+@multitable @columnfractions .20 .20 .20 .25
+@item Name            @tab Argument            @tab Return type       @tab Standard
+@item @code{IAND(I,J)} @tab @code{INTEGER I,J} @tab @code{INTEGER}
+  @tab Fortran 77 and later
+@item @code{BIAND(I,J)} @tab @code{INTEGER(1) I,J} @tab @code{INTEGER(1)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{IIAND(I,J)} @tab @code{INTEGER(2) I,J} @tab @code{INTEGER(2)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{JIAND(I,J)} @tab @code{INTEGER(4) I,J} @tab @code{INTEGER(4)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{KIAND(I,J)} @tab @code{INTEGER(8) I,J} @tab @code{INTEGER(8)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@end multitable
+
 @item @emph{See also}:
 @ref{IOR}, @ref{IEOR}, @ref{IBITS}, @ref{IBSET}, @ref{IBCLR}, @ref{NOT}
 
@@ -6322,6 +6776,21 @@ Elemental function
 The return value is of type @code{INTEGER} and of the same kind as
 @var{I}.
 
+@item @emph{Specific names}:
+@multitable @columnfractions .20 .20 .20 .25
+@item Name            @tab Argument            @tab Return type       @tab Standard
+@item @code{IBCLR} @tab @code{INTEGER I} @tab @code{INTEGER}
+  @tab Fortran 77 and later
+@item @code{BBCLR} @tab @code{INTEGER(1) I} @tab @code{INTEGER(1)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{IIBCLR} @tab @code{INTEGER(2) I} @tab @code{INTEGER}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{JIBCLR} @tab @code{INTEGER(4) I} @tab @code{INTEGER}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{KIBCLR} @tab @code{INTEGER(8) I} @tab @code{INTEGER}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@end multitable
+
 @item @emph{See also}:
 @ref{IBITS}, @ref{IBSET}, @ref{IAND}, @ref{IOR}, @ref{IEOR}, @ref{MVBITS}
 
@@ -6363,6 +6832,21 @@ Elemental function
 The return value is of type @code{INTEGER} and of the same kind as
 @var{I}.
 
+@item @emph{Specific names}:
+@multitable @columnfractions .20 .20 .20 .25
+@item Name            @tab Argument            @tab Return type       @tab Standard
+@item @code{IBITS} @tab @code{INTEGER I} @tab @code{INTEGER}
+  @tab Fortran 77 and later
+@item @code{BBITS} @tab @code{INTEGER(1) I} 
+  @tab @code{INTEGER(1)} @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{IIBITS} @tab @code{INTEGER(2) I}
+  @tab @code{INTEGER(2)} @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{JIBITS} @tab @code{INTEGER(4) I} 
+  @tab @code{INTEGER(4)} @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{KIBITS} @tab @code{INTEGER(8) I} 
+  @tab @code{INTEGER(8)} @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@end multitable
+
 @item @emph{See also}:
 @ref{BIT_SIZE}, @ref{IBCLR}, @ref{IBSET}, @ref{IAND}, @ref{IOR}, @ref{IEOR}
 @end table
@@ -6398,6 +6882,21 @@ Elemental function
 The return value is of type @code{INTEGER} and of the same kind as
 @var{I}.
 
+@item @emph{Specific names}:
+@multitable @columnfractions .20 .20 .20 .25
+@item Name            @tab Argument            @tab Return type       @tab Standard
+@item @code{IBSET} @tab @code{INTEGER I} @tab @code{INTEGER}
+  @tab Fortran 77 and later
+@item @code{BBSET} @tab @code{INTEGER(1) I} @tab @code{INTEGER(1)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{IIBSET} @tab @code{INTEGER(2) I} @tab @code{INTEGER(2)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{JIBSET} @tab @code{INTEGER(4) I} @tab @code{INTEGER(4)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{KIBSET} @tab @code{INTEGER(8) I} @tab @code{INTEGER(8)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@end multitable
+
 @item @emph{See also}:
 @ref{IBCLR}, @ref{IBITS}, @ref{IAND}, @ref{IOR}, @ref{IEOR}, @ref{MVBITS}
 
@@ -6559,6 +7058,21 @@ The return type is @code{INTEGER}, of the same kind as the
 arguments.  (If the argument kinds differ, it is of the same kind as
 the larger argument.)
 
+@item @emph{Specific names}:
+@multitable @columnfractions .20 .20 .20 .25
+@item Name            @tab Argument            @tab Return type       @tab Standard
+@item @code{IEOR(I,J)} @tab @code{INTEGER I,J} @tab @code{INTEGER}
+  @tab Fortran 77 and later
+@item @code{BIEOR(I,J)} @tab @code{INTEGER(1) I,J} @tab @code{INTEGER(1)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{IIEOR(I,J)} @tab @code{INTEGER(2) I,J} @tab @code{INTEGER(2)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{JIEOR(I,J)} @tab @code{INTEGER(4) I,J} @tab @code{INTEGER(4)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{KIEOR(I,J)} @tab @code{INTEGER(8) I,J} @tab @code{INTEGER(8)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@end multitable
+
 @item @emph{See also}:
 @ref{IOR}, @ref{IAND}, @ref{IBITS}, @ref{IBSET}, @ref{IBCLR}, @ref{NOT}
 @end table
@@ -6862,6 +7376,21 @@ The return type is @code{INTEGER}, of the same kind as the
 arguments.  (If the argument kinds differ, it is of the same kind as
 the larger argument.)
 
+@item @emph{Specific names}:
+@multitable @columnfractions .20 .20 .20 .25
+@item Name            @tab Argument            @tab Return type       @tab Standard
+@item @code{IOR(I,J)} @tab @code{INTEGER I,J} @tab @code{INTEGER}
+  @tab Fortran 77 and later
+@item @code{BIOR(I,J)} @tab @code{INTEGER(1) I,J} @tab @code{INTEGER(1)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{IIOR(I,J)} @tab @code{INTEGER(2) I,J} @tab @code{INTEGER(2)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{JIOR(I,J)} @tab @code{INTEGER(4) I,J} @tab @code{INTEGER(4)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{KIOR(I,J)} @tab @code{INTEGER(8) I,J} @tab @code{INTEGER(8)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@end multitable
+
 @item @emph{See also}:
 @ref{IEOR}, @ref{IAND}, @ref{IBITS}, @ref{IBSET}, @ref{IBCLR}, @ref{NOT}
 @end table
@@ -7146,6 +7675,21 @@ Elemental function
 The return value is of type @code{INTEGER} and of the same kind as
 @var{I}.
 
+@item @emph{Specific names}:
+@multitable @columnfractions .20 .20 .20 .25
+@item Name            @tab Argument            @tab Return type       @tab Standard
+@item @code{ISHFT} @tab @code{INTEGER I} @tab @code{INTEGER}
+  @tab Fortran 77 and later
+@item @code{BSHFT} @tab @code{INTEGER(1) I} 
+  @tab @code{INTEGER(1)} @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{IISHFT} @tab @code{INTEGER(2) I} 
+  @tab @code{INTEGER(2)} @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{JISHFT} @tab @code{INTEGER(4) I} 
+  @tab @code{INTEGER(4)} @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{KISHFT} @tab @code{INTEGER(8) I}
+  @tab @code{INTEGER(8)} @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@end multitable
+
 @item @emph{See also}:
 @ref{ISHFTC}
 @end table
@@ -7190,6 +7734,21 @@ the value must be greater than zero and less than or equal to
 The return value is of type @code{INTEGER} and of the same kind as
 @var{I}.
 
+@item @emph{Specific names}:
+@multitable @columnfractions .20 .20 .20 .25
+@item Name            @tab Argument            @tab Return type       @tab Standard
+@item @code{ISHFTC(I)} @tab @code{INTEGER I} @tab @code{INTEGER}
+  @tab Fortran 77 and later
+@item @code{BSHFTC} @tab @code{INTEGER(1) I} @tab @code{INTEGER(1)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{IISHFTC} @tab @code{INTEGER(2) I} @tab @code{INTEGER(2)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{JISHFTC} @tab @code{INTEGER(4) I} @tab @code{INTEGER(4)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{KISHFTC} @tab @code{INTEGER(8) I} @tab @code{INTEGER(8)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@end multitable
+
 @item @emph{See also}:
 @ref{ISHFT}
 @end table
@@ -9068,6 +9627,14 @@ end program test_mod
 @item @code{MOD(A,P)}  @tab @code{INTEGER A,P} @tab @code{INTEGER} @tab Fortran 95 and later
 @item @code{AMOD(A,P)} @tab @code{REAL(4) A,P} @tab @code{REAL(4)} @tab Fortran 95 and later
 @item @code{DMOD(A,P)} @tab @code{REAL(8) A,P} @tab @code{REAL(8)} @tab Fortran 95 and later
+@item @code{BMOD(A,P)} @tab @code{INTEGER(1) A,P} @tab @code{INTEGER(1)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{IMOD(A,P)} @tab @code{INTEGER(2) A,P} @tab @code{INTEGER(2)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{JMOD(A,P)} @tab @code{INTEGER(4) A,P} @tab @code{INTEGER(4)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{KMOD(A,P)} @tab @code{INTEGER(8) A,P} @tab @code{INTEGER(8)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
 @end multitable
 
 @item @emph{See also}:
@@ -9446,6 +10013,21 @@ Elemental function
 The return type is @code{INTEGER}, of the same kind as the
 argument.
 
+@item @emph{Specific names}:
+@multitable @columnfractions .20 .20 .20 .25
+@item Name            @tab Argument            @tab Return type       @tab Standard
+@item @code{NOT(I)} @tab @code{INTEGER I} @tab @code{INTEGER}
+  @tab Fortran 77 and later
+@item @code{BNOT(I)} @tab @code{INTEGER(1) I} @tab @code{INTEGER(1)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{INOT(I)} @tab @code{INTEGER(2) I} @tab @code{INTEGER(2)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{JNOT(I)} @tab @code{INTEGER(4) I} @tab @code{INTEGER(4)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{KNOT(I)} @tab @code{INTEGER(8) I} @tab @code{INTEGER(8)}
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@end multitable
+
 @item @emph{See also}:
 @ref{IAND}, @ref{IEOR}, @ref{IOR}, @ref{IBITS}, @ref{IBSET}, @ref{IBCLR}
 
@@ -10409,6 +10991,12 @@ end program test_real
 @item @code{FLOAT(A)}  @tab @code{INTEGER(4)}  @tab @code{REAL(4)}  @tab Fortran 77 and later
 @item @code{DFLOAT(A)} @tab @code{INTEGER(4)}  @tab @code{REAL(8)}  @tab GNU extension
 @item @code{SNGL(A)}   @tab @code{INTEGER(8)}  @tab @code{REAL(4)}  @tab Fortran 77 and later
+@item @code{FLOATI(A)}   @tab @code{INTEGER(2)}  @tab @code{REAL(4)} 
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{FLOATJ(A)}   @tab @code{INTEGER(4)}  @tab @code{REAL(4)} 
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
+@item @code{FLOATK(A)}   @tab @code{INTEGER(8)}  @tab @code{REAL(4)} 
+  @tab GNU extension (enabled with -fdec-intrinsic-ints)
 @end multitable
 
 
@@ -11412,7 +12000,64 @@ end program test_sin
 @end multitable
 
 @item @emph{See also}:
-@ref{ASIN}
+Inverse function: @ref{ASIN}
+Degree version: @ref{SIND}
+@end table
+
+
+
+@node SIND
+@section @code{SIND} --- Sine function, degree-valued parameter
+@fnindex SIND
+@fnindex DSIND
+@fnindex CSIND
+@fnindex ZSIND
+@fnindex CDSIND
+@cindex trigonometric function, sine, degrees
+@cindex sine, degrees
+
+@table @asis
+@item @emph{Description}:
+@code{SIND(X)} computes the sine of @var{X}, which is in degrees.
+
+@item @emph{Standard}:
+None. Enabled with @option{-fdec-math}
+
+@item @emph{Class}:
+Elemental function
+
+@item @emph{Syntax}:
+@code{RESULT = SIND(X)}
+
+@item @emph{Arguments}:
+@multitable @columnfractions .15 .70
+@item @var{X} @tab The type shall be @code{REAL}. The value is in degrees and
+is treated as modulo 360.
+@end multitable
+
+@item @emph{Return value}:
+The return value is of the same type and kind as @var{X}. The result is in
+radians. The return value lies in the range
+@math{-1} @leq{} @math{\cos (x)} @leq{} @math{1}.
+
+@item @emph{Example}:
+@smallexample
+program test_sind
+  real :: x = 45.0
+  x = sind(x) ! => 0.707
+end program test_sind
+@end smallexample
+
+@item @emph{Specific names}:
+@multitable @columnfractions .20 .20 .20 .25
+@item Name             @tab Argument          @tab Return type    @tab Standard
+@item @code{SIND(X)}   @tab @code{REAL(4) X}  @tab @code{REAL(4)} @tab None
+@item @code{DSIND(X)}  @tab @code{REAL(8) X}  @tab @code{REAL(8)} @tab None
+@end multitable
+
+@item @emph{See also}:
+Inverse function: @ref{ASIND}
+Radian version: @ref{SIN}
 @end table
 
 
@@ -12175,7 +12820,59 @@ end program test_tan
 @end multitable
 
 @item @emph{See also}:
-@ref{ATAN}
+Inverse function: @ref{ATAN}
+Degree version: @ref{TAND}
+@end table
+
+
+
+@node TAND
+@section @code{TAND} --- Tangent functio, degree-valued parameter
+@fnindex TAND
+@fnindex DTAND
+@cindex trigonometric function, tangent, degrees
+@cindex tangent, degrees
+
+@table @asis
+@item @emph{Description}:
+@code{TAND(X)} computes the tangent of @var{X}, which is in degrees.
+
+@item @emph{Standard}:
+None. Enabled with @option{-fdec-math}
+
+@item @emph{Class}:
+Elemental function
+
+@item @emph{Syntax}:
+@code{RESULT = TAND(X)}
+
+@item @emph{Arguments}:
+@multitable @columnfractions .15 .70
+@item @var{X} @tab The type shall be @code{REAL}. The value is in degrees and
+is treated as modulo 360.
+@end multitable
+
+@item @emph{Return value}:
+The return value has same type and kind as @var{X}.
+
+@item @emph{Example}:
+@smallexample
+program test_tand
+  real(8) :: x = 45.0_8
+  x = tand(x) ! => 1.0
+end program test_tand
+@end smallexample
+
+@item @emph{Specific names}:
+@multitable @columnfractions .20 .20 .20 .25
+@item Name            @tab Argument          @tab Return type     @tab Standard
+@item @code{TAND(X)}   @tab @code{REAL(4) X}  @tab @code{REAL(4)}  @tab None
+@item @code{DTAND(X)}  @tab @code{REAL(8) X}  @tab @code{REAL(8)}  @tab None
+@end multitable
+
+@item @emph{See also}:
+Inverse function: @ref{ATAND}
+Radian version: @ref{TAN}
 @end table
 
 
diff --git a/gcc/fortran/invoke.texi b/gcc/fortran/invoke.texi
index b0b43d8478b..3d29466111b 100644
--- a/gcc/fortran/invoke.texi
+++ b/gcc/fortran/invoke.texi
@@ -115,13 +115,17 @@ by type.  Explanations are in the following sections.
 @item Fortran Language Options
 @xref{Fortran Dialect Options,,Options controlling Fortran dialect}.
 @gccoptlist{-fall-intrinsics -fbackslash -fcray-pointer -fd-lines-as-code @gol
--fd-lines-as-comments -fdefault-double-8 -fdefault-integer-8 @gol
--fdefault-real-8 -fdollar-ok -ffixed-line-length-@var{n} @gol
--ffixed-line-length-none -ffree-form -ffree-line-length-@var{n} @gol
--ffree-line-length-none -fimplicit-none -finteger-4-integer-8 @gol
--fmax-identifier-length -fmodule-private -fno-fixed-form -fno-range-check @gol
--fopenmp -freal-4-real-10 -freal-4-real-16 -freal-4-real-8 @gol
--freal-8-real-10 -freal-8-real-16 -freal-8-real-4 -std=@var{std}
+-fd-lines-as-comments @gol
+-fdec -fdec-extended-int -fdec-member-dot -fdec-structure -fdec-math @gol
+-fdec-logical-xor -fdec-bitwise-ops -fdec-io fdec-intrinsic-ints -ffeed @gol
+-fdec-static -ftype-print @gol
+-fdefault-double-8 -fdefault-integer-8 -fdefault-real-8 -fdollar-ok @gol
+-ffixed-line-length-@var{n} -ffixed-line-length-none -ffree-form @gol
+-ffree-line-length-@var{n} -ffree-line-length-none -fimplicit-none @gol
+-finteger-4-integer-8 -floc-rval -fmax-identifier-length -fmodule-private @gol
+-fno-fixed-form -fno-range-check -fopenmp -freal-4-real-10 @gol
+-freal-4-real-16 -freal-4-real-8 -freal-8-real-10 -freal-8-real-16 @gol
+-freal-8-real-4 -std=@var{std}
 }
 
 @item Preprocessing Options
@@ -145,7 +149,8 @@ and warnings}.
 -Wimplicit-procedure -Wintrinsic-shadow -Wintrinsics-std @gol
 -Wline-truncation -Wno-align-commons -Wno-tabs -Wreal-q-constant @gol
 -Wsurprising -Wunderflow -Wunused-parameter -Wrealloc-lhs Wrealloc-lhs-all @gol
--Wtarget-lifetime -fmax-errors=@var{n} -fsyntax-only -pedantic -pedantic-errors
+-Wtarget-lifetime -Wargument-mismatch -Wformat-tab @gol
+-flazy-logicals -fmax-errors=@var{n} -fsyntax-only -pedantic -pedantic-errors
 }
 
 @item Debugging Options
@@ -178,6 +183,7 @@ and warnings}.
 -finit-character=@var{n} -finit-integer=@var{n} -finit-local-zero @gol
 -finit-logical=@var{<true|false>}
 -finit-real=@var{<zero|inf|-inf|nan|snan>} @gol
+-finit-derived @gol
 -fmax-array-constructor=@var{n} -fmax-stack-var-size=@var{n}
 -fno-align-commons @gol
 -fno-automatic -fno-protect-parens -fno-underscoring -fno-whole-file @gol
@@ -227,6 +233,79 @@ given they are treated as if the first column contained a blank.  If the
 @option{-fd-lines-as-comments} option is given, they are treated as
 comment lines.
 
+@item -fdec
+@opindex @code{fdec}
+Enable all supported Digital Equipment Corporation (DEC) extensions.
+These extensions are non-standard and should be avoided when possible.
+For details on GNU Fortran's implementation of these extensions see the 
+full documentation.
+
+The options enabled by this switch are: @option{-fdollar-ok} 
+@option{-fdec-structure} @option{-fdec-member-dot} @option{-fdec-extended-int}
+@option{-fdec-math} @option{-fdec-logical-xor} @option{-fdec-bitwise-ops}
+@option{-fd-lines-as-comments} @option{-fdec-io} @option{-ffeed}
+@option{-fdec-intrinsic-ints} @option{-fdec-static} @option{-flazy-logicals}
+@option{-ftype-print} @option{-Wno-format-tab}
+@option{-Wno-missing-include-dirs}
+
+@item -fdec-intrinsic-ints
+@opindex @code{fdec-intrinsic-ints}
+Enable B/I/J/K kind variants for integer intrinsics. For a list of supported
+intrinsics see the full documentation.
+
+@item -fdec-bitwise-ops
+@opindex @code{fdec-bitwise-ops}
+When at least one operand of a logical operator is an integer, convert both
+operands to an integer and instead use the corresponding bitwise operator.
+For example, 5 @code{.AND.} 4 is converted to @code{IAND}(5, 4) and returns 4.
+
+@item -fdec-extended-int
+@opindex @code{fdec-extended-int}
+Enable the DEC extended integer constant format. This format allows integer
+constants with bases between 2 and 36 to be specified in the "base#value"
+format.
+
+@item -fdec-io
+@opindex @code{fdec-io}
+Enable DEC extended IO syntax. This includes the @code{READONLY},
+@code{SHARED}, and @code{CARRAIGECONTROL} specifiers in @code{OPEN} statements.
+
+@item -fdec-member-dot
+@opindex @code{fdec-member-dot}
+Enable dot (@code{.}) as a member separator (in addition to the usual @code{%}).
+This is enabled automatically with @option{-fdec-structure}.
+
+@item -fdec-static
+@opindex @code{fdec-static}
+Enable @code{STATIC} and @code{AUTOMATIC} as attributes specifying storage
+location. For GNU Fortran, @code{STATIC} is the same as @code{SAVE} and local
+variables are @code{AUTOMATIC} by default, unless @option{-fno-automatic} is
+used.
+
+@item -fdec-structure
+@opindex @code{fdec-structure}
+Enable DEC old-style @code{STRUCTURE} and @code{RECORD}. This is provided for
+compatibility; Fortran 90 derived types should be used instead where
+possible. This implies @option{-fdec-member-dot}.
+
+@item -fdec-logical-xor
+@opindex @code{fdec-logical-xor}
+Enable the logical @code{.XOR.} function (same as @code{.NEQV.}).
+
+@item -fdec-math
+@opindex @code{fdec-math}
+Enable extra math intrinsics, such as degree-valued trig functions.
+For a list of supported intrinsics see the full documentation.
+
+@item -ffeed
+@opindex @code{ffeed}
+Treat form feed (@code{\f}) characters as whitespace in the source.
+
+@item -ftype-print
+@opindex @code{ftype-print}
+Interpret TYPE as an alias for PRINT whenever it can be disambiguated from
+derived type data and type declarations and TYPE IS statements.
+
 @item -fdefault-double-8
 @opindex @code{fdefault-double-8}
 Set the @code{DOUBLE PRECISION} type to an 8 byte wide type.  If
@@ -309,6 +388,11 @@ lines in the source file. The default value is 132.
 @option{-ffree-line-length-0} means the same thing as
 @option{-ffree-line-length-none}.
 
+@item -floc-rval
+@opindex @code{floc-rval}
+Enable the recognition of the %LOC() function as an rvalue. That is, it can
+be used just like the intrinsic LOC() function.
+
 @item -fmax-identifier-length=@var{n}
 @opindex @code{fmax-identifier-length=}@var{n}
 Specify the maximum allowed identifier length. Typical values are
@@ -677,6 +761,14 @@ These options control the amount and kinds of errors and warnings produced
 by GNU Fortran:
 
 @table @gcctabopt
+@item -flazy-logicals
+@opindex @code{flazy-logicals}
+Disables errors and warnings when using integers as conditional expressions in
+if statements and as operands to logical operators. Implies -fdec-bitwise-ops.
+With this option, integer conditional expressions are considered true if the 
+least significant bit of the integer is non-zero, as with older compilers.
+This flag is for compatibility only and should be generally avoided.
+
 @item -fmax-errors=@var{n}
 @opindex @code{fmax-errors=}@var{n}
 @cindex errors, limiting
@@ -954,6 +1046,17 @@ This option is implied by @option{-Wextra}.
 Warn if the pointer in a pointer assignment might be longer than the its
 target. This option is implied by @option{-Wall}.
 
+@item -Wargument-mismatch
+@opindex @code{Wargument-mismatch}
+Warn when the type or rank of formal and actual arguments do not match.
+Enabled by default.
+
+@item -Wformat-tab
+@opindex @code{Wformat-tab}
+Warn when a tab appears in a format specifier. Enabled by default. Note that
+this is still a GNU extension, and tabs in a format specifier will be an error
+if the standard is specified other than @option{-std=gnu}.
+
 @item -Werror
 @opindex @code{Werror}
 @cindex warnings, to errors
@@ -1518,11 +1621,13 @@ on the stack. This flag cannot be used together with
 @option{-fmax-stack-var-size=} or @option{-fno-automatic}.
 
 @item -finit-local-zero
+@itemx -finit-derived
 @itemx -finit-integer=@var{n}
 @itemx -finit-real=@var{<zero|inf|-inf|nan|snan>}
 @itemx -finit-logical=@var{<true|false>}
 @itemx -finit-character=@var{n}
 @opindex @code{finit-local-zero}
+@opindex @code{finit-derived}
 @opindex @code{finit-integer}
 @opindex @code{finit-real}
 @opindex @code{finit-logical}
@@ -1537,7 +1642,7 @@ initialization options are provided by the
 the real and imaginary parts of local @code{COMPLEX} variables),
 @option{-finit-logical=@var{<true|false>}}, and
 @option{-finit-character=@var{n}} (where @var{n} is an ASCII character
-value) options.  These options do not initialize
+value) options.  By default these options do not initialize
 @itemize @bullet
 @item
 allocatable arrays
@@ -1546,7 +1651,8 @@ components of derived type variables
 @item
 variables that appear in an @code{EQUIVALENCE} statement.
 @end itemize
-(These limitations may be removed in future releases).
+Components of derived type variables will be initialized with the values from
+these flags only with @option{-finit-derived}.
 
 Note that the @option{-finit-real=nan} option initializes @code{REAL}
 and @code{COMPLEX} variables with a quiet NaN. For a signalling NaN
diff --git a/gcc/fortran/io.c b/gcc/fortran/io.c
index 1d464742f5b..3f873857c4d 100644
--- a/gcc/fortran/io.c
+++ b/gcc/fortran/io.c
@@ -38,6 +38,12 @@ typedef struct
 io_tag;
 
 static const io_tag
+        tag_readonly    = {"READONLY", " readonly", NULL, BT_UNKNOWN },
+        tag_shared      = {"SHARED", " shared", NULL, BT_UNKNOWN },
+        tag_noshared    = {"NOSHARED", " noshared", NULL, BT_UNKNOWN },
+        tag_cc          = {"CARRIAGECONTROL",
+                           " carriagecontrol =", " %e", BT_CHARACTER },
+        tag_e_share     = {"SHARE", " share =", " %e", BT_CHARACTER },
 	tag_file	= {"FILE", " file =", " %e", BT_CHARACTER },
 	tag_status	= {"STATUS", " status =", " %e", BT_CHARACTER},
 	tag_e_access	= {"ACCESS", " access =", " %e", BT_CHARACTER},
@@ -201,7 +207,10 @@ next_char_not_space (bool *error)
       if (c == '\t')
 	{
 	  if (gfc_option.allow_std & GFC_STD_GNU)
-	    gfc_warning ("Extension: Tab character in format at %C");
+            {
+              if (gfc_option.warn_format_tab)
+                gfc_warning ("Extension: Tab character in format at %C");
+            }
 	  else
 	    {
 	      gfc_error ("Extension: Tab character in format at %C");
@@ -1374,6 +1383,92 @@ match_ltag (const io_tag *tag, gfc_st_label ** label)
 }
 
 
+/* Match a tag using match_etag, but only if -fdec-io is enabled. 
+   Gives a nice error if the tag was matched but -fdec-io is not on. */
+static match
+match_dec_etag (const io_tag *tag, gfc_expr **e)
+{
+  match m = match_etag (tag, e);
+  if (gfc_option.flag_dec_io && m != MATCH_NO)
+    return m;
+  else if (m != MATCH_NO)
+  {
+    gfc_error ("%s is a DEC extension at %C, re-compile with"
+               "-fdec-io to enable", tag->name);
+    return MATCH_ERROR;
+  }
+
+  return m;
+}
+
+/* Match a flag tag (tag with no var/expr association, such as READONLY).
+   The open object is messed with accordingly. */
+
+static match
+match_dec_ftag (const io_tag *tag, gfc_open *o)
+{
+  match m;
+  locus *where;
+  const int ch_kind = gfc_default_character_kind;
+
+  m = gfc_match (tag->spec);
+  if (m != MATCH_YES)
+    return m;
+
+  where = &gfc_current_locus;
+
+  if (!gfc_option.flag_dec_io)
+  {
+    gfc_error ("%s is a DEC extension at %C, re-compile with"
+               "-fdec-io to enable", tag->name);
+    return MATCH_ERROR;
+  }
+
+  /* Interpret READONLY as ACTION='READ' */
+  if (tag == &tag_readonly)
+  {
+    if (o->action)
+    {
+      gfc_error ("Cannot specify READONLY and ACTION together at %C"
+                 "(ACTION specified at %L)", &o->action->where);
+      return MATCH_ERROR;
+    }
+    o->action = gfc_get_character_expr (ch_kind, where, "read", 4);
+    o->readonly |= 1;
+    return MATCH_YES;
+  }
+
+  /* Interpret SHARED as SHARE='DENYNONE' (read lock) */
+  if (tag == &tag_shared)
+  {
+    if (o->share)
+    {
+      gfc_error ("Duplicate SHARE specification at %C "
+                 "(previously specified at %L)", &o->share->where);
+      return MATCH_ERROR;
+    }
+    o->share = gfc_get_character_expr (ch_kind, where, "denynone", 8);
+    return MATCH_YES;
+  }
+
+  /* Interpret NOSHARED as SHARE='DENYRW' (exclusive lock) */
+  if (tag == &tag_noshared)
+  {
+    if (o->share)
+    {
+      gfc_error ("Duplicate SHARE specification at %C "
+                 "(previously specified at %L)", &o->share->where);
+      return MATCH_ERROR;
+    }
+    o->share = gfc_get_character_expr (ch_kind, where, "denyrw", 6);
+    return MATCH_YES;
+  }
+
+  gfc_internal_error ("match_dectag(): Unhandled tag");
+  return MATCH_ERROR;
+}
+
+
 /* Resolution of the FORMAT tag, to be called from resolve_tag.  */
 
 static gfc_try
@@ -1620,6 +1715,23 @@ match_open_element (gfc_open *open)
   if (m != MATCH_NO)
     return m;
 
+  /* The following are DEC extensions. */
+  m = match_dec_etag (&tag_e_share, &open->share);
+  if (m != MATCH_NO)
+    return m;
+  m = match_dec_etag (&tag_cc, &open->cc);
+  if (m != MATCH_NO)
+    return m;
+  m = match_dec_ftag (&tag_readonly, open);
+  if (m != MATCH_NO)
+    return m;
+  m = match_dec_ftag (&tag_shared, open);
+  if (m != MATCH_NO)
+    return m;
+  m = match_dec_ftag (&tag_noshared, open);
+  if (m != MATCH_NO)
+    return m;
+
   return MATCH_NO;
 }
 
@@ -1652,6 +1764,8 @@ gfc_free_open (gfc_open *open)
   gfc_free_expr (open->convert);
   gfc_free_expr (open->asynchronous);
   gfc_free_expr (open->newunit);
+  gfc_free_expr (open->share);
+  gfc_free_expr (open->cc);
   free (open);
 }
 
@@ -1682,6 +1796,8 @@ gfc_resolve_open (gfc_open *open)
   RESOLVE_TAG (&tag_e_sign, open->sign);
   RESOLVE_TAG (&tag_convert, open->convert);
   RESOLVE_TAG (&tag_newunit, open->newunit);
+  RESOLVE_TAG (&tag_e_share, open->share);
+  RESOLVE_TAG (&tag_cc, open->cc);
 
   if (gfc_reference_st_label (open->err, ST_LABEL_TARGET) == FAILURE)
     return FAILURE;
@@ -1928,6 +2044,17 @@ gfc_match_open (void)
 	}
     }
 
+  /* Checks on the CARRIAGECONTROL specifier. */
+  if (open->cc)
+    {
+      static const char *cc[] = { "LIST", "FORTRAN", "NONE", NULL };
+
+      if (!compare_to_allowed_values ("CARRIAGECONTROL", cc, NULL, NULL,
+                                      open->cc->value.character.string,
+                                      "OPEN", warn))
+        goto cleanup;
+    }
+
   /* Checks on the DECIMAL specifier.  */
   if (open->decimal)
     {
@@ -2069,6 +2196,17 @@ gfc_match_open (void)
       warn_or_error ("RECL in OPEN statement at %C must be positive");
     }
 
+  /* Checks on the SHARE specifier. */
+  if (open->share && open->share->expr_type == EXPR_CONSTANT)
+    {
+      static const char *share[] = { "DENYNONE", "DENYRW", NULL };
+
+      if (!compare_to_allowed_values ("SHARE", share, NULL, NULL,
+                                      open->share->value.character.string,
+                                      "OPEN", warn))
+        goto cleanup;
+    }
+
   /* Checks on the STATUS specifier.  */
   if (open->status && open->status->expr_type == EXPR_CONSTANT)
     {
@@ -2258,6 +2396,8 @@ gfc_match_close (void)
   /* Checks on the STATUS specifier.  */
   if (close->status && close->status->expr_type == EXPR_CONSTANT)
     {
+      /* TODO: Protect READONLY from DELETE
+         Implement some of SAVE, PRINT, SUBMIT, PRINT/DELETE, SUBMIT/DELETE */
       static const char *status[] = { "KEEP", "DELETE", NULL };
 
       if (!compare_to_allowed_values ("STATUS", status, NULL, NULL,
diff --git a/gcc/fortran/ioparm.def b/gcc/fortran/ioparm.def
index 2499c90c9a8..42f5649240e 100644
--- a/gcc/fortran/ioparm.def
+++ b/gcc/fortran/ioparm.def
@@ -50,6 +50,9 @@ IOPARM (open,    round,		1 << 20, char2)
 IOPARM (open,    sign,		1 << 21, char1)
 IOPARM (open,    asynchronous,	1 << 22, char2)
 IOPARM (open,    newunit,	1 << 23, pint4)
+IOPARM (open,    readonly,      1 << 24, int4)
+IOPARM (open,    share,         1 << 25, char1)
+IOPARM (open,    cc,            1 << 26, char2)
 IOPARM (close,   common,	0,	 common)
 IOPARM (close,   status,	1 << 7,  char1)
 IOPARM (filepos, common,	0,	 common)
diff --git a/gcc/fortran/iresolve.c b/gcc/fortran/iresolve.c
index 5b2f8c7b44e..15b3c496bee 100644
--- a/gcc/fortran/iresolve.c
+++ b/gcc/fortran/iresolve.c
@@ -652,6 +652,87 @@ gfc_resolve_cosh (gfc_expr *f, gfc_expr *x)
 }
 
 
+/* Our replacement of elements of a trig call with an EXPR_OP (e.g.
+   multiplying the result or operands by a factor to convert to/from degrees)
+   will cause the resolve_* function to be invoked again when resolving the
+   freshly created EXPR_OP. See gfc_resolve_trigd, gfc_resolve_atrigd,
+   gfc_resolve_cotan. We must observe this and avoid recursively creating
+   layers of nested EXPR_OP expressions.  */
+
+static bool
+is_trig_resolved (gfc_expr *f)
+{
+  /* We know we've already resolved the function if we see the lib call
+     starting with '__'.  */
+  return f->value.function.name != NULL
+    && 0 == strncmp("__", f->value.function.name, 2);
+}
+
+/* Return a shallow copy of the function expression f. The original expression
+   has its pointers cleared so that it may be freed without affecting the
+   shallow copy. This is similar to gfc_copy_expr, but doesn't perform a deep
+   copy of the argument list, allowing it to be reused somewhere else,
+   setting the expression up nicely for gfc_replace_expr.  */
+
+static gfc_expr *
+copy_replace_function_shallow (gfc_expr *f)
+{
+  gfc_expr *fcopy;
+  gfc_actual_arglist *args;
+
+  /* The only thing deep-copied in gfc_copy_expr() is args.  */
+  args = f->value.function.actual;
+  f->value.function.actual = NULL;
+  fcopy = gfc_copy_expr (f);
+  fcopy->value.function.actual = args;
+
+  /* Clear the old function so the shallow copy is not affected if the old
+     expression is freed.  */
+  f->value.function.name = NULL;
+  f->value.function.isym = NULL;
+  f->value.function.actual = NULL;
+  f->value.function.esym = NULL;
+  f->shape = NULL;
+  f->ref = NULL;
+
+  return fcopy;
+}
+
+
+/* Resolve cotan(x) = 1/tan(x).  */
+
+void
+gfc_resolve_cotan (gfc_expr *f, gfc_expr *x)
+{
+  gfc_expr *result, *fcopy, *one;
+
+  if (is_trig_resolved (f))
+    return;
+
+  gfc_resolve_tan (f, x);
+  one = gfc_get_constant_expr (f->ts.type, f->ts.kind, &f->where);
+
+  switch (f->ts.type)
+    {
+      case BT_REAL:
+        mpfr_set_ui (one->value.real, 1, GFC_RND_MODE);
+        break;
+
+      case BT_COMPLEX:
+        mpc_set_ui (one->value.complex, 1, GFC_MPC_RND_MODE);
+        break;
+
+      default:
+        gcc_unreachable ();
+    }
+
+  /* Replace f [tan(x)] with 1/f [cotan(x)].  */
+  fcopy = copy_replace_function_shallow (f);
+  result = gfc_divide (one, fcopy);
+  gfc_replace_expr (f, result);
+}
+
+
 void
 gfc_resolve_count (gfc_expr *f, gfc_expr *mask, gfc_expr *dim, gfc_expr *kind)
 {
@@ -2547,7 +2628,6 @@ gfc_resolve_system (gfc_expr *f, gfc_expr *n ATTRIBUTE_UNUSED)
   f->value.function.name = gfc_get_string (PREFIX ("system"));
 }
 
-
 void
 gfc_resolve_tan (gfc_expr *f, gfc_expr *x)
 {
@@ -2566,6 +2646,130 @@ gfc_resolve_tanh (gfc_expr *f, gfc_expr *x)
 }
 
 
+/* Build an expression for converting degrees to radians. */
+
+static gfc_expr *
+get_radians (gfc_expr *deg)
+{
+  mpfr_t tmp;
+  gfc_expr *result, *factor; /* pi / 180 */
+
+  gcc_assert (deg->ts.type == BT_REAL);
+
+  factor = gfc_get_constant_expr (deg->ts.type, deg->ts.kind, &deg->where);
+
+  /* Factor = pi / 180 */
+  mpfr_init (tmp);
+  mpfr_set_d (tmp, 180.0l, GFC_RND_MODE);
+  mpfr_const_pi (factor->value.real, GFC_RND_MODE);
+  mpfr_div (factor->value.real, factor->value.real, tmp, GFC_RND_MODE);
+  mpfr_clear (tmp);
+
+  /* rad = deg * (pi / 180) */
+  result = gfc_multiply (deg, factor);
+  return result;
+}
+
+
+/* Build an expression for converting radians to degrees. */
+
+static gfc_expr *
+get_degrees (gfc_expr *rad)
+{
+  mpfr_t tmp;
+  gfc_expr *result, *factor; /* 180 / pi */
+
+  gcc_assert (rad->ts.type == BT_REAL);
+
+  factor = gfc_get_constant_expr (rad->ts.type, rad->ts.kind, &rad->where);
+
+  /* Factor = 180 / pi */
+  mpfr_init (tmp);
+  mpfr_const_pi (tmp, GFC_RND_MODE);
+  mpfr_set_d (factor->value.real, 180.0l, GFC_RND_MODE);
+  mpfr_div (factor->value.real, factor->value.real, tmp, GFC_RND_MODE);
+  mpfr_clear (tmp);
+
+  /* deg = rad * (180 / pi) */
+  result = gfc_multiply (rad, factor);
+  return result;
+}
+
+
+/* Resolve a call to a trig function.  */
+
+static void
+resolve_trig_call (gfc_expr *f, gfc_expr *x)
+{
+  switch (f->value.function.isym->id)
+    {
+      case GFC_ISYM_ACOS:
+        return gfc_resolve_acos (f, x);
+      case GFC_ISYM_ASIN:
+        return gfc_resolve_asin (f, x);
+      case GFC_ISYM_ATAN:
+        return gfc_resolve_atan (f, x);
+      case GFC_ISYM_ATAN2:
+        /* NB. arg3 is unused for atan2 */
+        return gfc_resolve_atan2 (f, x, NULL);
+      case GFC_ISYM_COS:
+        return gfc_resolve_cos (f, x);
+      case GFC_ISYM_COTAN:
+        return gfc_resolve_cotan (f, x);
+      case GFC_ISYM_SIN:
+        return gfc_resolve_sin (f, x);
+      case GFC_ISYM_TAN:
+        return gfc_resolve_tan (f, x);
+      default: break;
+    }
+
+  gcc_unreachable ();
+}
+
+/* Resolve degree trig function as trigd(x) = trig(radians(x)).  */
+
+void
+gfc_resolve_trigd (gfc_expr *f, gfc_expr *x)
+{
+  if (is_trig_resolved (f))
+    return;
+
+  x = get_radians (x);
+  f->value.function.actual->expr = x;
+
+  resolve_trig_call (f, x);
+}
+
+
+/* Resolve degree inverse trig function as atrigd(x) = degrees(atrig(x)).  */
+
+void
+gfc_resolve_atrigd (gfc_expr *f, gfc_expr *x)
+{
+  gfc_expr *result, *fcopy;
+
+  if (is_trig_resolved (f))
+    return;
+
+  resolve_trig_call (f, x);
+
+  fcopy = copy_replace_function_shallow (f);
+  result = get_degrees (fcopy);
+  gfc_replace_expr (f, result);
+}
+
+
+/* Resolve atan2d(x) = degrees(atan2(x)).  */
+
+void
+gfc_resolve_atan2d (gfc_expr *f, gfc_expr *x, gfc_expr *y ATTRIBUTE_UNUSED)
+{
+  /* Note that we lose the second arg here - that's okay because it is
+     unused in gfc_resolve_atan2 anyway.  */
+  gfc_resolve_atrigd (f, x);
+}
+
+
 void
 gfc_resolve_image_index (gfc_expr *f, gfc_expr *array ATTRIBUTE_UNUSED,
 			 gfc_expr *sub ATTRIBUTE_UNUSED)
diff --git a/gcc/fortran/lang.opt b/gcc/fortran/lang.opt
index fbe8a1b2fb9..f7f66edff41 100644
--- a/gcc/fortran/lang.opt
+++ b/gcc/fortran/lang.opt
@@ -205,6 +205,10 @@ Wampersand
 Fortran Warning
 Warn about missing ampersand in continued character constants
 
+Wargument-mismatch
+Fortran Warning
+Warn about type mismatches between formal and actual function arguments
+
 Warray-temporaries
 Fortran Warning
 Warn about creation of array temporaries
@@ -233,6 +237,10 @@ Wextra
 Fortran Warning
 Print extra (possibly unwanted) warnings
 
+Wformat-tab
+Fortran Warning
+Warn about tabs in format specifiers
+
 Wfunction-elimination
 Fortran Warning
 Warn about function call elimination
@@ -253,6 +261,10 @@ Wintrinsics-std
 Fortran Warning
 Warn on intrinsics not part of the selected standard
 
+Wmissing-include-dirs
+Fortran
+; Documented in C/C++
+
 Wreal-q-constant
 Fortran Warning
 Warn about real-literal-constants with 'q' exponent-letter
@@ -373,6 +385,46 @@ fd-lines-as-comments
 Fortran RejectNegative
 Treat lines with 'D' in column one as comments
 
+fdec
+Fortran
+Enable all DEC/Intel language extensions.
+
+fdec-intrinsic-ints
+Fortran
+Enable kind-specific variants of integer intrinsic functions.
+
+fdec-bitwise-ops
+Fortran
+Use bitwise operators when logical operators are used with int operands.
+
+fdec-extended-int
+Fortran
+Enable extended base#value integer constants
+
+fdec-io
+Fortran
+Enable DEC IO extensions
+
+fdec-logical-xor
+Fortran
+Enable the logical .XOR. operator.
+
+fdec-math
+Fortran
+Enable additional builtin math functions.
+
+fdec-member-dot
+Fortran
+Enable dot (`.`) as a member separator (in addition to the usual `%`).
+
+fdec-static
+Fortran
+Enable STATIC and AUTOMATIC attributes.
+
+fdec-structure
+Fortran
+Enable DEC STRUCTURE extension.
+
 fdefault-double-8
 Fortran
 Set the default double precision kind to an 8 byte wide type
@@ -413,6 +465,10 @@ ff2c
 Fortran
 Use f2c calling convention
 
+ffeed
+Fortran
+Enable form feeds in source
+
 ffixed-form
 Fortran RejectNegative
 Assume that the source file is fixed form
@@ -481,6 +537,18 @@ finit-real=
 Fortran RejectNegative Joined
 -finit-real=<zero|nan|inf|-inf>	Initialize local real variables
 
+finit-derived
+Fortran
+Automatically initialize local derived type variables
+
+flazy-logicals
+Fortran
+Suppress type-checking between integers and logicals
+
+floc-rval
+Fortran
+Enable the use of %LOC as an rvalue, like the built-in LOC().
+
 fmax-array-constructor=
 Fortran RejectNegative Joined UInteger
 -fmax-array-constructor=<n>	Maximum number of objects in an array constructor
@@ -501,6 +569,10 @@ fstack-arrays
 Fortran
 Put all local arrays on stack.
 
+ftype-print
+Fortran
+Interpret TYPE as an alias for PRINT
+
 fmodule-private
 Fortran
 Set default accessibility of module entities to PRIVATE.
diff --git a/gcc/fortran/libgfortran.h b/gcc/fortran/libgfortran.h
index 30b3b7bcee7..ef7047884f3 100644
--- a/gcc/fortran/libgfortran.h
+++ b/gcc/fortran/libgfortran.h
@@ -128,7 +128,7 @@ libgfortran_stat_codes;
    used in the run-time library for IO.  */
 typedef enum
 { BT_UNKNOWN = 0, BT_INTEGER, BT_LOGICAL, BT_REAL, BT_COMPLEX,
-  BT_DERIVED, BT_CHARACTER, BT_CLASS, BT_PROCEDURE, BT_HOLLERITH, BT_VOID,
-  BT_ASSUMED
+  BT_DERIVED, BT_CHARACTER, BT_CLASS, BT_PROCEDURE, BT_HOLLERITH, BT_UNION,
+  BT_VOID, BT_ASSUMED
 }
 bt;
diff --git a/gcc/fortran/match.c b/gcc/fortran/match.c
index 9827b6c4860..185e9c94b8c 100644
--- a/gcc/fortran/match.c
+++ b/gcc/fortran/match.c
@@ -111,6 +111,126 @@ gfc_op2string (gfc_intrinsic_op op)
 
 /******************** Generic matching subroutines ************************/
 
+/* Matches a member separator. With F90+ this is '%', but with
+   -fdec-member-dot we must carefully match dot ('.').
+   Because operators are spelled ".op.", "x.y.z" can be either a component
+   access (x->y)->z or a binary operation y(x,z). Here we choose to deal with
+   the "x.y.z" ambiguity in a manner consistent with Intel:
+     (1) If any user defined operator ".y." exists, this is always y(x,z)
+         (even if ".y." is the wrong type and/or x has a member y).
+     (2) Otherwise if x has a member y, and y is itself a derived type,
+         this is (x->y)->z, even if an intrinsic operator exists which 
+         can handle (x,z). 
+     (3) If x has no member y or (x->y) is not a derived type but ".y." 
+         is an intrinsic operator (such as ".eq."), this is y(x,z).
+     (4) Lastly if there is no operator ".y." and x has no member "y", it is an
+         error.  
+   It is worth noting that [fortunately] Intel does not support mixed use of
+   member accessors within a single string, nor does it support parenthesised
+   member accesses (therefore neither do we).
+   That is, even if x has component y and y has component z, the following
+   are all syntax errors:  "x%y.z"  "x.y%z"  "(x.y).z"  "(x%y)%z"
+ */
+
+match
+gfc_match_member_sep(gfc_symbol *sym)
+{
+    char name[GFC_MAX_SYMBOL_LEN + 1];
+    locus dot_loc, start_loc;
+    gfc_intrinsic_op iop;
+    match m;
+    gfc_symbol *tsym;
+    gfc_component *c;
+
+    /* Thank god; '%' is an unambiguous member separator. */
+    if (gfc_match_char ('%') == MATCH_YES)
+        return MATCH_YES;
+
+    /* Only continue if dot member separators are enabled. */
+    if (!gfc_option.flag_dec_member_dot || !sym)
+        return MATCH_NO;
+
+    tsym = NULL;
+
+    /* We may be given either a derived type variable or the derived type
+       declaration itself (which actually contains the components); 
+       if this is a member access we need the latter to check components. */
+    if (gfc_fl_struct (sym->attr.flavor))
+        tsym = sym;
+    else if (gfc_bt_struct (sym->ts.type))
+        tsym = sym->ts.u.derived;
+    else
+        return MATCH_NO;
+
+    iop = INTRINSIC_NONE;
+    name[0] = '\0';
+    m = MATCH_NO;
+
+    /* If we have to reject, come back here later. */
+    start_loc = gfc_current_locus;
+
+    /* Look for a component access next. */
+    if (gfc_match_char ('.') != MATCH_YES)
+        return MATCH_NO;
+
+    /* If we accept, come back here. */
+    dot_loc = gfc_current_locus;
+
+    /* Try to match a symbol name following '.' */
+    if (gfc_match_name (name) != MATCH_YES)
+    {
+        gfc_error ("Expected structure component or operator name "
+                   "after '.' at %C");
+        goto error;
+    }
+
+    /* If no dot follows we have "x.y" which must be a component access.
+       Ensure the leading symbol is a derived type variable. */
+    if (gfc_match_char ('.') != MATCH_YES)
+        goto yes;
+
+    /* Now we have a string "x.y.z" which could be a nested member access
+       (x->y)->z or a binary operation y on x and z. */
+
+    /* First use any user-defined operators ".y." */
+    if (gfc_find_uop (name, sym->ns) != NULL)
+        goto no;
+
+    /* Match accesses to existing derived-type components for 
+       derived-type vars: "x.y.z" = (x->y)->z */
+    c = gfc_find_component(tsym, name, false, true, NULL);
+    if (c && (c->ts.type == BT_DERIVED || c->ts.type == BT_CLASS))
+        goto yes;
+
+    /* If y is not a component or has no members, try intrinsic operators. */
+    gfc_current_locus = start_loc;
+    if (gfc_match_intrinsic_op (&iop) != MATCH_YES)
+    {
+        /* If ".y." is not an intrinsic operator but y was a valid non-
+           structure component, match and leave the trailing dot to be 
+           dealt with later. */
+        if (c)
+            goto yes;
+
+        gfc_error ("'%s' is neither a defined operator nor a "
+                   "structure component in dotted string at %C", name);
+        goto error;
+    }
+
+    /* .y. is an intrinsic operator, overriding any possible member access. */
+    goto no;
+
+    /* Return keeping the current locus consistent with the match result. */
+error:
+    m = MATCH_ERROR;
+no:
+    gfc_current_locus = start_loc;
+    return m;
+yes:
+    gfc_current_locus = dot_loc;
+    return MATCH_YES;
+}
+
 /* This function scans the current statement counting the opened and closed
    parenthesis to make sure they are balanced.  */
 
@@ -320,6 +440,219 @@ gfc_match_eos (void)
   return (flag) ? MATCH_YES : MATCH_NO;
 }
 
+/* As with gfc_check_digit, but allow any radix in [2,36]. */
+
+static int
+check_digit_extended (char c, int radix)
+{
+  int r = 0;
+  if (radix < 2 || radix > 36)
+      gfc_internal_error ("check_digit_extended(): bad radix");
+  else if (radix <= 10)
+      r = '0' <= c && c < ('0'+radix);
+  else
+      r =    ('0' <= c && c < ('0' +   radix   ))
+          || ('a' <= c && c < ('a' + (radix-10)));
+
+  return r;
+}
+
+/* Given a character and a radix, see if the character is a valid
+   digit in that radix.  */
+
+int
+gfc_check_digit (char c, int radix)
+{
+  int r;
+
+  if (gfc_option.flag_dec_extended_int)
+      return check_digit_extended (c, radix);
+
+  switch (radix)
+    {
+    case 2:
+      r = ('0' <= c && c <= '1');
+      break;
+
+    case 8:
+      r = ('0' <= c && c <= '7');
+      break;
+
+    case 10:
+      r = ('0' <= c && c <= '9');
+      break;
+
+    case 16:
+      r = ISXDIGIT (c);
+      break;
+
+    default:
+      gfc_internal_error ("gfc_check_digit(): bad radix");
+    }
+
+  return r;
+}
+
+/* Matches '+' or '-', and sets sign to 1 or -1 respectively if not NULL. */
+
+match
+gfc_match_sign (int *sign)
+{
+    match m;
+    if ((m = gfc_match_char ('+')) == MATCH_YES && sign)
+        *sign = 1;
+    else if ((m = gfc_match_char ('-')) == MATCH_YES && sign)
+        *sign = -1;
+    return m;
+}
+
+/* Match a radix as a base 10 number between 2 and 36. On MATCH_YES set
+   *radixp to the result if not NULL. (If NULL, still matches a radix.) */
+
+match
+gfc_match_radix (int *radixp)
+{
+    char radixbuf[3] = {'\0', '\0', '\0'};
+    locus old_loc;
+    int length, radix;
+    match m;
+
+    /* Get the length of a potential radix. */
+    old_loc = gfc_current_locus;
+    m = gfc_match_literal_int (NULL, 10, &length);
+    if (m != MATCH_YES)
+        return m;
+    gfc_current_locus = old_loc;
+
+    /* Base can't have more than two digits. */
+    if (length > 2)
+    {
+        gfc_error ("Base too large at %C");
+        return MATCH_ERROR;
+    }
+
+    gcc_assert (gfc_match_literal_int (radixbuf, 10, NULL) == MATCH_YES);
+    radix = atoi(radixbuf);
+
+    if (radix < 2 || radix > 36)
+    {
+        gfc_error ("Base '%d' out of range at %C", radix);
+        return MATCH_ERROR;
+    }
+
+    if (radixp)
+        *radixp = atoi (radixbuf);
+
+    return MATCH_YES;
+}
+
+/* Match the digit string part of an integer. If the buffer 
+   is NULL, we just count characters for the resolution pass returned
+   in *cnt (if not NULL). Returns whether an integer was successfully matched
+   using the given radix. */
+
+match
+gfc_match_literal_int (char *buffer, int radix, int *cnt)
+{
+  locus old_loc;
+  int length;
+  char c;
+  match m;
+
+  length = 0;
+  m = MATCH_YES;
+  old_loc = gfc_current_locus;
+  c = gfc_next_ascii_char ();
+
+  if (!gfc_check_digit (c, radix))
+  {
+    length = -1;
+    m = MATCH_NO;
+    goto done;
+  }
+
+  length++;
+  if (buffer != NULL)
+    *buffer++ = c;
+
+  for (;;)
+    {
+      old_loc = gfc_current_locus;
+      c = gfc_next_ascii_char ();
+
+      if (!gfc_check_digit (c, radix))
+	break;
+
+      if (buffer != NULL)
+	*buffer++ = c;
+      length++;
+    }
+
+
+done:
+  gfc_current_locus = old_loc;
+  if (cnt)
+      *cnt = length;
+  /* If digit belongs to another radix, we can give some helpful information */
+  if (gfc_option.flag_dec_extended_int && check_digit_extended (c, 36))
+      gfc_error ("Invalid digit '%c' in base %d integer constant at %C",
+                 c, radix);
+  return m;
+}
+
+/* Match a DEC extended 'base#value' integer if -fdec-extended-int is
+   enabled. 
+   On MATCH_YES, if not NULL:
+     buffer -> the value string
+     *radix -> the radix of the value
+     *cnt   -> the length of the value string */
+
+match
+gfc_match_extended_integer (char *buffer, int *radix, int *cnt)
+{
+  match m;
+  int base, length;
+  locus old_loc;
+  
+  base = 10;
+  old_loc = gfc_current_locus;
+  gfc_gobble_whitespace ();
+  m = gfc_match_literal_int (buffer, 10, &length);
+
+  /* If we see a '#' this is an extended base#val int; otherwise the number we
+     just matched is the number. */
+  if (gfc_peek_ascii_char () == '#' && gfc_option.flag_dec_extended_int)
+  {
+      gfc_current_locus = old_loc;
+      base = 16;
+      /* If no radix is found we default to 16. Out-of-range is an error. */
+      if (gfc_match_radix (&base) == MATCH_ERROR)
+          return MATCH_ERROR;
+      gcc_assert (gfc_match_char ('#') == MATCH_YES);
+
+      old_loc = gfc_current_locus;
+      m = gfc_match_literal_int (buffer, base, &length);
+      if (buffer)
+          buffer[length] = '\0';
+      if (m != MATCH_YES)
+      {
+          gfc_current_locus = old_loc;
+          gfc_error ("Expected base %d integer after '#' in extended integer "
+                     "constant at %C", base);
+          return MATCH_ERROR;
+      }
+  }
+
+  if (m == MATCH_YES)
+  {
+      if (radix)
+          *radix = base;
+      if (cnt)
+          *cnt = length;
+  }
+
+  return m;
+}
 
 /* Match a literal integer on the input, setting the value on
    MATCH_YES.  Literal ints occur in kind-parameters as well as
@@ -920,6 +1253,18 @@ gfc_match_intrinsic_op (gfc_intrinsic_op *result)
 	    }
 	  break;
 
+        case 'x':
+          if (gfc_option.flag_dec_logical_xor
+              && gfc_next_ascii_char () == 'o'
+              && gfc_next_ascii_char () == 'r'
+              && gfc_next_ascii_char () == '.')
+            {
+              /* Matched ".xor." -> equivalent to ".neqv." */
+              *result = INTRINSIC_NEQV;
+              return MATCH_YES;
+            }
+          break;
+
 	default:
 	  break;
 	}
@@ -1576,6 +1921,11 @@ gfc_match_if (gfc_statement *if_type)
   match ("where", match_simple_where, ST_WHERE)
   match ("write", gfc_match_write, ST_WRITE)
 
+  if (gfc_option.flag_type_print)
+    {
+      match ("type", gfc_match_print, ST_WRITE)
+    }
+
   /* The gfc_match_assignment() above may have returned a MATCH_NO
      where the assignment was to a named constant.  Check that
      special case here.  */
@@ -1920,7 +2270,7 @@ match_derived_type_spec (gfc_typespec *ts)
   if (derived && derived->attr.flavor == FL_PROCEDURE && derived->attr.generic)
     derived = gfc_find_dt_in_generic (derived);
 
-  if (derived && derived->attr.flavor == FL_DERIVED)
+  if (derived && gfc_fl_struct (derived->attr.flavor))
     {
       ts->type = BT_DERIVED;
       ts->u.derived = derived;
@@ -5222,7 +5572,7 @@ select_intrinsic_set_tmp (gfc_typespec *ts)
   gfc_symtree *tmp;
   int charlen = 0;
 
-  if (ts->type == BT_CLASS || ts->type == BT_DERIVED)
+  if (ts->type == BT_CLASS || gfc_bt_struct (ts->type))
     return NULL;
 
   if (select_type_stack->selector->ts.type == BT_CLASS
diff --git a/gcc/fortran/match.h b/gcc/fortran/match.h
index 48aa4056e17..a865b91d718 100644
--- a/gcc/fortran/match.h
+++ b/gcc/fortran/match.h
@@ -45,6 +45,10 @@ extern gfc_access gfc_typebound_default_access;
 match gfc_match_special_char (gfc_char_t *);
 match gfc_match_space (void);
 match gfc_match_eos (void);
+match gfc_match_literal_int (char *, int, int *);
+match gfc_match_extended_integer (char *, int *, int *);
+match gfc_match_radix (int *);
+match gfc_match_sign (int *);
 match gfc_match_small_literal_int (int *, int *);
 match gfc_match_st_label (gfc_st_label **);
 match gfc_match_label (void);
@@ -59,6 +63,7 @@ match gfc_match_char (char);
 match gfc_match (const char *, ...);
 match gfc_match_iterator (gfc_iterator *, int);
 match gfc_match_parens (void);
+match gfc_match_member_sep(gfc_symbol *);
 
 /* Statement matchers.  */
 match gfc_match_program (void);
@@ -159,8 +164,12 @@ match gfc_match_generic (void);
 match gfc_match_function_decl (void);
 match gfc_match_entry (void);
 match gfc_match_subroutine (void);
+match gfc_match_map (void);
+match gfc_match_union (void);
+match gfc_match_structure_decl (void);
 match gfc_match_derived_decl (void);
 match gfc_match_final_decl (void);
+match gfc_match_type (gfc_statement *);
 
 match gfc_match_implicit_none (void);
 match gfc_match_implicit (void);
@@ -184,6 +193,8 @@ match gfc_match_pointer (void);
 match gfc_match_protected (void);
 match gfc_match_private (gfc_statement *);
 match gfc_match_public (gfc_statement *);
+match gfc_match_automatic (void);
+match gfc_match_static (void);
 match gfc_match_save (void);
 match gfc_match_modproc (void);
 match gfc_match_target (void);
@@ -191,6 +202,7 @@ match gfc_match_value (void);
 match gfc_match_volatile (void);
 
 /* decl.c.  */
+match gfc_match_clist_expr (gfc_expr **, gfc_typespec *, bool);
 
 /* Fortran 2003 c interop.
    TODO: some of these should be moved to another file rather than decl.c */
diff --git a/gcc/fortran/mathbuiltins.def b/gcc/fortran/mathbuiltins.def
index 8236d5c1a1d..ea4403a1d3d 100644
--- a/gcc/fortran/mathbuiltins.def
+++ b/gcc/fortran/mathbuiltins.def
@@ -70,3 +70,10 @@ OTHER_BUILTIN (POW,       "pow",       1,       true)
 OTHER_BUILTIN (ROUND,     "round",     1,       true)
 OTHER_BUILTIN (SCALBN,    "scalbn",    scalbn,  true)
 OTHER_BUILTIN (TRUNC,     "trunc",     1,       true)
+
+/* MATH_ALIAS_BUILTIN (NEWID, OLDID, NAME, ARGTYPE)
+   NEWID  The new id of the builtin (to match GFC_ISYM_* in gfortran.h)
+   OLDID  The id of the actual builtin to alias ""
+   NAME   Te name of the new builtin
+   ARGTYPE The type of the arguments, to match that of OLDID */
+MATH_ALIAS_BUILTIN (COTAN, TAN, "tan", 0)
diff --git a/gcc/fortran/misc.c b/gcc/fortran/misc.c
index cce599b3cbc..8e097e14f2c 100644
--- a/gcc/fortran/misc.c
+++ b/gcc/fortran/misc.c
@@ -92,6 +92,9 @@ gfc_basic_typename (bt type)
     case BT_HOLLERITH:
       p = "HOLLERITH";
       break;
+    case BT_UNION:
+      p = "UNION";
+      break;
     case BT_DERIVED:
       p = "DERIVED";
       break;
@@ -153,6 +156,9 @@ gfc_typename (gfc_typespec *ts)
     case BT_HOLLERITH:
       sprintf (buffer, "HOLLERITH");
       break;
+    case BT_UNION:
+      sprintf (buffer, "UNION(%s)", ts->u.derived->name);
+      break;
     case BT_DERIVED:
       sprintf (buffer, "TYPE(%s)", ts->u.derived->name);
       break;
diff --git a/gcc/fortran/module.c b/gcc/fortran/module.c
index 4fd0d883c84..59d3aa5d661 100644
--- a/gcc/fortran/module.c
+++ b/gcc/fortran/module.c
@@ -406,8 +406,8 @@ resolve_fixups (fixup_t *f, void *gp)
    to convert the symtree name of a derived-type to the symbol name or to
    the name of the associated generic function.  */
 
-static const char *
-dt_lower_string (const char *name)
+const char *
+gfc_dt_lower_string (const char *name)
 {
   if (name[0] != (char) TOLOWER ((unsigned char) name[0]))
     return gfc_get_string ("%c%s", (char) TOLOWER ((unsigned char) name[0]),
@@ -421,8 +421,8 @@ dt_lower_string (const char *name)
    symtree/symbol name of the associated generic function start with a lower-
    case character.  */
 
-static const char *
-dt_upper_string (const char *name)
+const char *
+gfc_dt_upper_string (const char *name)
 {
   if (name[0] != (char) TOUPPER ((unsigned char) name[0]))
     return gfc_get_string ("%c%s", (char) TOUPPER ((unsigned char) name[0]),
@@ -724,7 +724,7 @@ find_use_name_n (const char *name, int *inst, bool interface)
 
   /* For derived types.  */
   if (name[0] != (char) TOLOWER ((unsigned char) name[0]))
-    low_name = dt_lower_string (name);
+    low_name = gfc_dt_lower_string (name);
 
   i = 0;
   for (u = gfc_rename_list; u; u = u->next)
@@ -753,7 +753,7 @@ find_use_name_n (const char *name, int *inst, bool interface)
     {
       if (u->local_name[0] == '\0')
 	return name;
-      return dt_upper_string (u->local_name);
+      return gfc_dt_upper_string (u->local_name);
     }
 
   return (u->local_name[0] != '\0') ? u->local_name : name;
@@ -881,8 +881,8 @@ add_true_name (gfc_symbol *sym)
 
   t = XCNEW (true_name);
   t->sym = sym;
-  if (sym->attr.flavor == FL_DERIVED)
-    t->name = dt_upper_string (sym->name);
+  if (gfc_fl_struct (sym->attr.flavor))
+    t->name = gfc_dt_upper_string (sym->name);
   else
     t->name = sym->name;
 
@@ -903,8 +903,8 @@ build_tnt (gfc_symtree *st)
   build_tnt (st->left);
   build_tnt (st->right);
 
-  if (st->n.sym->attr.flavor == FL_DERIVED)
-    name = dt_upper_string (st->n.sym->name);
+  if (gfc_fl_struct (st->n.sym->attr.flavor))
+    name = gfc_dt_upper_string (st->n.sym->name);
   else
     name = st->n.sym->name;
 
@@ -2219,6 +2219,8 @@ static const mstring bt_types[] = {
     minit ("COMPLEX", BT_COMPLEX),
     minit ("LOGICAL", BT_LOGICAL),
     minit ("CHARACTER", BT_CHARACTER),
+    minit ("HOLLERITH", BT_HOLLERITH),
+    minit ("UNION", BT_UNION),
     minit ("DERIVED", BT_DERIVED),
     minit ("CLASS", BT_CLASS),
     minit ("PROCEDURE", BT_PROCEDURE),
@@ -2272,7 +2274,7 @@ mio_typespec (gfc_typespec *ts)
 
   ts->type = MIO_NAME (bt) (ts->type, bt_types);
 
-  if (ts->type != BT_DERIVED && ts->type != BT_CLASS)
+  if (!gfc_bt_struct (ts->type) && ts->type != BT_CLASS)
     mio_integer (&ts->kind);
   else
     mio_symbol_ref (&ts->u.derived);
@@ -3088,8 +3090,8 @@ fix_mio_expr (gfc_expr *e)
       if (e->symtree->n.sym && check_unique_name (e->symtree->name))
 	{
           const char *name = e->symtree->n.sym->name;
-	  if (e->symtree->n.sym->attr.flavor == FL_DERIVED)
-	    name = dt_upper_string (name);
+	  if (gfc_fl_struct (e->symtree->n.sym->attr.flavor))
+	    name = gfc_dt_upper_string (name);
 	  ns_st = gfc_find_symtree (gfc_current_ns->sym_root, name);
 	}
 
@@ -3779,7 +3781,7 @@ mio_symbol (gfc_symbol *sym)
   
   mio_integer (&(sym->intmod_sym_id));
 
-  if (sym->attr.flavor == FL_DERIVED)
+  if (gfc_fl_struct (sym->attr.flavor))
     mio_integer (&(sym->hash_value));
 
   mio_rparen ();
@@ -4310,7 +4312,7 @@ load_needed (pointer_info *p)
 				 1, &ns->proc_name);
 
       sym = gfc_new_symbol (p->u.rsym.true_name, ns);
-      sym->name = dt_lower_string (p->u.rsym.true_name);
+      sym->name = gfc_dt_lower_string (p->u.rsym.true_name);
       sym->module = gfc_get_string (p->u.rsym.module);
       if (p->u.rsym.binding_label)
 	sym->binding_label = IDENTIFIER_POINTER (get_identifier 
@@ -4322,6 +4324,12 @@ load_needed (pointer_info *p)
   mio_symbol (sym);
   sym->attr.use_assoc = 1;
 
+  /* Unliked derived types, a STRUCTURE may share names with other symbols.
+     We greedily converted the the symbol name to lowercase before we knew its
+     type, so now we must fix it. */
+  if (sym->attr.flavor == FL_STRUCT)
+    sym->name = gfc_dt_upper_string (sym->name);
+
   /* Mark as only or rename for later diagnosis for explicitly imported
      but not used warnings; don't mark internal symbols such as __vtab,
      __def_init etc. Only mark them if they have been explicitly loaded.  */
@@ -4521,7 +4529,7 @@ read_module (void)
 	 can be used in expressions in the module.  To avoid the module loading
 	 failing, we need to associate the module's component pointer indexes
 	 with the existing symbol's component pointers.  */
-      if (sym->attr.flavor == FL_DERIVED)
+      if (gfc_fl_struct (sym->attr.flavor))
 	{
 	  gfc_component *c;
 
@@ -4673,7 +4681,7 @@ read_module (void)
 		{
 		  info->u.rsym.sym = gfc_new_symbol (info->u.rsym.true_name,
 						     gfc_current_ns);
-		  info->u.rsym.sym->name = dt_lower_string (info->u.rsym.true_name);
+		  info->u.rsym.sym->name = gfc_dt_lower_string (info->u.rsym.true_name);
 		  sym = info->u.rsym.sym;
 		  sym->module = gfc_get_string (info->u.rsym.module);
 
@@ -5056,10 +5064,10 @@ write_symbol (int n, gfc_symbol *sym)
 
   mio_integer (&n);
 
-  if (sym->attr.flavor == FL_DERIVED)
+  if (gfc_fl_struct (sym->attr.flavor))
     {
       const char *name;
-      name = dt_upper_string (sym->name);
+      name = gfc_dt_upper_string (sym->name);
       mio_pool_string (&name);
     }
   else
@@ -5870,7 +5878,7 @@ create_derived_type (const char *name, const char *modname,
   sym->attr.function = 1;
   sym->attr.generic = 1;
 
-  gfc_get_sym_tree (dt_upper_string (sym->name),
+  gfc_get_sym_tree (gfc_dt_upper_string (sym->name),
 		    gfc_current_ns, &tmp_symtree, false);
   dt_sym = tmp_symtree->n.sym;
   dt_sym->name = gfc_get_string (sym->name);
diff --git a/gcc/fortran/openmp.c b/gcc/fortran/openmp.c
index 05de49bd79b..3724e6e2aef 100644
--- a/gcc/fortran/openmp.c
+++ b/gcc/fortran/openmp.c
@@ -815,7 +815,9 @@ resolve_omp_clauses (gfc_code *code)
     {
       gfc_expr *expr = omp_clauses->if_expr;
       if (gfc_resolve_expr (expr) == FAILURE
-	  || expr->ts.type != BT_LOGICAL || expr->rank != 0)
+	   || ((expr->ts.type != BT_LOGICAL || expr->rank != 0)
+               && (!gfc_option.flag_lazy_logicals
+                   || expr->ts.type != BT_INTEGER)))
 	gfc_error ("IF clause at %L requires a scalar LOGICAL expression",
 		   &expr->where);
     }
diff --git a/gcc/fortran/options.c b/gcc/fortran/options.c
index fba1a3f3a88..2def9e123cb 100644
--- a/gcc/fortran/options.c
+++ b/gcc/fortran/options.c
@@ -51,6 +51,51 @@ set_default_std_flags (void)
   gfc_option.warn_std = GFC_STD_F95_DEL | GFC_STD_LEGACY;
 }
 
+static void
+set_missing_include_dirs (int value)
+{
+  gfc_option.warn_missing_include_dirs = value;
+
+  /* We might have buffered an include dir warning, so clear it.
+     (We know the buffered warning is an include dir warning because all
+     other warnings issued during cmdline parsing use gfc_warning_now.) */
+  if (!value)
+    gfc_clear_warning ();
+}
+
+/* Set all the DEC extension flags. */
+
+static void
+set_dec_flags (int value)
+{
+  if (value)
+    {
+      /* Allow legacy code without warnings.  */
+      gfc_option.allow_std |= GFC_STD_F95_OBS | GFC_STD_F95_DEL
+        | GFC_STD_GNU | GFC_STD_LEGACY;
+      gfc_option.warn_std &= ~(GFC_STD_LEGACY | GFC_STD_F95_DEL);
+
+      gfc_option.flag_dollar_ok = 1;
+      gfc_option.flag_d_lines = 0; /* -fd-lines-as-comments */
+      gfc_option.flag_loc_rval = 1;
+      gfc_option.warn_format_tab = 0;
+      set_missing_include_dirs (0);
+    }
+
+  /* Set other DEC compatibility extensions.  */
+  gfc_option.flag_dec_extended_int = value;
+  gfc_option.flag_dec_structure  = value;
+  gfc_option.flag_dec_member_dot = value;
+  gfc_option.flag_dec_math = value;
+  gfc_option.flag_dec_logical_xor = value;
+  gfc_option.flag_lazy_logicals = value;
+  gfc_option.flag_dec_bitwise_ops = value;
+  gfc_option.flag_dec_io = value;
+  gfc_option.flag_dec_intrinsic_ints = value;
+  gfc_option.flag_dec_static = value;
+  gfc_option.flag_feed = value;
+  gfc_option.flag_type_print = value;
+}
 
 /* Return language mask for Fortran options.  */
 
@@ -113,6 +158,9 @@ gfc_init_options (unsigned int decoded_options_count,
   gfc_option.warn_realloc_lhs_all = 0;
   gfc_option.warn_compare_reals = 0;
   gfc_option.warn_target_lifetime = 0;
+  gfc_option.warn_argument_mismatch = 1;
+  gfc_option.warn_format_tab = 1;
+  gfc_option.warn_missing_include_dirs = 1;
   gfc_option.max_errors = 25;
 
   gfc_option.flag_all_intrinsics = 0;
@@ -155,6 +203,7 @@ gfc_init_options (unsigned int decoded_options_count,
   gfc_option.flag_init_logical = GFC_INIT_LOGICAL_OFF;
   gfc_option.flag_init_character = GFC_INIT_CHARACTER_OFF;
   gfc_option.flag_init_character_value = (char)0;
+  gfc_option.flag_init_derived = 0;
   gfc_option.flag_align_commons = 1;
   gfc_option.flag_protect_parens = -1;
   gfc_option.flag_realloc_lhs = -1;
@@ -165,10 +214,15 @@ gfc_init_options (unsigned int decoded_options_count,
   gfc_option.rtcheck = 0;
   gfc_option.coarray = GFC_FCOARRAY_NONE;
 
+  gfc_option.flag_loc_rval = 0;
+  set_dec_flags (0);
+
   set_default_std_flags ();
 
   /* Initialize cpp-related options.  */
   gfc_cpp_init_options (decoded_options_count, decoded_options);
+
+  gfc_buffer_error (1);
 }
 
 
@@ -257,6 +311,9 @@ gfc_post_options (const char **pfilename)
   char *source_path;
   int i;
 
+  gfc_warning_check ();
+  gfc_buffer_error (0);
+
   /* Excess precision other than "fast" requires front-end
      support.  */
   if (flag_excess_precision_cmdline == EXCESS_PRECISION_STANDARD
@@ -726,6 +783,18 @@ gfc_handle_option (size_t scode, const char *arg, int value,
       gfc_option.warn_unused_dummy_argument = value;
       break;
 
+    case OPT_Wargument_mismatch:
+      gfc_option.warn_argument_mismatch = value;
+      break;
+
+    case OPT_Wformat_tab:
+      gfc_option.warn_format_tab = value;
+      break;
+
+    case OPT_Wmissing_include_dirs:
+      set_missing_include_dirs (value);
+      break;
+
     case OPT_fall_intrinsics:
       gfc_option.flag_all_intrinsics = 1;
       break;
@@ -942,6 +1011,10 @@ gfc_handle_option (size_t scode, const char *arg, int value,
       gfc_option.flag_init_character_value = (char)0;
       break;
 
+    case OPT_finit_derived:
+      gfc_option.flag_init_derived = 1;
+      break;
+
     case OPT_finit_logical_:
       if (!strcasecmp (arg, "false"))
 	gfc_option.flag_init_logical = GFC_INIT_LOGICAL_FALSE;
@@ -1119,6 +1192,64 @@ gfc_handle_option (size_t scode, const char *arg, int value,
     case OPT_fcoarray_:
       gfc_handle_coarray_option (arg);
       break;
+
+    case OPT_flazy_logicals:
+      gfc_option.flag_lazy_logicals = 1;
+      gfc_option.flag_dec_bitwise_ops = 1;
+      break;
+
+    case OPT_floc_rval:
+      gfc_option.flag_loc_rval = 1;
+      break;
+
+    case OPT_fdec:
+      /* Enable all DEC extensions. */
+      set_dec_flags (1);
+      break;
+
+    case OPT_fdec_extended_int:
+      gfc_option.flag_dec_extended_int = 1;
+      break;
+
+    case OPT_fdec_structure:
+      gfc_option.flag_dec_structure = 1;
+      /* Fall-through: -fdec-structure implies -fdec-member-dot. */
+
+    case OPT_fdec_member_dot:
+      gfc_option.flag_dec_member_dot = 1;
+      break;
+
+    case OPT_fdec_math:
+      gfc_option.flag_dec_math = 1;
+      break;
+
+    case OPT_fdec_logical_xor:
+      gfc_option.flag_dec_logical_xor = 1;
+      break;
+
+    case OPT_fdec_bitwise_ops:
+      gfc_option.flag_dec_bitwise_ops = 1;
+      break;
+
+    case OPT_fdec_io:
+      gfc_option.flag_dec_io = 1;
+      break;
+
+    case OPT_fdec_intrinsic_ints:
+      gfc_option.flag_dec_intrinsic_ints = 1;
+      break;
+
+    case OPT_fdec_static:
+      gfc_option.flag_dec_static = 1;
+      break;
+
+    case OPT_ffeed:
+      gfc_option.flag_feed = 1;
+      break;
+
+    case OPT_ftype_print:
+      gfc_option.flag_type_print = 1;
+      break;
     }
 
   Fortran_handle_option_auto (&global_options, &global_options_set, 
diff --git a/gcc/fortran/parse.c b/gcc/fortran/parse.c
index f748fe3262e..4899743cdd1 100644
--- a/gcc/fortran/parse.c
+++ b/gcc/fortran/parse.c
@@ -162,6 +162,7 @@ decode_specification_statement (void)
 	     ST_INTERFACE);
       match ("allocatable", gfc_match_allocatable, ST_ATTR_DECL);
       match ("asynchronous", gfc_match_asynchronous, ST_ATTR_DECL);
+      match ("automatic", gfc_match_automatic, ST_ATTR_DECL);
       break;
 
     case 'b':
@@ -227,6 +228,8 @@ decode_specification_statement (void)
 
     case 's':
       match ("save", gfc_match_save, ST_ATTR_DECL);
+      match ("static", gfc_match_static, ST_ATTR_DECL);
+      match ("structure", gfc_match_structure_decl, ST_STRUCTURE_DECL);
       break;
 
     case 't':
@@ -275,6 +278,10 @@ decode_statement (void)
 
   gfc_matching_function = false;
 
+  /* Legacy parameter statements are ambiguous with assignments so try
+   * parameter first.  */
+  match ("parameter", gfc_match_parameter, ST_PARAMETER);
+
   if (gfc_match_eos () == MATCH_YES)
     return ST_NONE;
 
@@ -359,6 +366,12 @@ decode_statement (void)
   gfc_undo_symbols ();
   gfc_current_locus = old_locus;
 
+  /* Try to match TYPE as an alias for PRINT.  */
+  if (gfc_match_type (&st) == MATCH_YES)
+    return st;
+  gfc_undo_symbols ();
+  gfc_current_locus = old_locus;
+
   match (NULL, gfc_match_do, ST_DO);
   match (NULL, gfc_match_block, ST_BLOCK);
   match (NULL, gfc_match_associate, ST_ASSOCIATE);
@@ -384,6 +397,7 @@ decode_statement (void)
       match ("allocatable", gfc_match_allocatable, ST_ATTR_DECL);
       match ("assign", gfc_match_assign, ST_LABEL_ASSIGNMENT);
       match ("asynchronous", gfc_match_asynchronous, ST_ATTR_DECL);
+      match ("automatic", gfc_match_automatic, ST_ATTR_DECL);
       break;
 
     case 'b':
@@ -454,6 +468,7 @@ decode_statement (void)
       break;
 
     case 'm':
+      match ("map", gfc_match_map, ST_MAP);
       match ("module% procedure", gfc_match_modproc, ST_MODULE_PROC);
       match ("module", gfc_match_module, ST_MODULE);
       break;
@@ -470,7 +485,6 @@ decode_statement (void)
 
     case 'p':
       match ("print", gfc_match_print, ST_WRITE);
-      match ("parameter", gfc_match_parameter, ST_PARAMETER);
       match ("pause", gfc_match_pause, ST_PAUSE);
       match ("pointer", gfc_match_pointer, ST_ATTR_DECL);
       if (gfc_match_private (&st) == MATCH_YES)
@@ -489,8 +503,11 @@ decode_statement (void)
       break;
 
     case 's':
+      // DEC extension: treat STRUCTURE /name/ ... as TYPE name ...
+      match ("structure", gfc_match_structure_decl, ST_STRUCTURE_DECL);
       match ("sequence", gfc_match_eos, ST_SEQUENCE);
       match ("stop", gfc_match_stop, ST_STOP);
+      match ("static", gfc_match_static, ST_ATTR_DECL);
       match ("save", gfc_match_save, ST_ATTR_DECL);
       match ("sync all", gfc_match_sync_all, ST_SYNC_ALL);
       match ("sync images", gfc_match_sync_images, ST_SYNC_IMAGES);
@@ -504,6 +521,7 @@ decode_statement (void)
       break;
 
     case 'u':
+      match ("union", gfc_match_union, ST_UNION);
       match ("unlock", gfc_match_unlock, ST_UNLOCK);
       break;
 
@@ -812,6 +830,9 @@ next_fixed (void)
 	{
 	case ' ':
 	  break;
+        case '\f':
+          if (gfc_option.flag_feed)
+            break;
 
 	case '0':
 	case '1':
@@ -1220,6 +1241,68 @@ gfc_enclosing_unit (gfc_compile_state * result)
   return NULL;
 }
 
+/* Translate a compile state to an ascii string. */
+
+const char *
+gfc_ascii_comp_state(gfc_compile_state c)
+{
+    const char *p = "NONE";
+    switch(c) {
+    case COMP_PROGRAM:
+        p = "PROGRAM"; break;
+    case COMP_MODULE:
+        p = "MODULE"; break;
+    case COMP_SUBROUTINE:
+        p = "SUBROUTINE"; break;
+    case COMP_FUNCTION:
+        p = "FUNCTION"; break;
+    case COMP_BLOCK_DATA:
+        p = "BLOCK DATA"; break;
+    case COMP_INTERFACE:
+        p = "INTERFACE"; break;
+    case COMP_DERIVED:
+        p = "DERIVED"; break;
+    case COMP_DERIVED_CONTAINS:
+        p = "DERIVED CONTAINS"; break;
+    case COMP_UNION:
+        p = "UNION"; break;
+    case COMP_MAP:
+        p = "MAP"; break;
+    case COMP_STRUCTURE:
+        p = "STRUCTURE"; break;
+    case COMP_BLOCK:
+        p = "BLOCK"; break;
+    case COMP_ASSOCIATE:
+        p = "ASSOCIATE"; break;
+    case COMP_IF:
+        p = "IF"; break;
+    case COMP_DO:
+        p = "DO"; break;
+    case COMP_SELECT:
+        p = "SELECT"; break;
+    case COMP_FORALL:
+        p = "FORALL"; break;
+    case COMP_WHERE:
+        p = "WHERE"; break;
+    case COMP_CONTAINS:
+        p = "CONTAINS"; break;
+    case COMP_ENUM:
+        p = "ENUM"; break;
+    case COMP_SELECT_TYPE:
+        p = "SELECT TYPE"; break;
+    case COMP_OMP_STRUCTURED_BLOCK:
+        p = "OMP STRUCTURED BLOCK"; break;
+    case COMP_CRITICAL:
+        p = "CRITICAL"; break;
+    case COMP_DO_CONCURRENT:
+        p = "CONCURRENT DO"; break;
+    case COMP_NONE:
+    default:
+        break;
+    }
+    return p;
+}
+
 
 /* Translate a statement enum to a string.  */
 
@@ -1284,6 +1367,15 @@ gfc_ascii_statement (gfc_statement st)
     case ST_DEALLOCATE:
       p = "DEALLOCATE";
       break;
+    case ST_MAP:
+      p = "MAP";
+      break;
+    case ST_UNION:
+      p = "UNION";
+      break;
+    case ST_STRUCTURE_DECL:
+      p = "STRUCTURE";
+      break;
     case ST_DERIVED_DECL:
       p = _("derived type declaration");
       break;
@@ -1344,6 +1436,15 @@ gfc_ascii_statement (gfc_statement st)
     case ST_END_WHERE:
       p = "END WHERE";
       break;
+    case ST_END_STRUCTURE:
+      p = "END STRUCTURE";
+      break;
+    case ST_END_UNION:
+      p = "END UNION";
+      break;
+    case ST_END_MAP:
+      p = "END MAP";
+      break;
     case ST_END_TYPE:
       p = "END TYPE";
       break;
@@ -1880,6 +1981,7 @@ verify_st_order (st_state *p, gfc_statement st, bool silent)
 
     case ST_PUBLIC:
     case ST_PRIVATE:
+    case ST_STRUCTURE_DECL:
     case ST_DERIVED_DECL:
     case_decl:
       if (p->state >= ORDER_EXEC)
@@ -2073,6 +2175,349 @@ error:
   return error_flag;
 }
 
+/* Set attributes for the parent symbol (gfc_symbol*)data based on the
+   attributes of a component, and raise errors if conflicting attributes
+   are found for the component. */
+
+static void
+check_component (gfc_component *c, gfc_symbol *sym, gfc_component **lockp)
+{
+  gfc_component *lock_comp = NULL;
+  bool coarray, lock_type, allocatable, pointer;
+  coarray = lock_type = allocatable = pointer = false;
+
+  if (lockp) lock_comp = *lockp;
+
+  /* Look for allocatable components.  */
+  if (c->attr.allocatable
+      || (c->ts.type == BT_CLASS && c->attr.class_ok
+          && CLASS_DATA (c)->attr.allocatable)
+      || (c->ts.type == BT_DERIVED && !c->attr.pointer
+          && c->ts.u.derived->attr.alloc_comp))
+    {
+      allocatable = true;
+      sym->attr.alloc_comp = 1;
+    }
+
+  /* Look for pointer components.  */
+  if (c->attr.pointer
+      || (c->ts.type == BT_CLASS && c->attr.class_ok
+          && CLASS_DATA (c)->attr.class_pointer)
+      || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.pointer_comp))
+    {
+      pointer = true;
+      sym->attr.pointer_comp = 1;
+    }
+
+  /* Look for procedure pointer components.  */
+  if (c->attr.proc_pointer
+      || (c->ts.type == BT_DERIVED
+          && c->ts.u.derived->attr.proc_pointer_comp))
+    sym->attr.proc_pointer_comp = 1;
+
+  /* Looking for coarray components.  */
+  if (c->attr.codimension
+      || (c->ts.type == BT_CLASS && c->attr.class_ok
+          && CLASS_DATA (c)->attr.codimension))
+    {
+      coarray = true;
+      sym->attr.coarray_comp = 1;
+    }
+ 
+  if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.coarray_comp)
+    {
+      coarray = true;
+      if (!pointer && !allocatable)
+        sym->attr.coarray_comp = 1;
+    }
+
+  /* Looking for lock_type components.  */
+  if ((c->ts.type == BT_DERIVED
+          && c->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV
+          && c->ts.u.derived->intmod_sym_id == ISOFORTRAN_LOCK_TYPE)
+      || (c->ts.type == BT_CLASS && c->attr.class_ok
+          && CLASS_DATA (c)->ts.u.derived->from_intmod
+             == INTMOD_ISO_FORTRAN_ENV
+          && CLASS_DATA (c)->ts.u.derived->intmod_sym_id
+             == ISOFORTRAN_LOCK_TYPE)
+      || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.lock_comp
+          && !allocatable && !pointer))
+    {
+      lock_type = 1;
+      lock_comp = c;
+      sym->attr.lock_comp = 1;
+    }
+
+  /* Check for F2008, C1302 - and recall that pointers may not be coarrays
+     (5.3.14) and that subobjects of coarray are coarray themselves (2.4.7),
+     unless there are nondirect [allocatable or pointer] components
+     involved (cf. 1.3.33.1 and 1.3.33.3).  */
+
+  if (pointer && !coarray && lock_type)
+    gfc_error ("Component %s at %L of type LOCK_TYPE must have a "
+               "codimension or be a subcomponent of a coarray, "
+               "which is not possible as the component has the "
+               "pointer attribute", c->name, &c->loc);
+  else if (pointer && !coarray && c->ts.type == BT_DERIVED
+           && c->ts.u.derived->attr.lock_comp)
+    gfc_error ("Pointer component %s at %L has a noncoarray subcomponent "
+               "of type LOCK_TYPE, which must have a codimension or be a "
+               "subcomponent of a coarray", c->name, &c->loc);
+
+  if (lock_type && allocatable && !coarray)
+    gfc_error ("Allocatable component %s at %L of type LOCK_TYPE must have "
+               "a codimension", c->name, &c->loc);
+  else if (lock_type && allocatable && c->ts.type == BT_DERIVED
+           && c->ts.u.derived->attr.lock_comp)
+    gfc_error ("Allocatable component %s at %L must have a codimension as "
+               "it has a noncoarray subcomponent of type LOCK_TYPE",
+               c->name, &c->loc);
+
+  if (sym->attr.coarray_comp && !coarray && lock_type)
+    gfc_error ("Noncoarray component %s at %L of type LOCK_TYPE or with "
+               "subcomponent of type LOCK_TYPE must have a codimension or "
+               "be a subcomponent of a coarray. (Variables of type %s may "
+               "not have a codimension as already a coarray "
+               "subcomponent exists)", c->name, &c->loc, sym->name);
+
+  if (sym->attr.lock_comp && coarray && !lock_type)
+    gfc_error ("Noncoarray component %s at %L of type LOCK_TYPE or with "
+               "subcomponent of type LOCK_TYPE must have a codimension or "
+               "be a subcomponent of a coarray. (Variables of type %s may "
+               "not have a codimension as %s at %L has a codimension or a "
+               "coarray subcomponent)", lock_comp->name, &lock_comp->loc,
+               sym->name, c->name, &c->loc);
+
+  /* Look for private components.  */
+  if (sym->component_access == ACCESS_PRIVATE
+      || c->attr.access == ACCESS_PRIVATE
+      || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.private_comp))
+    sym->attr.private_comp = 1;
+
+  if (lockp) *lockp = lock_comp;
+}
+
+static void parse_map (void);
+
+/* Parse a union component definition within a structure/derived-type 
+   definition. */
+
+static void
+parse_union (void)
+{
+    int compiling;
+    gfc_statement st;
+    gfc_state_data s;
+    gfc_component *c;
+    gfc_symbol *un;
+
+    accept_statement(ST_UNION);
+    push_state (&s, COMP_UNION, gfc_new_block);
+    un = gfc_new_block;
+
+    compiling = 1;
+
+    while (compiling)
+    {
+      st = next_statement ();
+      /* Only MAP declarations valid within a union. */
+      switch (st)
+        {
+        case ST_NONE:
+          unexpected_eof ();
+
+        case ST_MAP:
+          accept_statement (ST_MAP);
+          parse_map ();
+          /* Add a component to the union for each map. */
+          if (gfc_add_component (un, gfc_new_block->name, &c) == FAILURE)
+          {
+            gfc_internal_error ("failed to create map component '%s'", 
+                gfc_new_block->name);
+            reject_statement ();
+            return;
+          }
+          c->ts.type = BT_DERIVED;
+          c->ts.u.derived = gfc_new_block;
+          break;
+
+        case ST_END_UNION:
+          compiling = 0;
+          accept_statement (ST_END_UNION);
+          break;
+
+        default:
+          gfc_error ("Unexpected statement at %C; only MAP blocks are valid in"
+                     " a UNION block");
+          reject_statement ();
+          break;
+        }
+    }
+
+    for (c = un->components; c; c = c->next)
+      check_component (c, un, NULL);
+
+    /* Add the union as a component in its parent structure. */
+    pop_state ();
+    if (gfc_add_component (gfc_current_block (), un->name, &c) == FAILURE)
+    {
+      gfc_internal_error ("failed to create union component '%s'", un->name);
+      reject_statement ();
+      return;
+    }
+    c->ts.type = BT_UNION;
+    c->ts.u.derived = un;
+
+    un->attr.zero_comp = un->components == NULL;
+}
+
+/* Parse a structure definition. */
+
+static void
+parse_structure (void)
+{ 
+    int compiling_type;
+    gfc_statement st;
+    gfc_state_data s;
+    gfc_symbol *sym;
+    gfc_component *c;
+
+    accept_statement(ST_STRUCTURE_DECL);
+    push_state (&s, COMP_STRUCTURE, gfc_new_block);
+
+    gfc_new_block->component_access = ACCESS_PUBLIC;
+    compiling_type = 1;
+
+    while (compiling_type)
+    {
+      st = next_statement ();
+      switch (st)
+        {
+        case ST_NONE:
+          unexpected_eof ();
+          break;
+
+        /* Nested structure declarations should be captured as ST_DATA_DECL. */
+        case ST_STRUCTURE_DECL:
+          /* Let a more specific error take over. */
+          if (gfc_error_check () == 0)
+            gfc_error ("Syntax error in nested structure declaration at %C");
+          reject_statement ();
+          /* Skip the rest of this statement. */
+          gfc_error_recovery ();
+          break;
+
+        case ST_UNION:
+          accept_statement (ST_UNION);
+          parse_union ();
+          break;
+
+        case ST_DATA_DECL:
+          accept_statement (ST_DATA_DECL);
+          /* The data declaration was a nested/ad-hoc STRUCTURE field */
+          if (gfc_new_block && gfc_new_block != gfc_current_block ()
+                            && gfc_new_block->attr.flavor == FL_STRUCT)
+              parse_structure ();
+          break;
+
+        case ST_END_STRUCTURE:
+          compiling_type = 0;
+          accept_statement (ST_END_STRUCTURE);
+          break;
+
+        default:
+          unexpected_statement (st);
+          break;
+        }
+    }
+
+    /* need to verify that all fields of the derived type are
+    * interoperable with C if the type is declared to be bind(c)
+    */
+    sym = gfc_current_block ();
+    for (c = sym->components; c; c = c->next)
+      check_component (c, sym, NULL);
+
+    sym->attr.zero_comp = sym->components == NULL;
+
+    pop_state ();
+
+}
+
+/* Parse a map definition within a union. Similar to a structure definition
+   itself. */
+
+static void
+parse_map (void)
+{
+    int compiling_type;
+    gfc_statement st;
+    gfc_state_data s;
+    gfc_symbol *sym;
+    gfc_component *c;
+
+    accept_statement(ST_MAP);
+    push_state (&s, COMP_MAP, gfc_new_block);
+
+    gfc_new_block->component_access = ACCESS_PUBLIC;
+    compiling_type = 1;
+
+    while (compiling_type)
+    {
+      st = next_statement ();
+      switch (st)
+        {
+        case ST_NONE:
+          unexpected_eof ();
+
+        /* Nested structure declarations should be captured as ST_DATA_DECL. */
+        case ST_STRUCTURE_DECL:
+          /* Let a more specific error make it to decode_statement(). */
+          if (gfc_error_check () == 0)
+            gfc_error ("Syntax error in nested structure declaration at %C");
+          reject_statement ();
+          /* Skip the rest of this statement. */
+          gfc_error_recovery ();
+          break;
+
+        case ST_UNION:
+          accept_statement (ST_UNION);
+          parse_union ();
+          break;
+
+        case ST_DATA_DECL:
+          accept_statement (ST_DATA_DECL);
+          /* The data declaration was a nested/ad-hoc STRUCTURE field */
+          if (gfc_new_block && gfc_new_block != gfc_current_block ()
+                            && gfc_new_block->attr.flavor == FL_STRUCT)
+              parse_structure ();
+          break;
+
+        case ST_END_MAP:
+          compiling_type = 0;
+          accept_statement (ST_END_MAP);
+          break;
+
+        default:
+          unexpected_statement (st);
+          break;
+        }
+    }
+
+    /* need to verify that all fields of the derived type are
+    * interoperable with C if the type is declared to be bind(c)
+    */
+    sym = gfc_current_block ();
+    for (c = sym->components; c; c = c->next)
+      check_component (c, sym, NULL);
+
+    sym->attr.zero_comp = sym->components == NULL;
+
+    /* So parse_union can add this structure to its list of maps */
+    gfc_new_block = gfc_current_block ();
+
+    pop_state ();
+}
 
 /* Parse a derived type.  */
 
@@ -2190,119 +2635,9 @@ endType:
    */
   sym = gfc_current_block ();
   for (c = sym->components; c; c = c->next)
-    {
-      bool coarray, lock_type, allocatable, pointer;
-      coarray = lock_type = allocatable = pointer = false;
-
-      /* Look for allocatable components.  */
-      if (c->attr.allocatable
-	  || (c->ts.type == BT_CLASS && c->attr.class_ok
-	      && CLASS_DATA (c)->attr.allocatable)
-	  || (c->ts.type == BT_DERIVED && !c->attr.pointer
-	      && c->ts.u.derived->attr.alloc_comp))
-	{
-	  allocatable = true;
-	  sym->attr.alloc_comp = 1;
-	}
+    check_component (c, sym, &lock_comp);
 
-      /* Look for pointer components.  */
-      if (c->attr.pointer
-	  || (c->ts.type == BT_CLASS && c->attr.class_ok
-	      && CLASS_DATA (c)->attr.class_pointer)
-	  || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.pointer_comp))
-	{
-	  pointer = true;
-	  sym->attr.pointer_comp = 1;
-	}
-
-      /* Look for procedure pointer components.  */
-      if (c->attr.proc_pointer
-	  || (c->ts.type == BT_DERIVED
-	      && c->ts.u.derived->attr.proc_pointer_comp))
-	sym->attr.proc_pointer_comp = 1;
-
-      /* Looking for coarray components.  */
-      if (c->attr.codimension
-	  || (c->ts.type == BT_CLASS && c->attr.class_ok
-	      && CLASS_DATA (c)->attr.codimension))
-	{
-	  coarray = true;
-	  sym->attr.coarray_comp = 1;
-	}
-     
-      if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.coarray_comp)
-	{
-	  coarray = true;
-	  if (!pointer && !allocatable)
-	    sym->attr.coarray_comp = 1;
-	}
-
-      /* Looking for lock_type components.  */
-      if ((c->ts.type == BT_DERIVED
-	      && c->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV
-	      && c->ts.u.derived->intmod_sym_id == ISOFORTRAN_LOCK_TYPE)
-	  || (c->ts.type == BT_CLASS && c->attr.class_ok
-	      && CLASS_DATA (c)->ts.u.derived->from_intmod
-		 == INTMOD_ISO_FORTRAN_ENV
-	      && CLASS_DATA (c)->ts.u.derived->intmod_sym_id
-		 == ISOFORTRAN_LOCK_TYPE)
-	  || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.lock_comp
-	      && !allocatable && !pointer))
-	{
-	  lock_type = 1;
-	  lock_comp = c;
-	  sym->attr.lock_comp = 1;
-	}
-
-      /* Check for F2008, C1302 - and recall that pointers may not be coarrays
-	 (5.3.14) and that subobjects of coarray are coarray themselves (2.4.7),
-	 unless there are nondirect [allocatable or pointer] components
-	 involved (cf. 1.3.33.1 and 1.3.33.3).  */
-
-      if (pointer && !coarray && lock_type)
-	gfc_error ("Component %s at %L of type LOCK_TYPE must have a "
-		   "codimension or be a subcomponent of a coarray, "
-		   "which is not possible as the component has the "
-		   "pointer attribute", c->name, &c->loc);
-      else if (pointer && !coarray && c->ts.type == BT_DERIVED
-	       && c->ts.u.derived->attr.lock_comp)
-	gfc_error ("Pointer component %s at %L has a noncoarray subcomponent "
-		   "of type LOCK_TYPE, which must have a codimension or be a "
-		   "subcomponent of a coarray", c->name, &c->loc);
-
-      if (lock_type && allocatable && !coarray)
-	gfc_error ("Allocatable component %s at %L of type LOCK_TYPE must have "
-		   "a codimension", c->name, &c->loc);
-      else if (lock_type && allocatable && c->ts.type == BT_DERIVED
-	       && c->ts.u.derived->attr.lock_comp)
-	gfc_error ("Allocatable component %s at %L must have a codimension as "
-		   "it has a noncoarray subcomponent of type LOCK_TYPE",
-		   c->name, &c->loc);
-
-      if (sym->attr.coarray_comp && !coarray && lock_type)
-	gfc_error ("Noncoarray component %s at %L of type LOCK_TYPE or with "
-		   "subcomponent of type LOCK_TYPE must have a codimension or "
-		   "be a subcomponent of a coarray. (Variables of type %s may "
-		   "not have a codimension as already a coarray "
-		   "subcomponent exists)", c->name, &c->loc, sym->name);
-
-      if (sym->attr.lock_comp && coarray && !lock_type)
-	gfc_error ("Noncoarray component %s at %L of type LOCK_TYPE or with "
-		   "subcomponent of type LOCK_TYPE must have a codimension or "
-		   "be a subcomponent of a coarray. (Variables of type %s may "
-		   "not have a codimension as %s at %L has a codimension or a "
-		   "coarray subcomponent)", lock_comp->name, &lock_comp->loc,
-		   sym->name, c->name, &c->loc);
-
-      /* Look for private components.  */
-      if (sym->component_access == ACCESS_PRIVATE
-	  || c->attr.access == ACCESS_PRIVATE
-	  || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.private_comp))
-	sym->attr.private_comp = 1;
-    }
-
-  if (!seen_component)
-    sym->attr.zero_comp = 1;
+  sym->attr.zero_comp = !seen_component;
 
   pop_state ();
 }
@@ -2685,6 +3020,7 @@ loop:
     case ST_PARAMETER:
     case ST_PUBLIC:
     case ST_PRIVATE:
+    case ST_STRUCTURE_DECL:
     case ST_DERIVED_DECL:
     case_decl:
 declSt:
@@ -2701,6 +3037,10 @@ declSt:
 	  parse_interface ();
 	  break;
 
+        case ST_STRUCTURE_DECL:
+          parse_structure ();
+          break;
+
 	case ST_DERIVED_DECL:
 	  parse_derived ();
 	  break;
@@ -3938,9 +4278,9 @@ gfc_fixup_sibling_symbols (gfc_symbol *sym, gfc_namespace *siblings)
       if (!st || (st->n.sym->attr.dummy && ns == st->n.sym->ns))
 	goto fixup_contained;
 
-      if ((st->n.sym->attr.flavor == FL_DERIVED
+      if ((gfc_fl_struct (st->n.sym->attr.flavor)
 	   && sym->attr.generic && sym->attr.function)
-	  ||(sym->attr.flavor == FL_DERIVED
+	  ||(gfc_fl_struct (sym->attr.flavor)
 	     && st->n.sym->attr.generic && st->n.sym->attr.function))
 	goto fixup_contained;
 
diff --git a/gcc/fortran/parse.h b/gcc/fortran/parse.h
index dbe3c49ad6b..a8c9cf9625f 100644
--- a/gcc/fortran/parse.h
+++ b/gcc/fortran/parse.h
@@ -27,6 +27,7 @@ typedef enum
 {
   COMP_NONE, COMP_PROGRAM, COMP_MODULE, COMP_SUBROUTINE, COMP_FUNCTION,
   COMP_BLOCK_DATA, COMP_INTERFACE, COMP_DERIVED, COMP_DERIVED_CONTAINS,
+  COMP_STRUCTURE, COMP_UNION, COMP_MAP,
   COMP_BLOCK, COMP_ASSOCIATE, COMP_IF,
   COMP_DO, COMP_SELECT, COMP_FORALL, COMP_WHERE, COMP_CONTAINS, COMP_ENUM,
   COMP_SELECT_TYPE, COMP_OMP_STRUCTURED_BLOCK, COMP_CRITICAL, COMP_DO_CONCURRENT
@@ -59,10 +60,15 @@ extern gfc_state_data *gfc_state_stack;
 #define gfc_current_block() (gfc_state_stack->sym)
 #define gfc_current_state() (gfc_state_stack->state)
 
+/* STRUCTURE and TYPE are treated similarly, so these are common checks. */
+#define gfc_comp_is_derived(s) \
+    (((s) == COMP_DERIVED) || ((s) == COMP_STRUCTURE) || ((s) == COMP_MAP))
+
 int gfc_check_do_variable (gfc_symtree *);
 gfc_try gfc_find_state (gfc_compile_state);
 gfc_state_data *gfc_enclosing_unit (gfc_compile_state *);
 const char *gfc_ascii_statement (gfc_statement);
+const char *gfc_ascii_comp_state (gfc_compile_state);
 match gfc_match_enum (void);
 match gfc_match_enumerator_def (void);
 void gfc_free_enum_history (void);
diff --git a/gcc/fortran/primary.c b/gcc/fortran/primary.c
index a94ae216dd5..8a3e4854525 100644
--- a/gcc/fortran/primary.c
+++ b/gcc/fortran/primary.c
@@ -107,116 +107,51 @@ get_kind (int *is_iso_c)
   return (m == MATCH_YES) ? kind : -1;
 }
 
-
-/* Given a character and a radix, see if the character is a valid
-   digit in that radix.  */
-
-int
-gfc_check_digit (char c, int radix)
-{
-  int r;
-
-  switch (radix)
-    {
-    case 2:
-      r = ('0' <= c && c <= '1');
-      break;
-
-    case 8:
-      r = ('0' <= c && c <= '7');
-      break;
-
-    case 10:
-      r = ('0' <= c && c <= '9');
-      break;
-
-    case 16:
-      r = ISXDIGIT (c);
-      break;
-
-    default:
-      gfc_internal_error ("gfc_check_digit(): bad radix");
-    }
-
-  return r;
-}
-
-
-/* Match the digit string part of an integer if signflag is not set,
-   the signed digit string part if signflag is set.  If the buffer 
-   is NULL, we just count characters for the resolution pass.  Returns 
-   the number of characters matched, -1 for no match.  */
-
-static int
-match_digits (int signflag, int radix, char *buffer)
-{
-  locus old_loc;
-  int length;
-  char c;
-
-  length = 0;
-  c = gfc_next_ascii_char ();
-
-  if (signflag && (c == '+' || c == '-'))
-    {
-      if (buffer != NULL)
-	*buffer++ = c;
-      gfc_gobble_whitespace ();
-      c = gfc_next_ascii_char ();
-      length++;
-    }
-
-  if (!gfc_check_digit (c, radix))
-    return -1;
-
-  length++;
-  if (buffer != NULL)
-    *buffer++ = c;
-
-  for (;;)
-    {
-      old_loc = gfc_current_locus;
-      c = gfc_next_ascii_char ();
-
-      if (!gfc_check_digit (c, radix))
-	break;
-
-      if (buffer != NULL)
-	*buffer++ = c;
-      length++;
-    }
-
-  gfc_current_locus = old_loc;
-
-  return length;
-}
-
-
 /* Match an integer (digit string and optional kind).  
    A sign will be accepted if signflag is set.  */
 
 static match
 match_integer_constant (gfc_expr **result, int signflag)
 {
+  int radix, sign;
   int length, kind, is_iso_c;
-  locus old_loc;
-  char *buffer;
+  locus old_loc, start_loc;
+  char *buffer, *matchbuf;
   gfc_expr *e;
+  match m;
+
+  sign = 0; /* Not present */
+  start_loc = gfc_current_locus;
 
-  old_loc = gfc_current_locus;
   gfc_gobble_whitespace ();
 
-  length = match_digits (signflag, 10, NULL);
+  if (signflag)
+      gfc_match_sign (&sign);
+
+  /* Get the length of the match first. */
+  old_loc = gfc_current_locus;
+  m = gfc_match_extended_integer (NULL, &radix, &length);
+
+  if (m != MATCH_YES)
+  {
+      gfc_current_locus = start_loc;
+      return m;
+  }
   gfc_current_locus = old_loc;
-  if (length == -1)
-    return MATCH_NO;
+
+  /* Reserve a space in buffer for '-' */
+  if (sign < 0)
+      ++length;
 
   buffer = (char *) alloca (length + 1);
   memset (buffer, '\0', length + 1);
 
-  gfc_gobble_whitespace ();
+  /* Match number after sign. */
+  matchbuf = buffer;
+  if (sign < 0)
+      matchbuf++[0] = '-';
 
-  match_digits (signflag, 10, buffer);
+  gcc_assert (gfc_match_extended_integer (matchbuf, NULL, NULL) == MATCH_YES);
 
   kind = get_kind (&is_iso_c);
   if (kind == -2)
@@ -233,7 +168,7 @@ match_integer_constant (gfc_expr **result, int signflag)
       return MATCH_ERROR;
     }
 
-  e = gfc_convert_integer (buffer, kind, 10, &gfc_current_locus);
+  e = gfc_convert_integer (buffer, kind, radix, &gfc_current_locus);
   e->ts.is_c_interop = is_iso_c;
 
   if (gfc_range_check (e) != ARITH_OK)
@@ -264,6 +199,18 @@ match_hollerith_constant (gfc_expr **result)
   old_loc = gfc_current_locus;
   gfc_gobble_whitespace ();
 
+  if (gfc_match_literal_int (NULL, 10, NULL) == MATCH_YES)
+  {
+    gfc_gobble_whitespace ();
+    if (gfc_peek_ascii_char () == '#' && gfc_option.flag_dec_extended_int)
+    {
+      /* This is actually an extended integer constant. */
+      gfc_current_locus = old_loc;
+      return MATCH_NO;
+    }
+  }
+  gfc_current_locus = old_loc;
+
   if (match_integer_constant (&e, 0) == MATCH_YES
       && gfc_match_char ('h') == MATCH_YES)
     {
@@ -349,6 +296,7 @@ match_boz_constant (gfc_expr **result)
   locus old_loc, start_loc;
   char *buffer, post, delim;
   gfc_expr *e;
+  match m;
 
   start_loc = old_loc = gfc_current_locus;
   gfc_gobble_whitespace ();
@@ -398,8 +346,14 @@ match_boz_constant (gfc_expr **result)
 
   old_loc = gfc_current_locus;
 
-  length = match_digits (0, radix, NULL);
-  if (length == -1)
+  length = -1;
+  m = gfc_match_literal_int (NULL, radix, &length);
+
+  /* Error set by gfc_match_literal_int */
+  if (m == MATCH_ERROR)
+      return MATCH_ERROR;
+
+  if (length == -1 || m == MATCH_NO)
     {
       gfc_error ("Empty set of digits in BOZ constant at %C");
       return MATCH_ERROR;
@@ -441,7 +395,7 @@ match_boz_constant (gfc_expr **result)
   buffer = (char *) alloca (length + 1);
   memset (buffer, '\0', length + 1);
 
-  match_digits (0, radix, buffer);
+  gfc_match_literal_int (buffer, radix, NULL);
   gfc_next_ascii_char ();    /* Eat delimiter.  */
   if (post == 1)
     gfc_next_ascii_char ();  /* Eat postfixed b, o, z, or x.  */
@@ -1822,11 +1776,12 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,
 		   bool ppc_arg)
 {
   char name[GFC_MAX_SYMBOL_LEN + 1];
-  gfc_ref *substring, *tail;
+  gfc_ref *substring, *tail, *tmp;
   gfc_component *component;
   gfc_symbol *sym = primary->symtree->n.sym;
   match m;
   bool unknown;
+  char sep;
 
   tail = NULL;
 
@@ -1907,25 +1862,30 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,
   if (equiv_flag)
     return MATCH_YES;
 
-  if (sym->ts.type == BT_UNKNOWN && gfc_peek_ascii_char () == '%'
+  sep = gfc_peek_ascii_char ();
+  m = gfc_match_member_sep (sym);
+  if(m == MATCH_ERROR)
+      return MATCH_ERROR;
+
+  if (sym->ts.type == BT_UNKNOWN && m == MATCH_YES
       && gfc_get_default_type (sym->name, sym->ns)->type == BT_DERIVED)
     gfc_set_default_type (sym, 0, sym->ns);
 
-  if (sym->ts.type == BT_UNKNOWN && gfc_match_char ('%') == MATCH_YES)
+  if (sym->ts.type == BT_UNKNOWN && m == MATCH_YES)
     {
       gfc_error ("Symbol '%s' at %C has no IMPLICIT type", sym->name);
       return MATCH_ERROR;
     }
   else if ((sym->ts.type != BT_DERIVED && sym->ts.type != BT_CLASS)
-	   && gfc_match_char ('%') == MATCH_YES)
+          && m == MATCH_YES)
     {
-      gfc_error ("Unexpected '%%' for nonderived-type variable '%s' at %C",
-		 sym->name);
+      gfc_error ("Unexpected '%c' for nonderived-type variable "
+                 "'%s' at %C", sep, sym->name);
       return MATCH_ERROR;
     }
 
   if ((sym->ts.type != BT_DERIVED && sym->ts.type != BT_CLASS)
-      || gfc_match_char ('%') != MATCH_YES)
+      || m != MATCH_YES)
     goto check_substring;
 
   sym = sym->ts.u.derived;
@@ -1994,15 +1954,20 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,
 	  break;
 	}
 
-      component = gfc_find_component (sym, name, false, false);
+      component = gfc_find_component (sym, name, false, false, &tmp);
       if (component == NULL)
-	return MATCH_ERROR;
+        return MATCH_ERROR;
 
-      tail = extend_ref (primary, tail);
-      tail->type = REF_COMPONENT;
+      /* Extend the reference chain through the determined ref. */
+      if (primary->ref == NULL)
+        primary->ref = tmp;
+      else
+        tail->next = tmp;
 
-      tail->u.c.component = component;
-      tail->u.c.sym = sym;
+      /* The reference chain may be longer than one hop for union
+         subcomponents; find the new tail. */
+      for (tail = tmp; tail->next; tail = tail->next)
+        ;
 
       primary->ts = component->ts;
 
@@ -2053,7 +2018,7 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,
 	}
 
       if ((component->ts.type != BT_DERIVED && component->ts.type != BT_CLASS)
-	  || gfc_match_char ('%') != MATCH_YES)
+	  || gfc_match_member_sep (component->ts.u.derived) != MATCH_YES)
 	break;
 
       sym = component->ts.u.derived;
@@ -2061,7 +2026,7 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,
 
 check_substring:
   unknown = false;
-  if (primary->ts.type == BT_UNKNOWN && sym->attr.flavor != FL_DERIVED)
+  if (primary->ts.type == BT_UNKNOWN && !gfc_fl_struct (sym->attr.flavor))
     {
       if (gfc_get_default_type (sym->name, sym->ns)->type == BT_CHARACTER)
        {
@@ -2463,11 +2428,11 @@ gfc_convert_to_structure_constructor (gfc_expr *e, gfc_symbol *sym, gfc_expr **c
       /* Find the current component in the structure definition and check
 	     its access is not private.  */
       if (comp)
-	this_comp = gfc_find_component (sym, comp->name, false, false);
+	this_comp = gfc_find_component (sym, comp->name, false, false, NULL);
       else
 	{
 	  this_comp = gfc_find_component (sym, (const char *)comp_tail->name,
-					  false, false);
+					  false, false, NULL);
 	  comp = NULL; /* Reset needed!  */
 	}
 
@@ -2511,7 +2476,7 @@ gfc_convert_to_structure_constructor (gfc_expr *e, gfc_symbol *sym, gfc_expr **c
           if (comp && comp == sym->components
                 && sym->attr.extension
 		&& comp_tail->val
-                && (comp_tail->val->ts.type != BT_DERIVED
+                && (!gfc_bt_struct (comp_tail->val->ts.type)
                       ||
                     comp_tail->val->ts.u.derived != this_comp->ts.u.derived))
             {
@@ -2612,7 +2577,7 @@ gfc_match_structure_constructor (gfc_symbol *sym, gfc_expr **result)
   e->symtree = symtree;
   e->expr_type = EXPR_FUNCTION;
 
-  gcc_assert (sym->attr.flavor == FL_DERIVED
+  gcc_assert (gfc_fl_struct (sym->attr.flavor)
 	      && symtree->n.sym->attr.flavor == FL_PROCEDURE);
   e->value.function.esym = sym;
   e->symtree->n.sym->attr.generic = 1;
@@ -2701,18 +2666,43 @@ gfc_match_rvalue (gfc_expr **result)
   bool implicit_char;
   gfc_ref *ref;
 
-  m = gfc_match_name (name);
-  if (m != MATCH_YES)
-    return m;
+  m = MATCH_NO;
+  if (gfc_option.flag_loc_rval)
+  {
+    /* Let %LOC() act as a valid rvalue; treat it like GFC_ISYM_LOC */
+    m = gfc_match ("%%loc");
+    if (m == MATCH_YES)
+        strcpy (name, "loc");
+  }
 
-  if (gfc_find_state (COMP_INTERFACE) == SUCCESS
-      && !gfc_current_ns->has_import_set)
-    i = gfc_get_sym_tree (name, NULL, &symtree, false);
-  else
-    i = gfc_get_ha_sym_tree (name, &symtree);
+  if (m != MATCH_YES)
+  {
+      m = gfc_match_name (name);
+      if (m != MATCH_YES)
+        return m;
+  }
 
+  /* Check if the symbol exists first */
+  i = gfc_find_sym_tree (name, NULL, 1, &symtree);
   if (i)
     return MATCH_ERROR;
+  /* If not, we do not create it if there is a corresponding structure decl */
+  if (!symtree)
+  {
+    i = gfc_find_sym_tree (gfc_dt_upper_string (name), NULL, 1, &symtree);
+    if (i)
+      return MATCH_ERROR;
+  }
+  if (!symtree || symtree->n.sym->attr.flavor != FL_STRUCT)
+  {
+    if (gfc_find_state (COMP_INTERFACE) == SUCCESS
+        && !gfc_current_ns->has_import_set)
+      i = gfc_get_sym_tree (name, NULL, &symtree, false);
+    else
+      i = gfc_get_ha_sym_tree (name, &symtree);
+    if (i)
+      return MATCH_ERROR;
+  }
 
   sym = symtree->n.sym;
   e = NULL;
@@ -2824,6 +2814,7 @@ gfc_match_rvalue (gfc_expr **result)
 
       break;
 
+    case FL_STRUCT:
     case FL_DERIVED:
       sym = gfc_use_derived (sym);
       if (sym == NULL)
@@ -2964,10 +2955,12 @@ gfc_match_rvalue (gfc_expr **result)
 	 via an IMPLICIT statement.  This can't wait for the
 	 resolution phase.  */
 
-      if (gfc_peek_ascii_char () == '%'
+      old_loc = gfc_current_locus;
+      if (gfc_match_member_sep (sym) == MATCH_YES
 	  && sym->ts.type == BT_UNKNOWN
 	  && gfc_get_default_type (sym->name, sym->ns)->type == BT_DERIVED)
 	gfc_set_default_type (sym, 0, sym->ns);
+      gfc_current_locus = old_loc;
 
       /* If the symbol has a (co)dimension attribute, the expression is a
 	 variable.  */
@@ -3123,13 +3116,17 @@ gfc_match_rvalue (gfc_expr **result)
       break;
 
     generic_function:
-      gfc_get_sym_tree (name, NULL, &symtree, false);	/* Can't fail */
+      gfc_find_sym_tree (name, NULL, 1, &symtree);
+      if (!symtree)
+        gfc_find_sym_tree (gfc_dt_upper_string (name), NULL, 1, &symtree);
+      if (!symtree || symtree->n.sym->attr.flavor != FL_STRUCT)
+        gfc_get_sym_tree (name, NULL, &symtree, false); /* Can't fail */
 
       e = gfc_get_expr ();
       e->symtree = symtree;
       e->expr_type = EXPR_FUNCTION;
 
-      if (sym->attr.flavor == FL_DERIVED)
+      if (gfc_fl_struct (sym->attr.flavor))
 	{
 	  e->value.function.esym = sym;
 	  e->symtree->n.sym->attr.generic = 1;
@@ -3169,10 +3166,10 @@ gfc_match_rvalue (gfc_expr **result)
 static match
 match_variable (gfc_expr **result, int equiv_flag, int host_flag)
 {
-  gfc_symbol *sym;
+  gfc_symbol *sym, *dt_sym;
   gfc_symtree *st;
   gfc_expr *expr;
-  locus where;
+  locus where, old_loc;
   match m;
 
   /* Since nothing has any business being an lvalue in a module
@@ -3202,6 +3199,17 @@ match_variable (gfc_expr **result, int equiv_flag, int host_flag)
   sym->attr.implied_index = 0;
 
   gfc_set_sym_referenced (sym);
+
+  /* Check for generic symbols representing derived or structure types. */
+  if (sym->attr.flavor == FL_PROCEDURE && sym->generic
+      && (dt_sym = gfc_find_dt_in_generic (sym)))
+  {
+    if (dt_sym->attr.flavor == FL_DERIVED)
+      gfc_error ("Derived type '%s' cannot be used as a variable at %C",
+                 sym->name);
+    return MATCH_ERROR;
+  }
+
   switch (sym->attr.flavor)
     {
     case FL_VARIABLE:
@@ -3288,10 +3296,12 @@ match_variable (gfc_expr **result, int equiv_flag, int host_flag)
       else
 	implicit_ns = sym->ns;
 	
-      if (gfc_peek_ascii_char () == '%'
+      old_loc = gfc_current_locus;
+      if (gfc_match_member_sep (sym) == MATCH_YES
 	  && sym->ts.type == BT_UNKNOWN
 	  && gfc_get_default_type (sym->name, implicit_ns)->type == BT_DERIVED)
 	gfc_set_default_type (sym, 0, implicit_ns);
+      gfc_current_locus = old_loc;
     }
 
   expr = gfc_get_expr ();
diff --git a/gcc/fortran/resolve.c b/gcc/fortran/resolve.c
index c16e3d0b0a0..abf65c5caf2 100644
--- a/gcc/fortran/resolve.c
+++ b/gcc/fortran/resolve.c
@@ -520,7 +520,7 @@ static void
 find_arglists (gfc_symbol *sym)
 {
   if (sym->attr.if_source == IFSRC_UNKNOWN || sym->ns != gfc_current_ns
-      || sym->attr.flavor == FL_DERIVED)
+      || gfc_fl_struct (sym->attr.flavor))
     return;
 
   resolve_formal_arglist (sym);
@@ -933,9 +933,9 @@ resolve_common_vars (gfc_symbol *sym, bool named_common)
 		       "has an ultimate component that is "
 		       "allocatable", csym->name, &csym->declared_at);
       if (gfc_has_default_initializer (csym->ts.u.derived))
-	gfc_error_now ("Derived type variable '%s' in COMMON at %L "
-		       "may not have default initializer", csym->name,
-		       &csym->declared_at);
+        gfc_error_now ("Derived type variable '%s' in COMMON at %L "
+                       "may not have default initializer", csym->name,
+                       &csym->declared_at);
 
       if (csym->attr.flavor == FL_UNKNOWN && !csym->attr.proc_pointer)
 	gfc_add_flavor (&csym->attr, FL_VARIABLE, csym->name, &csym->declared_at);
@@ -1017,7 +1017,7 @@ resolve_contained_functions (gfc_namespace *ns)
 
 
 static gfc_try resolve_fl_derived0 (gfc_symbol *sym);
-
+static gfc_try resolve_fl_union (gfc_symbol *sym);
 
 /* Resolve all of the elements of a structure constructor and make sure that
    the types are correct. The 'init' flag indicates that the given
@@ -1035,6 +1035,8 @@ resolve_structure_cons (gfc_expr *expr, int init)
 
   if (expr->ts.type == BT_DERIVED)
     resolve_fl_derived0 (expr->ts.u.derived);
+  else if (expr->ts.type == BT_UNION)
+    resolve_fl_union (expr->ts.u.derived);
 
   cons = gfc_constructor_first (expr->value.constructor);
 
@@ -1055,6 +1057,10 @@ resolve_structure_cons (gfc_expr *expr, int init)
       && cons->expr && cons->expr->expr_type == EXPR_NULL)
     return SUCCESS;
 
+  /* Union constructors only have one constructor. */
+  if (expr->ts.type == BT_UNION)
+    return SUCCESS;
+
   /* A constructor may have references if it is the result of substituting a
      parameter variable.  In this case we just pull out the component we
      want.  */
@@ -1477,7 +1483,7 @@ is_illegal_recursion (gfc_symbol* sym, gfc_namespace* context)
   gfc_namespace* real_context;
 
   if (sym->attr.flavor == FL_PROGRAM
-      || sym->attr.flavor == FL_DERIVED)
+      || gfc_fl_struct (sym->attr.flavor))
     return false;
 
   gcc_assert (sym->attr.flavor == FL_PROCEDURE);
@@ -2446,7 +2452,7 @@ resolve_generic_f (gfc_expr *expr)
 generic:
       if (!intr)
 	for (intr = sym->generic; intr; intr = intr->next)
-	  if (intr->sym->attr.flavor == FL_DERIVED)
+	  if (gfc_fl_struct (intr->sym->attr.flavor))
 	    break;
 
       if (sym->ns->parent == NULL)
@@ -3889,6 +3895,86 @@ compare_shapes (gfc_expr *op1, gfc_expr *op2)
   return t;
 }
 
+/* Convert a logical operator to the corresponding bitwise intrinsic function
+   call; i.e. A .AND. B becomes IAND(A, B). */
+static gfc_expr *
+logical_to_bitwise (gfc_expr *e)
+{
+  gfc_expr *tmp, *op1, *op2;
+  gfc_isym_id isym;
+  gfc_actual_arglist *args = NULL;
+
+  gcc_assert (e->expr_type = EXPR_OP);
+
+  isym = GFC_ISYM_NONE;
+  op1 = e->value.op.op1;
+  op2 = e->value.op.op2;
+
+  switch (e->value.op.op)
+  {
+    case INTRINSIC_NOT:
+      isym = GFC_ISYM_NOT;
+      break;
+    case INTRINSIC_AND:
+      isym = GFC_ISYM_IAND;
+      break;
+    case INTRINSIC_OR:
+      isym = GFC_ISYM_IOR;
+      break;
+    case INTRINSIC_NEQV:
+      isym = GFC_ISYM_IEOR;
+      break;
+    case INTRINSIC_EQV:
+      /* Bitwise "eqv" is actually the complement of XOR. 
+         Change the old expression to NEQV === XOR and wrap it in NOT. */
+      tmp = gfc_copy_expr (e);
+      tmp->value.op.op = INTRINSIC_NEQV;
+      tmp = logical_to_bitwise (tmp);
+      isym = GFC_ISYM_NOT;
+      op1 = tmp;
+      op2 = NULL;
+      break;
+    default:
+      gfc_internal_error ("logical_to_bitwise(): Bad intrinsic");
+  }
+
+  /* Inherit the original operation's operands as arguments. */
+  args = gfc_get_actual_arglist ();
+  args->expr = op1;
+  if (op2)
+  {
+    args->next = gfc_get_actual_arglist ();
+    args->next->expr = op2;
+  }
+
+  /* Convert the expression to a function call. */
+  e->expr_type = EXPR_FUNCTION;
+  /* ? mpz_init_set_ui (e->shape, 0) ? */
+  e->value.function.actual = args;
+  e->value.function.isym = gfc_intrinsic_function_by_id(isym);
+  e->value.function.name = e->value.function.isym->name;
+  e->value.function.esym = NULL;
+  if (!e->symtree || !e->symtree->n.sym)
+    {
+      gfc_symbol *sym;
+      gfc_get_ha_sym_tree (e->value.function.isym->name, &e->symtree);
+      sym = e->symtree->n.sym;
+      sym->result = sym;
+      sym->attr.flavor = FL_PROCEDURE;
+      sym->attr.function = 1;
+      sym->attr.elemental = 1;
+      sym->attr.pure = 1;
+      sym->attr.referenced = 1;
+      gfc_intrinsic_symbol (sym);
+      gfc_commit_symbol (sym);
+    }
+
+  args->name = e->value.function.isym->formal->name;
+  if (e->value.function.isym->formal->next)
+    args->next->name = e->value.function.isym->formal->next->name;
+
+  return e;
+}
 
 /* Resolve an operator expression node.  This can involve replacing the
    operation with a user defined function call.  */
@@ -3995,6 +4081,20 @@ resolve_operator (gfc_expr *e)
 	  break;
 	}
 
+      /* -fdec-bitwise-ops: Logical ops on integers become bitwise ops */
+      else if (gfc_option.flag_dec_bitwise_ops
+          && (op1->ts.type == BT_INTEGER || op2->ts.type == BT_INTEGER))
+        {
+          e->ts.type = BT_INTEGER;
+          e->ts.kind = gfc_kind_max (op1, op2);
+          if (op1->ts.type == BT_LOGICAL)
+              gfc_convert_type (op1, &e->ts, 1);
+          if (op2->ts.type == BT_LOGICAL)
+              gfc_convert_type (op2, &e->ts, 1);
+          e = logical_to_bitwise (e);
+          return resolve_function (e);
+        }
+
       sprintf (msg, _("Operands of logical operator '%s' at %%L are %s/%s"),
 	       gfc_op2string (e->value.op.op), gfc_typename (&op1->ts),
 	       gfc_typename (&op2->ts));
@@ -4002,6 +4102,15 @@ resolve_operator (gfc_expr *e)
       goto bad_op;
 
     case INTRINSIC_NOT:
+      /* Logical ops on integers become bitwise ops with -fdec-bitwise-ops */
+      if (gfc_option.flag_dec_bitwise_ops && op1->ts.type == BT_INTEGER)
+        {
+          e->ts.type = BT_INTEGER;
+          e->ts.kind = op1->ts.kind;
+          e = logical_to_bitwise (e);
+          return resolve_function (e);
+        }
+
       if (op1->ts.type == BT_LOGICAL)
 	{
 	  e->ts.type = BT_LOGICAL;
@@ -4041,7 +4150,10 @@ resolve_operator (gfc_expr *e)
 	  break;
 	}
 
-      if (gfc_numeric_ts (&op1->ts) && gfc_numeric_ts (&op2->ts))
+      if ((gfc_numeric_ts (&op1->ts) && gfc_numeric_ts (&op2->ts))
+        || (gfc_option.flag_lazy_logicals
+            && (   (op1->ts.type == BT_LOGICAL || op1->ts.type == BT_INTEGER)
+                && (op2->ts.type == BT_LOGICAL || op2->ts.type == BT_INTEGER))))
 	{
 	  gfc_type_convert_binary (e, 1);
 
@@ -5455,14 +5567,14 @@ resolve_procedure:
 	{
 	  gfc_component *c;
 	  c = ref2 ? ref2->u.c.component : e->symtree->n.sym->components;
-	  for ( ; c; c = c->next)
-	    if (c->attr.allocatable && c->ts.type == BT_CLASS)
-	      {
-		gfc_error ("Coindexed object with polymorphic allocatable "
-			 "subcomponent at %L", &e->where);
-		t = FAILURE;
-		break;
-	      }
+          for ( ; c; c = c->next)
+            if (c->attr.allocatable && c->ts.type == BT_CLASS)
+              {
+                gfc_error ("Coindexed object with polymorphic allocatable "
+                           "subcomponent at %L", &e->where);
+                t = FAILURE;
+                break;
+              }
 	}
     }
 
@@ -5935,7 +6047,7 @@ get_declared_from_expr (gfc_ref **class_ref, gfc_ref **new_ref,
 	continue;
 
       if ((ref->u.c.component->ts.type == BT_CLASS
-	     || (check_types && ref->u.c.component->ts.type == BT_DERIVED))
+	     || (check_types && gfc_bt_struct (ref->u.c.component->ts.type)))
 	  && ref->u.c.component->attr.flavor != FL_PROCEDURE)
 	{
 	  declared = ref->u.c.component->ts.u.derived;
@@ -6196,7 +6308,7 @@ resolve_typebound_function (gfc_expr* e)
 	 is present.  */
       ts = expr->ts;
       declared = ts.u.derived;
-      c = gfc_find_component (declared, "_vptr", true, true);
+      c = gfc_find_component (declared, "_vptr", true, true, NULL);
       if (c->ts.u.derived == NULL)
 	c->ts.u.derived = gfc_find_derived_vtab (declared);
 
@@ -6240,14 +6352,14 @@ resolve_typebound_function (gfc_expr* e)
   declared = get_declared_from_expr (&class_ref, &new_ref, e, true);
 
   /* Weed out cases of the ultimate component being a derived type.  */
-  if ((class_ref && class_ref->u.c.component->ts.type == BT_DERIVED)
+  if ((class_ref && gfc_bt_struct (class_ref->u.c.component->ts.type))
 	 || (!class_ref && st->n.sym->ts.type != BT_CLASS))
     {
       gfc_free_ref_list (new_ref);
       return resolve_compcall (e, NULL);
     }
 
-  c = gfc_find_component (declared, "_data", true, true);
+  c = gfc_find_component (declared, "_data", true, true, NULL);
   declared = c->ts.u.derived;
 
   /* Treat the call as if it is a typebound procedure, in order to roll
@@ -6324,7 +6436,7 @@ resolve_typebound_subroutine (gfc_code *code)
 	 that any delays in resolution are corrected and that the vtab
 	 is present.  */
       declared = expr->ts.u.derived;
-      c = gfc_find_component (declared, "_vptr", true, true);
+      c = gfc_find_component (declared, "_vptr", true, true, NULL);
       if (c->ts.u.derived == NULL)
 	c->ts.u.derived = gfc_find_derived_vtab (declared);
 
@@ -6369,7 +6481,7 @@ resolve_typebound_subroutine (gfc_code *code)
   get_declared_from_expr (&class_ref, &new_ref, code->expr1, true);
 
   /* Weed out cases of the ultimate component being a derived type.  */
-  if ((class_ref && class_ref->u.c.component->ts.type == BT_DERIVED)
+  if ((class_ref && gfc_bt_struct (class_ref->u.c.component->ts.type))
 	 || (!class_ref && st->n.sym->ts.type != BT_CLASS))
     {
       gfc_free_ref_list (new_ref);
@@ -6861,8 +6973,8 @@ derived_inaccessible (gfc_symbol *sym)
 
   for (c = sym->components; c; c = c->next)
     {
-	if (c->ts.type == BT_DERIVED && derived_inaccessible (c->ts.u.derived))
-	  return 1;
+      if (c->ts.type == BT_DERIVED && derived_inaccessible (c->ts.u.derived))
+        return 1;
     }
 
   return 0;
@@ -7314,7 +7426,7 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)
 	 using _copy and trans_call. It is convenient to exploit that
 	 when the allocated type is different from the declared type but
 	 no SOURCE exists by setting expr3.  */
-      code->expr3 = gfc_default_initializer (&code->ext.alloc.ts);
+      code->expr3 = gfc_default_initializer (&code->ext.alloc.ts, false);
     }
   else if (!code->expr3)
     {
@@ -7322,7 +7434,7 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)
       gfc_typespec ts;
       gfc_expr *init_e;
 
-      if (code->ext.alloc.ts.type == BT_DERIVED)
+      if (gfc_bt_struct (code->ext.alloc.ts.type))
 	ts = code->ext.alloc.ts;
       else
 	ts = e->ts;
@@ -7330,7 +7442,8 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)
       if (ts.type == BT_CLASS)
 	ts = ts.u.derived->components->ts;
 
-      if (ts.type == BT_DERIVED && (init_e = gfc_default_initializer (&ts)))
+      if (gfc_bt_struct (ts.type) && (init_e = gfc_default_initializer (&ts,
+                                                                      false)))
 	{
 	  gfc_code *init_st = gfc_get_code ();
 	  init_st->loc = code->loc;
@@ -7344,7 +7457,7 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)
   else if (code->expr3->mold && code->expr3->ts.type == BT_DERIVED)
     {
       /* Default initialization via MOLD (non-polymorphic).  */
-      gfc_expr *rhs = gfc_default_initializer (&code->expr3->ts);
+      gfc_expr *rhs = gfc_default_initializer (&code->expr3->ts, false);
       gfc_resolve_expr (rhs);
       gfc_free_expr (code->expr3);
       code->expr3 = rhs;
@@ -7446,7 +7559,7 @@ check_symbols:
 	  sym = a->expr->symtree->n.sym;
 
 	  /* TODO - check derived type components.  */
-	  if (sym->ts.type == BT_DERIVED || sym->ts.type == BT_CLASS)
+	  if (gfc_bt_struct (sym->ts.type) || sym->ts.type == BT_CLASS)
 	    continue;
 
 	  if ((ar->start[i] != NULL
@@ -9391,7 +9504,9 @@ gfc_resolve_blocks (gfc_code *b, gfc_namespace *ns)
 	{
 	case EXEC_IF:
 	  if (t == SUCCESS && b->expr1 != NULL
-	      && (b->expr1->ts.type != BT_LOGICAL || b->expr1->rank != 0))
+	      && (b->expr1->ts.type != BT_LOGICAL || b->expr1->rank != 0)
+              && (!gfc_option.flag_lazy_logicals
+                  || b->expr1->ts.type != BT_INTEGER))
 	    gfc_error ("IF clause at %L requires a scalar LOGICAL expression",
 		       &b->expr1->where);
 	  break;
@@ -9803,7 +9918,7 @@ nonscalar_typebound_assign (gfc_symbol *derived, int depth)
 
   for (c= derived->components; c; c = c->next)
     {
-      if ((c->ts.type != BT_DERIVED
+      if ((!gfc_bt_struct (c->ts.type)
 	    || c->attr.pointer
 	    || c->attr.allocatable
 	    || c->attr.proc_pointer_comp
@@ -9877,9 +9992,172 @@ static int component_assignment_level = 0;
 static gfc_code *tmp_head = NULL, *tmp_tail = NULL;
 
 static void
+generate_derived_component_assignments (gfc_code **code, gfc_namespace *ns,
+    gfc_code **this_code, gfc_code **head, gfc_code **tail, gfc_expr **t1,
+    gfc_symbol *d1, gfc_symbol *d2)
+{
+  gfc_component *comp1, *comp2, *map1, *map2;
+
+  comp1 = d1->components;
+  comp2 = d2->components;
+
+  for (; comp1; comp1 = comp1->next, comp2 = comp2->next)
+  {
+    bool inout = false;
+
+    /* For unions, just recurse into the maps. */
+    if (comp1->ts.type == BT_UNION)
+    {
+      map1 = comp1->ts.u.derived->components;
+      map2 = comp2->ts.u.derived->components;
+      for (; map1; map1 = map1->next, map2 = map2->next)
+      {
+        generate_derived_component_assignments (code, ns,
+            this_code, head, tail, t1, map1->ts.u.derived, map2->ts.u.derived);
+      }
+      continue;
+    }
+
+    /* The intrinsic assignment does the right thing for pointers
+       of all kinds and allocatable components.  */
+    if (comp1->ts.type != BT_DERIVED
+        || comp1->attr.pointer
+        || comp1->attr.allocatable
+        || comp1->attr.proc_pointer_comp
+        || comp1->attr.class_pointer
+        || comp1->attr.proc_pointer)
+      continue;
+
+    /* Make an assigment for this component.  */
+    *this_code = build_assignment (EXEC_ASSIGN,
+                                  (*code)->expr1, (*code)->expr2,
+                                  comp1, comp2, (*code)->loc);
+
+    /* Convert the assignment if there is a defined assignment for
+       this type.  Otherwise, using the call from resolve_code,
+       recurse into its components.  */
+    resolve_code (*this_code, ns);
+
+    if ((*this_code)->op == EXEC_ASSIGN_CALL)
+      {
+        gfc_formal_arglist *dummy_args;
+        gfc_symbol *rsym;
+        /* Check that there is a typebound defined assignment.  If not,
+           then this must be a module defined assignment.  We cannot
+           use the defined_assign_comp attribute here because it must
+           be this derived type that has the defined assignment and not
+           a parent type.  */
+        if (!(comp1->ts.u.derived->f2k_derived
+              && comp1->ts.u.derived->f2k_derived
+                                      ->tb_op[INTRINSIC_ASSIGN]))
+          {
+            gfc_free_statements (*this_code);
+            *this_code = NULL;
+            continue;
+          }
+
+        /* If the first argument of the subroutine has intent INOUT
+           a temporary must be generated and used instead.  */
+        rsym = (*this_code)->resolved_sym;
+        dummy_args = gfc_sym_get_dummy_args (rsym);
+        if (dummy_args
+            && dummy_args->sym->attr.intent == INTENT_INOUT)
+          {
+            gfc_code *temp_code;
+            inout = true;
+
+            /* Build the temporary required for the assignment and put
+               it at the head of the generated code.  */
+            if (!*t1)
+              {
+                *t1 = get_temp_from_expr ((*code)->expr1, ns);
+                temp_code = build_assignment (EXEC_ASSIGN,
+                                              *t1, (*code)->expr1,
+                              NULL, NULL, (*code)->loc);
+
+                /* For allocatable LHS, check whether it is allocated.  Note
+                   that allocatable components with defined assignment are
+                   not yet support.  See PR 57696.  */
+                if ((*code)->expr1->symtree->n.sym->attr.allocatable)
+                  {
+                    gfc_code *block;
+                    gfc_expr *e =
+                      gfc_lval_expr_from_sym ((*code)->expr1->symtree->n.sym);
+                    block = gfc_get_code ();
+                    block->op = EXEC_IF;
+                    block->block = gfc_get_code ();
+                    block->block->op = EXEC_IF;
+                    block->block->expr1
+                        = gfc_build_intrinsic_call (ns,
+                                  GFC_ISYM_ALLOCATED, "allocated",
+                                  (*code)->loc, 1, e);
+                    block->block->next = temp_code;
+                    temp_code = block;
+                  }
+                add_code_to_chain (&temp_code, &tmp_head, &tmp_tail);
+              }
+
+            /* Replace the first actual arg with the component of the
+               temporary.  */
+            gfc_free_expr ((*this_code)->ext.actual->expr);
+            (*this_code)->ext.actual->expr = gfc_copy_expr (*t1);
+            add_comp_ref ((*this_code)->ext.actual->expr, comp1);
+
+            /* If the LHS variable is allocatable and wasn't allocated and
+               the temporary is allocatable, pointer assign the address of
+               the freshly allocated LHS to the temporary.  */
+            if ((*code)->expr1->symtree->n.sym->attr.allocatable
+                && gfc_expr_attr ((*code)->expr1).allocatable)
+              {
+                gfc_code *block;
+                gfc_expr *cond;
+
+                cond = gfc_get_expr ();
+                cond->ts.type = BT_LOGICAL;
+                cond->ts.kind = gfc_default_logical_kind;
+                cond->expr_type = EXPR_OP;
+                cond->where = (*code)->loc;
+                cond->value.op.op = INTRINSIC_NOT;
+                cond->value.op.op1 = gfc_build_intrinsic_call (ns,
+                                        GFC_ISYM_ALLOCATED, "allocated",
+                                        (*code)->loc, 1, gfc_copy_expr (*t1));
+                block = gfc_get_code ();
+                block->op = EXEC_IF;
+                block->block = gfc_get_code ();
+                block->block->op = EXEC_IF;
+                block->block->expr1 = cond;
+                block->block->next = build_assignment (EXEC_POINTER_ASSIGN,
+                                      *t1, (*code)->expr1,
+                                      NULL, NULL, (*code)->loc);
+                add_code_to_chain (&block, head, tail);
+              }
+          }
+      }
+    else if ((*this_code)->op == EXEC_ASSIGN && !(*this_code)->next)
+      {
+        /* Don't add intrinsic assignments since they are already
+           effected by the intrinsic assignment of the structure.  */
+        gfc_free_statements (*this_code);
+        (*this_code) = NULL;
+        continue;
+      }
+
+    add_code_to_chain (this_code, head, tail);
+
+    if (*t1 && inout)
+      {
+        /* Transfer the value to the final result.  */
+        *this_code = build_assignment (EXEC_ASSIGN,
+                                      (*code)->expr1, *t1,
+                                      comp1, comp2, (*code)->loc);
+        add_code_to_chain (this_code, head, tail);
+      }
+  }
+}
+
+static void
 generate_component_assignments (gfc_code **code, gfc_namespace *ns)
 {
-  gfc_component *comp1, *comp2;
   gfc_code *this_code = NULL, *head = NULL, *tail = NULL;
   gfc_expr *t1;
   int error_count, depth;
@@ -9933,149 +10211,11 @@ generate_component_assignments (gfc_code **code, gfc_namespace *ns)
       add_code_to_chain (&this_code, &head, &tail);
     }
 
-  comp1 = (*code)->expr1->ts.u.derived->components;
-  comp2 = (*code)->expr2->ts.u.derived->components;
-
   t1 = NULL;
-  for (; comp1; comp1 = comp1->next, comp2 = comp2->next)
-    {
-      bool inout = false;
-
-      /* The intrinsic assignment does the right thing for pointers
-	 of all kinds and allocatable components.  */
-      if (comp1->ts.type != BT_DERIVED
-	  || comp1->attr.pointer
-	  || comp1->attr.allocatable
-	  || comp1->attr.proc_pointer_comp
-	  || comp1->attr.class_pointer
-	  || comp1->attr.proc_pointer)
-	continue;
-
-      /* Make an assigment for this component.  */
-      this_code = build_assignment (EXEC_ASSIGN,
-				    (*code)->expr1, (*code)->expr2,
-				    comp1, comp2, (*code)->loc);
-
-      /* Convert the assignment if there is a defined assignment for
-	 this type.  Otherwise, using the call from resolve_code,
-	 recurse into its components.  */
-      resolve_code (this_code, ns);
-
-      if (this_code->op == EXEC_ASSIGN_CALL)
-	{
-	  gfc_formal_arglist *dummy_args;
-	  gfc_symbol *rsym;
-	  /* Check that there is a typebound defined assignment.  If not,
-	     then this must be a module defined assignment.  We cannot
-	     use the defined_assign_comp attribute here because it must
-	     be this derived type that has the defined assignment and not
-	     a parent type.  */
-	  if (!(comp1->ts.u.derived->f2k_derived
-		&& comp1->ts.u.derived->f2k_derived
-					->tb_op[INTRINSIC_ASSIGN]))
-	    {
-	      gfc_free_statements (this_code);
-	      this_code = NULL;
-	      continue;
-	    }
 
-	  /* If the first argument of the subroutine has intent INOUT
-	     a temporary must be generated and used instead.  */
-	  rsym = this_code->resolved_sym;
-	  dummy_args = gfc_sym_get_dummy_args (rsym);
-	  if (dummy_args
-	      && dummy_args->sym->attr.intent == INTENT_INOUT)
-	    {
-	      gfc_code *temp_code;
-	      inout = true;
-
-	      /* Build the temporary required for the assignment and put
-		 it at the head of the generated code.  */
-	      if (!t1)
-		{
-		  t1 = get_temp_from_expr ((*code)->expr1, ns);
-		  temp_code = build_assignment (EXEC_ASSIGN,
-						t1, (*code)->expr1,
-				NULL, NULL, (*code)->loc);
-
-		  /* For allocatable LHS, check whether it is allocated.  Note
-		     that allocatable components with defined assignment are
-		     not yet support.  See PR 57696.  */
-		  if ((*code)->expr1->symtree->n.sym->attr.allocatable)
-		    {
-		      gfc_code *block;
-		      gfc_expr *e =
-			gfc_lval_expr_from_sym ((*code)->expr1->symtree->n.sym);
-		      block = gfc_get_code ();
-		      block->op = EXEC_IF;
-		      block->block = gfc_get_code ();
-		      block->block->op = EXEC_IF;
-		      block->block->expr1
-			  = gfc_build_intrinsic_call (ns,
-				    GFC_ISYM_ALLOCATED, "allocated",
-				    (*code)->loc, 1, e);
-		      block->block->next = temp_code;
-		      temp_code = block;
-		    }
-		  add_code_to_chain (&temp_code, &tmp_head, &tmp_tail);
-		}
-
-	      /* Replace the first actual arg with the component of the
-		 temporary.  */
-	      gfc_free_expr (this_code->ext.actual->expr);
-	      this_code->ext.actual->expr = gfc_copy_expr (t1);
-	      add_comp_ref (this_code->ext.actual->expr, comp1);
-
-	      /* If the LHS variable is allocatable and wasn't allocated and
-                 the temporary is allocatable, pointer assign the address of
-                 the freshly allocated LHS to the temporary.  */
-	      if ((*code)->expr1->symtree->n.sym->attr.allocatable
-		  && gfc_expr_attr ((*code)->expr1).allocatable)
-		{
-		  gfc_code *block;
-		  gfc_expr *cond;
-
-		  cond = gfc_get_expr ();
-		  cond->ts.type = BT_LOGICAL;
-		  cond->ts.kind = gfc_default_logical_kind;
-		  cond->expr_type = EXPR_OP;
-		  cond->where = (*code)->loc;
-		  cond->value.op.op = INTRINSIC_NOT;
-		  cond->value.op.op1 = gfc_build_intrinsic_call (ns,
-					  GFC_ISYM_ALLOCATED, "allocated",
-					  (*code)->loc, 1, gfc_copy_expr (t1));
-		  block = gfc_get_code ();
-		  block->op = EXEC_IF;
-		  block->block = gfc_get_code ();
-		  block->block->op = EXEC_IF;
-		  block->block->expr1 = cond;
-		  block->block->next = build_assignment (EXEC_POINTER_ASSIGN,
-					t1, (*code)->expr1,
-					NULL, NULL, (*code)->loc);
-		  add_code_to_chain (&block, &head, &tail);
-		}
-	    }
-	}
-      else if (this_code->op == EXEC_ASSIGN && !this_code->next)
-	{
-	  /* Don't add intrinsic assignments since they are already
-	     effected by the intrinsic assignment of the structure.  */
-	  gfc_free_statements (this_code);
-	  this_code = NULL;
-	  continue;
-	}
-
-      add_code_to_chain (&this_code, &head, &tail);
-
-      if (t1 && inout)
-	{
-	  /* Transfer the value to the final result.  */
-	  this_code = build_assignment (EXEC_ASSIGN,
-					(*code)->expr1, t1,
-					comp1, comp2, (*code)->loc);
-	  add_code_to_chain (&this_code, &head, &tail);
-	}
-    }
+  generate_derived_component_assignments (code, ns,
+      &this_code, &head, &tail, &t1,
+      (*code)->expr1->ts.u.derived, (*code)->expr2->ts.u.derived);
 
   /* Put the temporary assignments at the top of the generated code.  */
   if (tmp_head && component_assignment_level == 1)
@@ -10350,7 +10490,9 @@ resolve_code (gfc_code *code, gfc_namespace *ns)
 	case EXEC_IF:
 	  if (t == SUCCESS && code->expr1 != NULL
 	      && (code->expr1->ts.type != BT_LOGICAL
-		  || code->expr1->rank != 0))
+		  || code->expr1->rank != 0)
+              && (!gfc_option.flag_lazy_logicals
+                  || code->expr1->ts.type != BT_INTEGER))
 	    gfc_error ("IF clause at %L requires a scalar LOGICAL expression",
 		       &code->expr1->where);
 	  break;
@@ -10647,7 +10789,7 @@ resolve_bind_c_comms (gfc_symtree *comm_block_tree)
 static void
 resolve_bind_c_derived_types (gfc_symbol *derived_sym)
 {
-  if (derived_sym != NULL && derived_sym->attr.flavor == FL_DERIVED
+  if (derived_sym != NULL && gfc_fl_struct (derived_sym->attr.flavor)
       && derived_sym->attr.is_bind_c == 1)
     verify_bind_c_derived_type (derived_sym);
 
@@ -10664,7 +10806,7 @@ gfc_verify_binding_labels (gfc_symbol *sym)
   int has_error = 0;
 
   if (sym != NULL && sym->attr.is_bind_c && sym->attr.is_iso_c == 0
-      && sym->attr.flavor != FL_DERIVED && sym->binding_label)
+      && !gfc_fl_struct (sym->attr.flavor) && sym->binding_label)
     {
       gfc_gsymbol *bind_c_sym;
 
@@ -10899,6 +11041,34 @@ build_init_assign (gfc_symbol *sym, gfc_expr *init)
   init_st->expr2 = init;
 }
 
+/* Whether or not we can create an initializer for the given symbol.  */
+
+static bool
+can_create_init (gfc_symbol *sym)
+{
+  symbol_attribute *a;
+  if (!sym)
+    return false;
+  a = &sym->attr;
+
+  /* These symbols should never have a default initialization.  */
+  return !(
+       a->allocatable
+    || a->external
+    || a->pointer
+    || a->in_equivalence
+    || a->in_common
+    || a->data
+    || sym->module
+    || a->cray_pointee
+    || a->cray_pointer
+    || sym->assoc
+    || (!a->referenced && !a->result)
+    || (a->dummy && a->intent != INTENT_OUT)
+    || (a->function && sym != sym->result)
+  );
+} 
+
 /* Assign the default initializer to a derived type variable or result.  */
 
 static void
@@ -10910,7 +11080,7 @@ apply_default_init (gfc_symbol *sym)
     return;
 
   if (sym->ts.type == BT_DERIVED && sym->ts.u.derived)
-    init = gfc_default_initializer (&sym->ts);
+    init = gfc_default_initializer (&sym->ts, can_create_init (sym));
 
   if (init == NULL && sym->ts.type != BT_CLASS)
     return;
@@ -10919,17 +11089,11 @@ apply_default_init (gfc_symbol *sym)
   sym->attr.referenced = 1;
 }
 
-/* Build an initializer for a local integer, real, complex, logical, or
-   character variable, based on the command line flags finit-local-zero,
-   finit-integer=, finit-real=, finit-logical=, and finit-runtime.  Returns
-   null if the symbol should not have a default initialization.  */
+/* Wrapper around gfc_build_default_init_expr that takes a symbol and
+   returns NULL if the symbol should not have a default initializer. */
 static gfc_expr *
 build_default_init_expr (gfc_symbol *sym)
 {
-  int char_len;
-  gfc_expr *init_expr;
-  int i;
-
   /* These symbols should never have a default initialization.  */
   if (sym->attr.allocatable
       || sym->attr.external
@@ -10944,145 +11108,8 @@ build_default_init_expr (gfc_symbol *sym)
       || sym->assoc)
     return NULL;
 
-  /* Now we'll try to build an initializer expression.  */
-  init_expr = gfc_get_constant_expr (sym->ts.type, sym->ts.kind,
-				     &sym->declared_at);
-
-  /* We will only initialize integers, reals, complex, logicals, and
-     characters, and only if the corresponding command-line flags
-     were set.  Otherwise, we free init_expr and return null.  */
-  switch (sym->ts.type)
-    {
-    case BT_INTEGER:
-      if (gfc_option.flag_init_integer != GFC_INIT_INTEGER_OFF)
-	mpz_set_si (init_expr->value.integer,
-			 gfc_option.flag_init_integer_value);
-      else
-	{
-	  gfc_free_expr (init_expr);
-	  init_expr = NULL;
-	}
-      break;
-
-    case BT_REAL:
-      switch (gfc_option.flag_init_real)
-	{
-	case GFC_INIT_REAL_SNAN:
-	  init_expr->is_snan = 1;
-	  /* Fall through.  */
-	case GFC_INIT_REAL_NAN:
-	  mpfr_set_nan (init_expr->value.real);
-	  break;
-
-	case GFC_INIT_REAL_INF:
-	  mpfr_set_inf (init_expr->value.real, 1);
-	  break;
-
-	case GFC_INIT_REAL_NEG_INF:
-	  mpfr_set_inf (init_expr->value.real, -1);
-	  break;
-
-	case GFC_INIT_REAL_ZERO:
-	  mpfr_set_ui (init_expr->value.real, 0.0, GFC_RND_MODE);
-	  break;
-
-	default:
-	  gfc_free_expr (init_expr);
-	  init_expr = NULL;
-	  break;
-	}
-      break;
-
-    case BT_COMPLEX:
-      switch (gfc_option.flag_init_real)
-	{
-	case GFC_INIT_REAL_SNAN:
-	  init_expr->is_snan = 1;
-	  /* Fall through.  */
-	case GFC_INIT_REAL_NAN:
-	  mpfr_set_nan (mpc_realref (init_expr->value.complex));
-	  mpfr_set_nan (mpc_imagref (init_expr->value.complex));
-	  break;
-
-	case GFC_INIT_REAL_INF:
-	  mpfr_set_inf (mpc_realref (init_expr->value.complex), 1);
-	  mpfr_set_inf (mpc_imagref (init_expr->value.complex), 1);
-	  break;
-
-	case GFC_INIT_REAL_NEG_INF:
-	  mpfr_set_inf (mpc_realref (init_expr->value.complex), -1);
-	  mpfr_set_inf (mpc_imagref (init_expr->value.complex), -1);
-	  break;
-
-	case GFC_INIT_REAL_ZERO:
-	  mpc_set_ui (init_expr->value.complex, 0, GFC_MPC_RND_MODE);
-	  break;
-
-	default:
-	  gfc_free_expr (init_expr);
-	  init_expr = NULL;
-	  break;
-	}
-      break;
-
-    case BT_LOGICAL:
-      if (gfc_option.flag_init_logical == GFC_INIT_LOGICAL_FALSE)
-	init_expr->value.logical = 0;
-      else if (gfc_option.flag_init_logical == GFC_INIT_LOGICAL_TRUE)
-	init_expr->value.logical = 1;
-      else
-	{
-	  gfc_free_expr (init_expr);
-	  init_expr = NULL;
-	}
-      break;
-
-    case BT_CHARACTER:
-      /* For characters, the length must be constant in order to
-	 create a default initializer.  */
-      if (gfc_option.flag_init_character == GFC_INIT_CHARACTER_ON
-	  && sym->ts.u.cl->length
-	  && sym->ts.u.cl->length->expr_type == EXPR_CONSTANT)
-	{
-	  char_len = mpz_get_si (sym->ts.u.cl->length->value.integer);
-	  init_expr->value.character.length = char_len;
-	  init_expr->value.character.string = gfc_get_wide_string (char_len+1);
-	  for (i = 0; i < char_len; i++)
-	    init_expr->value.character.string[i]
-	      = (unsigned char) gfc_option.flag_init_character_value;
-	}
-      else
-	{
-	  gfc_free_expr (init_expr);
-	  init_expr = NULL;
-	}
-      if (!init_expr && gfc_option.flag_init_character == GFC_INIT_CHARACTER_ON
-	  && sym->ts.u.cl->length && gfc_option.flag_max_stack_var_size != 0)
-	{
-	  gfc_actual_arglist *arg;
-	  init_expr = gfc_get_expr ();
-	  init_expr->where = sym->declared_at;
-	  init_expr->ts = sym->ts;
-	  init_expr->expr_type = EXPR_FUNCTION;
-	  init_expr->value.function.isym =
-		gfc_intrinsic_function_by_id (GFC_ISYM_REPEAT);
-	  init_expr->value.function.name = "repeat";
-	  arg = gfc_get_actual_arglist ();
-	  arg->expr = gfc_get_character_expr (sym->ts.kind, &sym->declared_at,
-					      NULL, 1);
-	  arg->expr->value.character.string[0]
-		= gfc_option.flag_init_character_value;
-	  arg->next = gfc_get_actual_arglist ();
-	  arg->next->expr = gfc_copy_expr (sym->ts.u.cl->length);
-	  init_expr->value.function.actual = arg;
-	}
-      break;
-
-    default:
-     gfc_free_expr (init_expr);
-     init_expr = NULL;
-    }
-  return init_expr;
+  /* Get the appropriate init expression. */
+  return gfc_build_default_init_expr(&sym->ts, &sym->declared_at);
 }
 
 /* Add an initialization expression to a local variable.  */
@@ -11106,9 +11133,11 @@ apply_default_init_local (gfc_symbol *sym)
      entry, so we just add a static initializer. Note that automatic variables
      are stack allocated even with -fno-automatic; we have also to exclude
      result variable, which are also nonstatic.  */
-  if (sym->attr.save || sym->ns->save_all
-      || (gfc_option.flag_max_stack_var_size == 0 && !sym->attr.result
-	  && (!sym->attr.dimension || !is_non_constant_shape_array (sym))))
+  if (!sym->attr.automatic
+      && (sym->attr.save || sym->ns->save_all
+          || (gfc_option.flag_max_stack_var_size == 0 && !sym->attr.result
+              && !sym->ns->proc_name->attr.recursive
+              && (!sym->attr.dimension || !is_non_constant_shape_array (sym)))))
     {
       /* Don't clobber an existing initializer!  */
       gcc_assert (sym->value == NULL);
@@ -11232,7 +11261,7 @@ resolve_fl_variable_derived (gfc_symbol *sym, int no_init_flag)
       gfc_find_symbol (sym->ts.u.derived->name, sym->ns, 0, &s);
       if (s && s->attr.generic)
 	s = gfc_find_dt_in_generic (s);
-      if (s && s->attr.flavor != FL_DERIVED)
+      if (s && !gfc_fl_struct (s->attr.flavor))
 	{
 	  gfc_error ("The type '%s' cannot be host associated at %L "
 		     "because it is blocked by an incompatible object "
@@ -11253,7 +11282,7 @@ resolve_fl_variable_derived (gfc_symbol *sym, int no_init_flag)
      a hidden default for allocatable components.  */
   if (!(sym->value || no_init_flag) && sym->ns->proc_name
       && sym->ns->proc_name->attr.flavor == FL_MODULE
-      && !sym->ns->save_all && !sym->attr.save
+      && !(sym->ns->save_all && !sym->attr.automatic) && !sym->attr.save
       && !sym->attr.pointer && !sym->attr.allocatable
       && gfc_has_default_initializer (sym->ts.u.derived)
       && gfc_notify_std (GFC_STD_F2008, "Implied SAVE for "
@@ -11266,7 +11295,7 @@ resolve_fl_variable_derived (gfc_symbol *sym, int no_init_flag)
   if (!(sym->value || sym->attr.pointer || sym->attr.allocatable)
       && (!no_init_flag || sym->attr.intent == INTENT_OUT))
     {
-      sym->value = gfc_default_initializer (&sym->ts);
+      sym->value = gfc_default_initializer (&sym->ts, can_create_init (sym));
     }
 
   return SUCCESS;
@@ -12230,7 +12259,7 @@ resolve_typebound_procedure (gfc_symtree* stree)
   locus where;
   gfc_symbol* me_arg;
   gfc_symbol* super_type;
-  gfc_component* comp;
+  gfc_component *comp;
 
   gcc_assert (stree);
 
@@ -12407,7 +12436,8 @@ resolve_typebound_procedure (gfc_symtree* stree)
       }
 
   /* Try to find a name collision with an inherited component.  */
-  if (super_type && gfc_find_component (super_type, stree->name, true, true))
+  if (super_type && gfc_find_component (super_type, stree->name, true, true,
+                                        NULL))
     {
       gfc_error ("Procedure '%s' at %L has the same name as an inherited"
 		 " component of '%s'",
@@ -12555,7 +12585,7 @@ check_defined_assignments (gfc_symbol *derived)
 
   for (c = derived->components; c; c = c->next)
     {
-      if (c->ts.type != BT_DERIVED
+      if (!gfc_bt_struct (c->ts.type)
 	  || c->attr.pointer
 	  || c->attr.allocatable
 	  || c->attr.proc_pointer_comp
@@ -12580,402 +12610,459 @@ check_defined_assignments (gfc_symbol *derived)
     }
 }
 
-
-/* Resolve the components of a derived type. This does not have to wait until
-   resolution stage, but can be done as soon as the dt declaration has been
-   parsed.  */
+/* Resolve a component (for resolve_fl_derived0). */
 
 static gfc_try
-resolve_fl_derived0 (gfc_symbol *sym)
+resolve_component (gfc_component *c, void *data)
 {
-  gfc_symbol* super_type;
-  gfc_component *c;
+  gfc_symbol *sym = (gfc_symbol *)data;
+  gfc_symbol *super_type = gfc_get_derived_super_type (sym);
 
-  if (sym->attr.unlimited_polymorphic)
+  if (c->attr.artificial)
     return SUCCESS;
 
-  super_type = gfc_get_derived_super_type (sym);
+  /* See PRs 51550, 47545, 48654, 49050, 51075 - and 45170.  */
+  if (c->ts.type == BT_CHARACTER && c->ts.deferred && !c->attr.function)
+    {
+      gfc_error ("Deferred-length character component '%s' at %L is not "
+                 "yet supported", c->name, &c->loc);
+      return FAILURE;
+    }
 
-  /* F2008, C432. */
-  if (super_type && sym->attr.coarray_comp && !super_type->attr.coarray_comp)
+  /* F2008, C442.  */
+  if ((!sym->attr.is_class || c != sym->components)
+      && c->attr.codimension
+      && (!c->attr.allocatable || (c->as && c->as->type != AS_DEFERRED)))
     {
-      gfc_error ("As extending type '%s' at %L has a coarray component, "
-		 "parent type '%s' shall also have one", sym->name,
-		 &sym->declared_at, super_type->name);
+      gfc_error ("Coarray component '%s' at %L must be allocatable with "
+                 "deferred shape", c->name, &c->loc);
       return FAILURE;
     }
 
-  /* Ensure the extended type gets resolved before we do.  */
-  if (super_type && resolve_fl_derived0 (super_type) == FAILURE)
-    return FAILURE;
+  /* F2008, C443.  */
+  if (c->attr.codimension && c->ts.type == BT_DERIVED
+      && c->ts.u.derived->ts.is_iso_c)
+    {
+      gfc_error ("Component '%s' at %L of TYPE(C_PTR) or TYPE(C_FUNPTR) "
+                 "shall not be a coarray", c->name, &c->loc);
+      return FAILURE;
+    }
 
-  /* An ABSTRACT type must be extensible.  */
-  if (sym->attr.abstract && !gfc_type_is_extensible (sym))
+  /* F2008, C444.  */
+  if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.coarray_comp
+      && (c->attr.codimension || c->attr.pointer || c->attr.dimension
+          || c->attr.allocatable))
     {
-      gfc_error ("Non-extensible derived-type '%s' at %L must not be ABSTRACT",
-		 sym->name, &sym->declared_at);
+      gfc_error ("Component '%s' at %L with coarray component "
+                 "shall be a nonpointer, nonallocatable scalar",
+                 c->name, &c->loc);
       return FAILURE;
     }
 
-  c = (sym->attr.is_class) ? sym->components->ts.u.derived->components
-			   : sym->components;
+  /* F2008, C448.  */
+  if (c->attr.contiguous && (!c->attr.dimension || !c->attr.pointer))
+    {
+      gfc_error ("Component '%s' at %L has the CONTIGUOUS attribute but "
+                 "is not an array pointer", c->name, &c->loc);
+      return FAILURE;
+    }
 
-  for ( ; c != NULL; c = c->next)
+  if (c->attr.proc_pointer && c->ts.interface)
     {
-      if (c->attr.artificial)
-	continue;
+      gfc_symbol *ifc = c->ts.interface;
 
-      /* See PRs 51550, 47545, 48654, 49050, 51075 - and 45170.  */
-      if (c->ts.type == BT_CHARACTER && c->ts.deferred && !c->attr.function)
-	{
-	  gfc_error ("Deferred-length character component '%s' at %L is not "
-		     "yet supported", c->name, &c->loc);
-	  return FAILURE;
-	}
+      if (!sym->attr.vtype
+          && check_proc_interface (ifc, &c->loc) == FAILURE)
+        {
+          c->tb->error = 1;
+          return FAILURE;
+        }
 
-      /* F2008, C442.  */
-      if ((!sym->attr.is_class || c != sym->components)
-	  && c->attr.codimension
-	  && (!c->attr.allocatable || (c->as && c->as->type != AS_DEFERRED)))
-	{
-	  gfc_error ("Coarray component '%s' at %L must be allocatable with "
-		     "deferred shape", c->name, &c->loc);
-	  return FAILURE;
-	}
+      if (ifc->attr.if_source || ifc->attr.intrinsic)
+        {
+          /* Resolve interface and copy attributes.  */
+          if (ifc->formal && !ifc->formal_ns)
+            resolve_symbol (ifc);
+          if (ifc->attr.intrinsic)
+            gfc_resolve_intrinsic (ifc, &ifc->declared_at);
 
-      /* F2008, C443.  */
-      if (c->attr.codimension && c->ts.type == BT_DERIVED
-	  && c->ts.u.derived->ts.is_iso_c)
-	{
-	  gfc_error ("Component '%s' at %L of TYPE(C_PTR) or TYPE(C_FUNPTR) "
-		     "shall not be a coarray", c->name, &c->loc);
-	  return FAILURE;
-	}
+          if (ifc->result)
+            {
+              c->ts = ifc->result->ts;
+              c->attr.allocatable = ifc->result->attr.allocatable;
+              c->attr.pointer = ifc->result->attr.pointer;
+              c->attr.dimension = ifc->result->attr.dimension;
+              c->as = gfc_copy_array_spec (ifc->result->as);
+              c->attr.class_ok = ifc->result->attr.class_ok;
+            }
+          else
+            {
+              c->ts = ifc->ts;
+              c->attr.allocatable = ifc->attr.allocatable;
+              c->attr.pointer = ifc->attr.pointer;
+              c->attr.dimension = ifc->attr.dimension;
+              c->as = gfc_copy_array_spec (ifc->as);
+              c->attr.class_ok = ifc->attr.class_ok;
+            }
+          c->ts.interface = ifc;
+          c->attr.function = ifc->attr.function;
+          c->attr.subroutine = ifc->attr.subroutine;
+
+          c->attr.pure = ifc->attr.pure;
+          c->attr.elemental = ifc->attr.elemental;
+          c->attr.recursive = ifc->attr.recursive;
+          c->attr.always_explicit = ifc->attr.always_explicit;
+          c->attr.ext_attr |= ifc->attr.ext_attr;
+          /* Copy char length.  */
+          if (ifc->ts.type == BT_CHARACTER && ifc->ts.u.cl)
+            {
+              gfc_charlen *cl = gfc_new_charlen (sym->ns, ifc->ts.u.cl);
+              if (cl->length && !cl->resolved
+                  && gfc_resolve_expr (cl->length) == FAILURE)
+                {
+                  c->tb->error = 1;
+                  return FAILURE;
+                }
+              c->ts.u.cl = cl;
+            }
+        }
+    }
+  else if (c->attr.proc_pointer && c->ts.type == BT_UNKNOWN)
+    {
+      /* Since PPCs are not implicitly typed, a PPC without an explicit
+         interface must be a subroutine.  */
+      gfc_add_subroutine (&c->attr, c->name, &c->loc);
+    }
 
-      /* F2008, C444.  */
-      if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.coarray_comp
-	  && (c->attr.codimension || c->attr.pointer || c->attr.dimension
-	      || c->attr.allocatable))
-	{
-	  gfc_error ("Component '%s' at %L with coarray component "
-		     "shall be a nonpointer, nonallocatable scalar",
-		     c->name, &c->loc);
-	  return FAILURE;
-	}
+  /* Procedure pointer components: Check PASS arg.  */
+  if (c->attr.proc_pointer && !c->tb->nopass && c->tb->pass_arg_num == 0
+      && !sym->attr.vtype)
+    {
+      gfc_symbol* me_arg;
 
-      /* F2008, C448.  */
-      if (c->attr.contiguous && (!c->attr.dimension || !c->attr.pointer))
-	{
-	  gfc_error ("Component '%s' at %L has the CONTIGUOUS attribute but "
-		     "is not an array pointer", c->name, &c->loc);
-	  return FAILURE;
-	}
+      if (c->tb->pass_arg)
+        {
+          gfc_formal_arglist* i;
 
-      if (c->attr.proc_pointer && c->ts.interface)
-	{
-	  gfc_symbol *ifc = c->ts.interface;
+          /* If an explicit passing argument name is given, walk the arg-list
+            and look for it.  */
 
-	  if (!sym->attr.vtype
-	      && check_proc_interface (ifc, &c->loc) == FAILURE)
-	    return FAILURE;
+          me_arg = NULL;
+          c->tb->pass_arg_num = 1;
+          for (i = c->ts.interface->formal; i; i = i->next)
+            {
+              if (!strcmp (i->sym->name, c->tb->pass_arg))
+                {
+                  me_arg = i->sym;
+                  break;
+                }
+              c->tb->pass_arg_num++;
+            }
 
-	  if (ifc->attr.if_source || ifc->attr.intrinsic)
-	    {
-	      /* Resolve interface and copy attributes.  */
-	      if (ifc->formal && !ifc->formal_ns)
-		resolve_symbol (ifc);
-	      if (ifc->attr.intrinsic)
-		gfc_resolve_intrinsic (ifc, &ifc->declared_at);
+          if (!me_arg)
+            {
+              gfc_error ("Procedure pointer component '%s' with PASS(%s) "
+                         "at %L has no argument '%s'", c->name,
+                         c->tb->pass_arg, &c->loc, c->tb->pass_arg);
+              c->tb->error = 1;
+              return FAILURE;
+            }
+        }
+      else
+        {
+          /* Otherwise, take the first one; there should in fact be at least
+            one.  */
+          c->tb->pass_arg_num = 1;
+          if (!c->ts.interface->formal)
+            {
+              gfc_error ("Procedure pointer component '%s' with PASS at %L "
+                         "must have at least one argument",
+                         c->name, &c->loc);
+              c->tb->error = 1;
+              return FAILURE;
+            }
+          me_arg = c->ts.interface->formal->sym;
+        }
 
-	      if (ifc->result)
-		{
-		  c->ts = ifc->result->ts;
-		  c->attr.allocatable = ifc->result->attr.allocatable;
-		  c->attr.pointer = ifc->result->attr.pointer;
-		  c->attr.dimension = ifc->result->attr.dimension;
-		  c->as = gfc_copy_array_spec (ifc->result->as);
-		  c->attr.class_ok = ifc->result->attr.class_ok;
-		}
-	      else
-		{
-		  c->ts = ifc->ts;
-		  c->attr.allocatable = ifc->attr.allocatable;
-		  c->attr.pointer = ifc->attr.pointer;
-		  c->attr.dimension = ifc->attr.dimension;
-		  c->as = gfc_copy_array_spec (ifc->as);
-		  c->attr.class_ok = ifc->attr.class_ok;
-		}
-	      c->ts.interface = ifc;
-	      c->attr.function = ifc->attr.function;
-	      c->attr.subroutine = ifc->attr.subroutine;
-
-	      c->attr.pure = ifc->attr.pure;
-	      c->attr.elemental = ifc->attr.elemental;
-	      c->attr.recursive = ifc->attr.recursive;
-	      c->attr.always_explicit = ifc->attr.always_explicit;
-	      c->attr.ext_attr |= ifc->attr.ext_attr;
-	      /* Copy char length.  */
-	      if (ifc->ts.type == BT_CHARACTER && ifc->ts.u.cl)
-		{
-		  gfc_charlen *cl = gfc_new_charlen (sym->ns, ifc->ts.u.cl);
-		  if (cl->length && !cl->resolved
-		      && gfc_resolve_expr (cl->length) == FAILURE)
-		    return FAILURE;
-		  c->ts.u.cl = cl;
-		}
-	    }
-	}
-      else if (c->attr.proc_pointer && c->ts.type == BT_UNKNOWN)
-	{
-	  /* Since PPCs are not implicitly typed, a PPC without an explicit
-	     interface must be a subroutine.  */
-	  gfc_add_subroutine (&c->attr, c->name, &c->loc);
-	}
+      /* Now check that the argument-type matches.  */
+      gcc_assert (me_arg);
+      if ((me_arg->ts.type != BT_DERIVED && me_arg->ts.type != BT_CLASS)
+          || (me_arg->ts.type == BT_DERIVED && me_arg->ts.u.derived != sym)
+          || (me_arg->ts.type == BT_CLASS
+              && CLASS_DATA (me_arg)->ts.u.derived != sym))
+        {
+          gfc_error ("Argument '%s' of '%s' with PASS(%s) at %L must be of"
+                     " the derived type '%s'", me_arg->name, c->name,
+                     me_arg->name, &c->loc, sym->name);
+          c->tb->error = 1;
+          return FAILURE;
+        }
 
-      /* Procedure pointer components: Check PASS arg.  */
-      if (c->attr.proc_pointer && !c->tb->nopass && c->tb->pass_arg_num == 0
-	  && !sym->attr.vtype)
-	{
-	  gfc_symbol* me_arg;
+      /* Check for C453.  */
+      if (me_arg->attr.dimension)
+        {
+          gfc_error ("Argument '%s' of '%s' with PASS(%s) at %L "
+                     "must be scalar", me_arg->name, c->name, me_arg->name,
+                     &c->loc);
+          c->tb->error = 1;
+          return FAILURE;
+        }
 
-	  if (c->tb->pass_arg)
-	    {
-	      gfc_formal_arglist* i;
+      if (me_arg->attr.pointer)
+        {
+          gfc_error ("Argument '%s' of '%s' with PASS(%s) at %L "
+                     "may not have the POINTER attribute", me_arg->name,
+                     c->name, me_arg->name, &c->loc);
+          c->tb->error = 1;
+          return FAILURE;
+        }
 
-	      /* If an explicit passing argument name is given, walk the arg-list
-		and look for it.  */
+      if (me_arg->attr.allocatable)
+        {
+          gfc_error ("Argument '%s' of '%s' with PASS(%s) at %L "
+                     "may not be ALLOCATABLE", me_arg->name, c->name,
+                     me_arg->name, &c->loc);
+          c->tb->error = 1;
+          return FAILURE;
+        }
 
-	      me_arg = NULL;
-	      c->tb->pass_arg_num = 1;
-	      for (i = c->ts.interface->formal; i; i = i->next)
-		{
-		  if (!strcmp (i->sym->name, c->tb->pass_arg))
-		    {
-		      me_arg = i->sym;
-		      break;
-		    }
-		  c->tb->pass_arg_num++;
-		}
+      if (gfc_type_is_extensible (sym) && me_arg->ts.type != BT_CLASS)
+        {
+          gfc_error ("Non-polymorphic passed-object dummy argument of '%s'"
+                     " at %L", c->name, &c->loc);
+          return FAILURE;
+        }
 
-	      if (!me_arg)
-		{
-		  gfc_error ("Procedure pointer component '%s' with PASS(%s) "
-			     "at %L has no argument '%s'", c->name,
-			     c->tb->pass_arg, &c->loc, c->tb->pass_arg);
-		  c->tb->error = 1;
-		  return FAILURE;
-		}
-	    }
-	  else
-	    {
-	      /* Otherwise, take the first one; there should in fact be at least
-		one.  */
-	      c->tb->pass_arg_num = 1;
-	      if (!c->ts.interface->formal)
-		{
-		  gfc_error ("Procedure pointer component '%s' with PASS at %L "
-			     "must have at least one argument",
-			     c->name, &c->loc);
-		  c->tb->error = 1;
-		  return FAILURE;
-		}
-	      me_arg = c->ts.interface->formal->sym;
-	    }
+    }
 
-	  /* Now check that the argument-type matches.  */
-	  gcc_assert (me_arg);
-	  if ((me_arg->ts.type != BT_DERIVED && me_arg->ts.type != BT_CLASS)
-	      || (me_arg->ts.type == BT_DERIVED && me_arg->ts.u.derived != sym)
-	      || (me_arg->ts.type == BT_CLASS
-		  && CLASS_DATA (me_arg)->ts.u.derived != sym))
-	    {
-	      gfc_error ("Argument '%s' of '%s' with PASS(%s) at %L must be of"
-			 " the derived type '%s'", me_arg->name, c->name,
-			 me_arg->name, &c->loc, sym->name);
-	      c->tb->error = 1;
-	      return FAILURE;
-	    }
+  /* Check type-spec if this is not the parent-type component.  */
+  if (((sym->attr.is_class
+        && (!sym->components->ts.u.derived->attr.extension
+            || c != sym->components->ts.u.derived->components))
+       || (!sym->attr.is_class
+           && (!sym->attr.extension || c != sym->components)))
+      && !sym->attr.vtype
+      && resolve_typespec_used (&c->ts, &c->loc, c->name) == FAILURE)
+    return FAILURE;
 
-	  /* Check for C453.  */
-	  if (me_arg->attr.dimension)
-	    {
-	      gfc_error ("Argument '%s' of '%s' with PASS(%s) at %L "
-			 "must be scalar", me_arg->name, c->name, me_arg->name,
-			 &c->loc);
-	      c->tb->error = 1;
-	      return FAILURE;
-	    }
+  /* If this type is an extension, set the accessibility of the parent
+     component.  */
+  if (super_type
+      && ((sym->attr.is_class
+           && c == sym->components->ts.u.derived->components)
+          || (!sym->attr.is_class && c == sym->components))
+      && strcmp (super_type->name, c->name) == 0)
+    c->attr.access = super_type->attr.access;
+
+  /* If this type is an extension, see if this component has the same name
+     as an inherited type-bound procedure.  */
+  if (super_type && !sym->attr.is_class
+      && gfc_find_typebound_proc (super_type, NULL, c->name, true, NULL))
+    {
+      gfc_error ("Component '%s' of '%s' at %L has the same name as an"
+                 " inherited type-bound procedure",
+                 c->name, sym->name, &c->loc);
+      return FAILURE;
+    }
 
-	  if (me_arg->attr.pointer)
-	    {
-	      gfc_error ("Argument '%s' of '%s' with PASS(%s) at %L "
-			 "may not have the POINTER attribute", me_arg->name,
-			 c->name, me_arg->name, &c->loc);
-	      c->tb->error = 1;
-	      return FAILURE;
-	    }
+  if (c->ts.type == BT_CHARACTER && !c->attr.proc_pointer
+        && !c->ts.deferred)
+    {
+     if (c->ts.u.cl->length == NULL
+         || (resolve_charlen (c->ts.u.cl) == FAILURE)
+         || !gfc_is_constant_expr (c->ts.u.cl->length))
+       {
+         gfc_error ("Character length of component '%s' needs to "
+                    "be a constant specification expression at %L",
+                    c->name,
+                    c->ts.u.cl->length ? &c->ts.u.cl->length->where : &c->loc);
+         return FAILURE;
+       }
+    }
 
-	  if (me_arg->attr.allocatable)
-	    {
-	      gfc_error ("Argument '%s' of '%s' with PASS(%s) at %L "
-			 "may not be ALLOCATABLE", me_arg->name, c->name,
-			 me_arg->name, &c->loc);
-	      c->tb->error = 1;
-	      return FAILURE;
-	    }
+  if (c->ts.type == BT_CHARACTER && c->ts.deferred
+      && !c->attr.pointer && !c->attr.allocatable)
+    {
+      gfc_error ("Character component '%s' of '%s' at %L with deferred "
+                 "length must be a POINTER or ALLOCATABLE",
+                 c->name, sym->name, &c->loc);
+      return FAILURE;
+    }
 
-	  if (gfc_type_is_extensible (sym) && me_arg->ts.type != BT_CLASS)
-	    gfc_error ("Non-polymorphic passed-object dummy argument of '%s'"
-		       " at %L", c->name, &c->loc);
+  if (c->ts.type == BT_DERIVED
+      && sym->component_access != ACCESS_PRIVATE
+      && gfc_check_symbol_access (sym)
+      && !is_sym_host_assoc (c->ts.u.derived, sym->ns)
+      && !c->ts.u.derived->attr.use_assoc
+      && !gfc_check_symbol_access (c->ts.u.derived)
+      && gfc_notify_std (GFC_STD_F2003, "the component '%s' "
+                         "is a PRIVATE type and cannot be a component of "
+                         "'%s', which is PUBLIC at %L", c->name,
+                         sym->name, &sym->declared_at) == FAILURE)
+    return FAILURE;
 
-	}
+  if ((sym->attr.sequence || sym->attr.is_bind_c) && c->ts.type == BT_CLASS)
+    {
+      gfc_error ("Polymorphic component %s at %L in SEQUENCE or BIND(C) "
+                 "type %s", c->name, &c->loc, sym->name);
+      return FAILURE;
+    }
 
-      /* Check type-spec if this is not the parent-type component.  */
-      if (((sym->attr.is_class
-	    && (!sym->components->ts.u.derived->attr.extension
-		|| c != sym->components->ts.u.derived->components))
-	   || (!sym->attr.is_class
-	       && (!sym->attr.extension || c != sym->components)))
-	  && !sym->attr.vtype
-	  && resolve_typespec_used (&c->ts, &c->loc, c->name) == FAILURE)
-	return FAILURE;
+  if (sym->attr.sequence)
+    {
+      if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.sequence == 0)
+        {
+          gfc_error ("Component %s of SEQUENCE type declared at %L does "
+                     "not have the SEQUENCE attribute",
+                     c->ts.u.derived->name, &sym->declared_at);
+          return FAILURE;
+        }
+    }
 
-      /* If this type is an extension, set the accessibility of the parent
-	 component.  */
-      if (super_type
-	  && ((sym->attr.is_class
-	       && c == sym->components->ts.u.derived->components)
-	      || (!sym->attr.is_class && c == sym->components))
-	  && strcmp (super_type->name, c->name) == 0)
-	c->attr.access = super_type->attr.access;
-
-      /* If this type is an extension, see if this component has the same name
-	 as an inherited type-bound procedure.  */
-      if (super_type && !sym->attr.is_class
-	  && gfc_find_typebound_proc (super_type, NULL, c->name, true, NULL))
-	{
-	  gfc_error ("Component '%s' of '%s' at %L has the same name as an"
-		     " inherited type-bound procedure",
-		     c->name, sym->name, &c->loc);
-	  return FAILURE;
-	}
+  if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.generic)
+    c->ts.u.derived = gfc_find_dt_in_generic (c->ts.u.derived);
+  else if (c->ts.type == BT_CLASS && c->attr.class_ok
+           && CLASS_DATA (c)->ts.u.derived->attr.generic)
+    CLASS_DATA (c)->ts.u.derived
+                    = gfc_find_dt_in_generic (CLASS_DATA (c)->ts.u.derived);
 
-      if (c->ts.type == BT_CHARACTER && !c->attr.proc_pointer
-	    && !c->ts.deferred)
-	{
-	 if (c->ts.u.cl->length == NULL
-	     || (resolve_charlen (c->ts.u.cl) == FAILURE)
-	     || !gfc_is_constant_expr (c->ts.u.cl->length))
-	   {
-	     gfc_error ("Character length of component '%s' needs to "
-			"be a constant specification expression at %L",
-			c->name,
-			c->ts.u.cl->length ? &c->ts.u.cl->length->where : &c->loc);
-	     return FAILURE;
-	   }
-	}
+  if (!sym->attr.is_class && c->ts.type == BT_DERIVED && !sym->attr.vtype
+      && c->attr.pointer && c->ts.u.derived->components == NULL
+      && !c->ts.u.derived->attr.zero_comp)
+    {
+      gfc_error ("The pointer component '%s' of '%s' at %L is a type "
+                 "that has not been declared", c->name, sym->name,
+                 &c->loc);
+      return FAILURE;
+    }
 
-      if (c->ts.type == BT_CHARACTER && c->ts.deferred
-	  && !c->attr.pointer && !c->attr.allocatable)
-	{
-	  gfc_error ("Character component '%s' of '%s' at %L with deferred "
-		     "length must be a POINTER or ALLOCATABLE",
-		     c->name, sym->name, &c->loc);
-	  return FAILURE;
-	}
+  if (c->ts.type == BT_CLASS && c->attr.class_ok
+      && CLASS_DATA (c)->attr.class_pointer
+      && CLASS_DATA (c)->ts.u.derived->components == NULL
+      && !CLASS_DATA (c)->ts.u.derived->attr.zero_comp
+      && !UNLIMITED_POLY (c))
+    {
+      gfc_error ("The pointer component '%s' of '%s' at %L is a type "
+                 "that has not been declared", c->name, sym->name,
+                 &c->loc);
+      return FAILURE;
+    }
 
-      if (c->ts.type == BT_DERIVED
-	  && sym->component_access != ACCESS_PRIVATE
-	  && gfc_check_symbol_access (sym)
-	  && !is_sym_host_assoc (c->ts.u.derived, sym->ns)
-	  && !c->ts.u.derived->attr.use_assoc
-	  && !gfc_check_symbol_access (c->ts.u.derived)
-	  && gfc_notify_std (GFC_STD_F2003, "the component '%s' "
-			     "is a PRIVATE type and cannot be a component of "
-			     "'%s', which is PUBLIC at %L", c->name,
-			     sym->name, &sym->declared_at) == FAILURE)
-	return FAILURE;
+  /* C437.  */
+  if (c->ts.type == BT_CLASS && c->attr.flavor != FL_PROCEDURE
+      && (!c->attr.class_ok
+          || !(CLASS_DATA (c)->attr.class_pointer
+               || CLASS_DATA (c)->attr.allocatable)))
+    {
+      gfc_error ("Component '%s' with CLASS at %L must be allocatable "
+                 "or pointer", c->name, &c->loc);
+      /* Prevent a recurrence of the error.  */
+      c->ts.type = BT_UNKNOWN;
+      return FAILURE;
+    }
 
-      if ((sym->attr.sequence || sym->attr.is_bind_c) && c->ts.type == BT_CLASS)
-	{
-	  gfc_error ("Polymorphic component %s at %L in SEQUENCE or BIND(C) "
-		     "type %s", c->name, &c->loc, sym->name);
-	  return FAILURE;
-	}
+  if (c->ts.type == BT_UNION && resolve_fl_union (c->ts.u.derived) == FAILURE)
+      return FAILURE;
 
-      if (sym->attr.sequence)
-	{
-	  if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.sequence == 0)
-	    {
-	      gfc_error ("Component %s of SEQUENCE type declared at %L does "
-			 "not have the SEQUENCE attribute",
-			 c->ts.u.derived->name, &sym->declared_at);
-	      return FAILURE;
-	    }
-	}
+  /* Ensure that all the derived type components are put on the
+     derived type list; even in formal namespaces, where derived type
+     pointer components might not have been declared.  */
+  if (c->ts.type == BT_DERIVED
+        && c->ts.u.derived
+        && c->ts.u.derived->components
+        && c->attr.pointer
+        && sym != c->ts.u.derived)
+    add_dt_to_dt_list (c->ts.u.derived);
+
+  if (gfc_resolve_array_spec (c->as, !(c->attr.pointer
+                                       || c->attr.proc_pointer
+                                       || c->attr.allocatable)) == FAILURE)
+    return FAILURE;
 
-      if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.generic)
-	c->ts.u.derived = gfc_find_dt_in_generic (c->ts.u.derived);
-      else if (c->ts.type == BT_CLASS && c->attr.class_ok
-	       && CLASS_DATA (c)->ts.u.derived->attr.generic)
-	CLASS_DATA (c)->ts.u.derived
-			= gfc_find_dt_in_generic (CLASS_DATA (c)->ts.u.derived);
+  if (c->initializer && !sym->attr.vtype
+      && gfc_check_assign_symbol (sym, c, c->initializer) == FAILURE)
+    return FAILURE;
 
-      if (!sym->attr.is_class && c->ts.type == BT_DERIVED && !sym->attr.vtype
-	  && c->attr.pointer && c->ts.u.derived->components == NULL
-	  && !c->ts.u.derived->attr.zero_comp)
-	{
-	  gfc_error ("The pointer component '%s' of '%s' at %L is a type "
-		     "that has not been declared", c->name, sym->name,
-		     &c->loc);
-	  return FAILURE;
-	}
+  return SUCCESS;
+}
 
-      if (c->ts.type == BT_CLASS && c->attr.class_ok
-	  && CLASS_DATA (c)->attr.class_pointer
-	  && CLASS_DATA (c)->ts.u.derived->components == NULL
-	  && !CLASS_DATA (c)->ts.u.derived->attr.zero_comp
-	  && !UNLIMITED_POLY (c))
-	{
-	  gfc_error ("The pointer component '%s' of '%s' at %L is a type "
-		     "that has not been declared", c->name, sym->name,
-		     &c->loc);
-	  return FAILURE;
-	}
+/* Resolve the components of a union type. */
 
-      /* C437.  */
-      if (c->ts.type == BT_CLASS && c->attr.flavor != FL_PROCEDURE
-	  && (!c->attr.class_ok
-	      || !(CLASS_DATA (c)->attr.class_pointer
-		   || CLASS_DATA (c)->attr.allocatable)))
-	{
-	  gfc_error ("Component '%s' with CLASS at %L must be allocatable "
-		     "or pointer", c->name, &c->loc);
-	  /* Prevent a recurrence of the error.  */
-	  c->ts.type = BT_UNKNOWN;
-	  return FAILURE;
-	}
+static gfc_try
+resolve_fl_union (gfc_symbol *sym)
+{
+  gfc_component *map;
+  gfc_try success;
 
-      /* Ensure that all the derived type components are put on the
-	 derived type list; even in formal namespaces, where derived type
-	 pointer components might not have been declared.  */
-      if (c->ts.type == BT_DERIVED
-	    && c->ts.u.derived
-	    && c->ts.u.derived->components
-	    && c->attr.pointer
-	    && sym != c->ts.u.derived)
-	add_dt_to_dt_list (c->ts.u.derived);
+  gcc_assert (sym->attr.flavor == FL_UNION);
 
-      if (gfc_resolve_array_spec (c->as, !(c->attr.pointer
-					   || c->attr.proc_pointer
-					   || c->attr.allocatable)) == FAILURE)
-	return FAILURE;
+  success = SUCCESS;
+  for (map = sym->components; map; map = map->next)
+  {
+    if (resolve_component (map, (void *)sym) == FAILURE)
+      success = FAILURE;
+  }
 
-      if (c->initializer && !sym->attr.vtype
-	  && gfc_check_assign_symbol (sym, c, c->initializer) == FAILURE)
-	return FAILURE;
+  if (success != SUCCESS)
+    return FAILURE;
+
+  if (sym->components)
+    add_dt_to_dt_list (sym);
+
+  return SUCCESS;
+}
+
+/* Resolve the components of a derived type. This does not have to wait until
+   resolution stage, but can be done as soon as the dt declaration has been
+   parsed.  */
+
+static gfc_try
+resolve_fl_derived0 (gfc_symbol *sym)
+{
+  gfc_symbol* super_type;
+  gfc_component *c;
+  gfc_try success;
+
+  if (sym->attr.unlimited_polymorphic)
+    return SUCCESS;
+
+  super_type = gfc_get_derived_super_type (sym);
+
+  /* F2008, C432. */
+  if (super_type && sym->attr.coarray_comp && !super_type->attr.coarray_comp)
+    {
+      gfc_error ("As extending type '%s' at %L has a coarray component, "
+		 "parent type '%s' shall also have one", sym->name,
+		 &sym->declared_at, super_type->name);
+      return FAILURE;
+    }
+
+  /* Ensure the extended type gets resolved before we do.  */
+  if (super_type && resolve_fl_derived0 (super_type) == FAILURE)
+    return FAILURE;
+
+  /* An ABSTRACT type must be extensible.  */
+  if (sym->attr.abstract && !gfc_type_is_extensible (sym))
+    {
+      gfc_error ("Non-extensible derived-type '%s' at %L must not be ABSTRACT",
+		 sym->name, &sym->declared_at);
+      return FAILURE;
     }
 
+  c = (sym->attr.is_class) ? sym->components->ts.u.derived->components
+			   : sym->components;
+
+  /* Resolve all components of this type. */
+  success = SUCCESS;
+  for (; c; c = c->next)
+  {
+    if (resolve_component (c, (void *)sym) == FAILURE)
+      success = FAILURE;
+  }
+
+  if (success != SUCCESS)
+    return FAILURE;
+
   check_defined_assignments (sym);
 
   if (!sym->attr.defined_assign_comp && super_type)
@@ -13037,8 +13124,8 @@ resolve_fl_derived (gfc_symbol *sym)
   if (sym->attr.is_class && sym->ts.u.derived == NULL)
     {
       /* Fix up incomplete CLASS symbols.  */
-      gfc_component *data = gfc_find_component (sym, "_data", true, true);
-      gfc_component *vptr = gfc_find_component (sym, "_vptr", true, true);
+      gfc_component *data = gfc_find_component (sym, "_data", true, true, NULL);
+      gfc_component *vptr = gfc_find_component (sym, "_vptr", true, true, NULL);
 
       /* Nothing more to do for unlimited polymorphic entities.  */
       if (data->ts.u.derived->attr.unlimited_polymorphic)
@@ -13259,6 +13346,11 @@ resolve_symbol (gfc_symbol *sym)
     return;
   sym->resolved = 1;
 
+  /* No symbol will ever have union type; only components can be unions.
+     Union type declaration symbols have type BT_UNKNOWN but flavor FL_UNION
+     (just like derived type declaration symbols have flavor FL_DERIVED). */
+  gcc_assert (sym->ts.type != BT_UNION);
+
   if (sym->attr.artificial)
     return;
 
@@ -13327,7 +13419,11 @@ resolve_symbol (gfc_symbol *sym)
       return;
     }
 
-  if (sym->attr.flavor == FL_DERIVED && resolve_fl_derived (sym) == FAILURE)
+  if ((sym->attr.flavor == FL_DERIVED || sym->attr.flavor == FL_STRUCT)
+      && resolve_fl_derived (sym) == FAILURE)
+    return;
+
+  if (sym->attr.flavor == FL_UNION && resolve_fl_union (sym) == FAILURE)
     return;
 
   /* Symbols that are module procedures with results (functions) have
@@ -13547,7 +13643,7 @@ resolve_symbol (gfc_symbol *sym)
      interoperability when a variable is declared of that type.  */
   if (sym->attr.is_bind_c && sym->attr.implicit_type == 0 &&
       sym->attr.use_assoc == 0 && sym->attr.dummy == 0 &&
-      sym->attr.flavor != FL_PROCEDURE && sym->attr.flavor != FL_DERIVED)
+      sym->attr.flavor != FL_PROCEDURE && !gfc_fl_struct (sym->attr.flavor))
     {
       gfc_try t = SUCCESS;
 
@@ -13723,7 +13819,7 @@ resolve_symbol (gfc_symbol *sym)
   if (class_attr.codimension
       && !(class_attr.allocatable || sym->attr.dummy || sym->attr.save
 	   || sym->attr.select_type_temporary
-	   || sym->ns->save_all
+	   || (sym->ns->save_all && !sym->attr.automatic)
 	   || sym->ns->proc_name->attr.flavor == FL_MODULE
 	   || sym->ns->proc_name->attr.is_main_program
 	   || sym->attr.function || sym->attr.result || sym->attr.use_assoc))
@@ -13861,7 +13957,8 @@ resolve_symbol (gfc_symbol *sym)
     }
 
   /* Check threadprivate restrictions.  */
-  if (sym->attr.threadprivate && !sym->attr.save && !sym->ns->save_all
+  if (sym->attr.threadprivate && !sym->attr.save 
+      && !(sym->ns->save_all && !sym->attr.automatic)
       && (!sym->attr.in_common
 	  && sym->module == NULL
 	  && (sym->ns->proc_name == NULL
@@ -13875,16 +13972,16 @@ resolve_symbol (gfc_symbol *sym)
       && !sym->value
       && !sym->attr.allocatable
       && !sym->attr.alloc_comp)
-    {
-      symbol_attribute *a = &sym->attr;
-
-      if ((!a->save && !a->dummy && !a->pointer
-	   && !a->in_common && !a->use_assoc
-	   && (a->referenced || a->result)
-	   && !(a->function && sym != sym->result))
-	  || (a->dummy && a->intent == INTENT_OUT && !a->pointer))
-	apply_default_init (sym);
-    }
+  {
+    symbol_attribute *a = &sym->attr;
+
+    if ((!a->save && !a->dummy && !a->pointer
+          && !a->in_common && !a->use_assoc
+          && (a->referenced || a->result)
+          && !(a->function && sym != sym->result))
+        || (a->dummy && a->intent == INTENT_OUT && !a->pointer))
+      apply_default_init (sym);
+  }
 
   if (sym->ts.type == BT_CLASS && sym->ns == gfc_current_ns
       && sym->attr.dummy && sym->attr.intent == INTENT_OUT
@@ -14479,8 +14576,7 @@ sequence_type (gfc_typespec ts)
 
   switch (ts.type)
   {
-    case BT_DERIVED:
-
+    case_struct_bt:
       if (ts.u.derived->components == NULL)
 	return SEQ_NONDEFAULT;
 
@@ -14566,7 +14662,7 @@ resolve_equivalence_derived (gfc_symbol *derived, gfc_symbol *sym, gfc_expr *e)
 
   for (; c ; c = c->next)
     {
-      if (c->ts.type == BT_DERIVED
+      if (gfc_bt_struct (c->ts.type)
 	  && (resolve_equivalence_derived (c->ts.u.derived, sym, e) == FAILURE))
 	return FAILURE;
 
diff --git a/gcc/fortran/scanner.c b/gcc/fortran/scanner.c
index f714ed01a54..d762e6c2a58 100644
--- a/gcc/fortran/scanner.c
+++ b/gcc/fortran/scanner.c
@@ -332,14 +332,9 @@ add_path_to_list (gfc_directorylist **list, const char *path,
   if (stat (q, &st))
     {
       if (errno != ENOENT)
-	gfc_warning_now ("Include directory \"%s\": %s", path,
-			 xstrerror(errno));
-      else
-	{
-	  /* FIXME:  Also support -Wmissing-include-dirs.  */
-	  if (warn)
-	    gfc_warning_now ("Nonexistent include directory \"%s\"", path);
-	}
+        gfc_warning ("Include directory %s: %s", path, xstrerror(errno));
+      else if (warn && gfc_option.warn_missing_include_dirs)
+        gfc_warning ("Nonexistent include directory %s", path);
       return;
     }
   else if (!S_ISDIR (st.st_mode))
diff --git a/gcc/fortran/simplify.c b/gcc/fortran/simplify.c
index 65c65a300d2..eca7da4709c 100644
--- a/gcc/fortran/simplify.c
+++ b/gcc/fortran/simplify.c
@@ -1699,6 +1699,144 @@ gfc_simplify_conjg (gfc_expr *e)
   return range_check (result, "CONJG");
 }
 
+/* Return the simplification of the constant expression func(x). */
+
+static gfc_expr *
+simplify_trig_call (gfc_expr *icall)
+{
+  gfc_isym_id func = icall->value.function.isym->id;
+  gfc_expr *x = icall->value.function.actual->expr;
+
+  switch (func)
+  {
+    case GFC_ISYM_ACOS:
+        return gfc_simplify_acos (x);
+    case GFC_ISYM_ASIN:
+        return gfc_simplify_asin (x);
+    case GFC_ISYM_ATAN:
+        return gfc_simplify_atan (x); 
+    case GFC_ISYM_COS:
+        return gfc_simplify_cos (x);
+    case GFC_ISYM_COTAN:
+        return gfc_simplify_cotan (x);
+    case GFC_ISYM_SIN:
+        return gfc_simplify_sin (x);
+    case GFC_ISYM_TAN:
+        return gfc_simplify_tan (x);
+    default:
+         break;
+  }
+  /* Unreachable. */
+  gfc_internal_error ("in simplify_trig_call(): Bad intrinsic");
+  return NULL;
+}
+
+/* Convert a floating-point number from radians to degrees. */
+
+static void
+degrees_f (mpfr_t x, mp_rnd_t rnd_mode)
+{
+    mpfr_t tmp;
+    mpfr_init (tmp);
+
+    /* x = x * 180 */
+    mpfr_set_d (tmp, 180.0l, rnd_mode);
+    mpfr_mul (x, x, tmp, rnd_mode);
+
+    /* x = x / pi */
+    mpfr_const_pi (tmp, rnd_mode);
+    mpfr_div (x, x, tmp, rnd_mode); 
+
+    mpfr_clear (tmp);
+}
+
+/* Convert a floating-point number from degrees to radians. */
+
+static void
+radians_f (mpfr_t x, mp_rnd_t rnd_mode)
+{
+    mpfr_t tmp;
+    mpfr_init (tmp);
+
+    /* x = x * pi */
+    mpfr_const_pi (tmp, rnd_mode);
+    mpfr_mul (x, x, tmp, rnd_mode);
+
+    /* x = x / 180 */
+    mpfr_set_d (tmp, 180.0l, rnd_mode);
+    mpfr_div (x, x, tmp, rnd_mode); 
+
+    mpfr_clear (tmp);
+}
+
+
+/* Convert argument to radians before calling a trig function.  */
+
+gfc_expr *
+gfc_simplify_trigd (gfc_expr *icall)
+{
+  gfc_expr *arg;
+
+  arg = icall->value.function.actual->expr;
+
+  if (arg->ts.type != BT_REAL)
+    gfc_internal_error ("in gfc_simplify_trigd(): Bad type");
+
+  if (arg->expr_type == EXPR_CONSTANT)
+    /* Convert constant to radians before passing off to simplifier. */
+    radians_f (arg->value.real, GFC_RND_MODE);
+
+  /* Let the usual simplifier take over - we just simplified the arg.  */
+  return simplify_trig_call (icall);
+}
+
+/* Convert result of an inverse trig function to degrees.  */
+
+gfc_expr *
+gfc_simplify_atrigd (gfc_expr *icall)
+{
+  gfc_expr *result;
+
+  if (icall->value.function.actual->expr->ts.type != BT_REAL)
+    gfc_internal_error ("in gfc_simplify_atrigd(): Bad type");
+
+  /* See if another simplifier has work to do first. */
+  result = simplify_trig_call (icall);
+
+  if (result && result->expr_type == EXPR_CONSTANT)
+  {
+      /* Convert constant to degrees after passing off to actual simplifier. */
+      degrees_f (result->value.real, GFC_RND_MODE);
+      return result;
+  }
+
+  /* Let gfc_resolve_atrigd take care of the non-constant case.  */
+  return NULL;
+}
+
+/* Convert the result of atan2 to degrees.  */
+
+gfc_expr *
+gfc_simplify_atan2d (gfc_expr *y, gfc_expr *x)
+{
+  gfc_expr *result;
+
+  if (x->ts.type != BT_REAL || y->ts.type != BT_REAL)
+    gfc_internal_error ("in gfc_simplify_atan2d(): Bad type");
+
+  if (x->expr_type == EXPR_CONSTANT && y->expr_type == EXPR_CONSTANT)
+    {
+      result = gfc_simplify_atan2 (y, x);
+      if (result != NULL)
+        {
+          degrees_f (result->value.real, GFC_RND_MODE);
+          return result;
+        }
+    }
+
+  /* Let gfc_resolve_atan2d take care of the non-constant case.  */
+  return NULL;
+}
 
 gfc_expr *
 gfc_simplify_cos (gfc_expr *x)
@@ -5945,6 +6083,43 @@ gfc_simplify_sum (gfc_expr *array, gfc_expr *dim, gfc_expr *mask)
 
 
 gfc_expr *
+gfc_simplify_cotan (gfc_expr *x)
+{
+  gfc_expr *result;
+  mpc_t one, *val;
+
+  if (x->expr_type != EXPR_CONSTANT)
+    return NULL;
+
+  result = gfc_get_constant_expr (x->ts.type, x->ts.kind, &x->where);
+
+  switch (x->ts.type)
+    {
+      case BT_REAL:
+        mpfr_cot (result->value.real, x->value.real, GFC_RND_MODE);
+        break;
+
+      case BT_COMPLEX:
+        mpc_init2 (one, mpfr_get_default_prec ());
+        mpc_set_ui (one, 1, GFC_MPC_RND_MODE);
+
+        /* There is no builtin mpc_cot, so compute x = 1 / tan(x).  */
+        val = &result->value.complex;
+        mpc_tan (*val, *val, GFC_MPC_RND_MODE);
+        mpc_div (*val, one, *val, GFC_MPC_RND_MODE); 
+
+        mpc_clear (one);
+        break;
+
+      default:
+        gcc_unreachable ();
+    }
+
+  return range_check (result, "COTAN");
+}
+
+
+gfc_expr *
 gfc_simplify_tan (gfc_expr *x)
 {
   gfc_expr *result;
diff --git a/gcc/fortran/symbol.c b/gcc/fortran/symbol.c
index 785f58200c2..4134c643dc7 100644
--- a/gcc/fortran/symbol.c
+++ b/gcc/fortran/symbol.c
@@ -40,6 +40,7 @@ const mstring flavors[] =
   minit ("VARIABLE", FL_VARIABLE), minit ("PARAMETER", FL_PARAMETER),
   minit ("LABEL", FL_LABEL), minit ("PROCEDURE", FL_PROCEDURE),
   minit ("DERIVED", FL_DERIVED), minit ("NAMELIST", FL_NAMELIST),
+  minit ("UNION", FL_UNION), minit ("STRUCTURE", FL_STRUCT),
   minit (NULL, -1)
 };
 
@@ -362,7 +363,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)
     *volatile_ = "VOLATILE", *is_protected = "PROTECTED",
     *is_bind_c = "BIND(C)", *procedure = "PROCEDURE",
     *asynchronous = "ASYNCHRONOUS", *codimension = "CODIMENSION",
-    *contiguous = "CONTIGUOUS", *generic = "GENERIC";
+    *contiguous = "CONTIGUOUS", *generic = "GENERIC", *automatic = "AUTOMATIC";
   static const char *threadprivate = "THREADPRIVATE";
 
   const char *a1, *a2;
@@ -421,6 +422,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)
       conf (dummy, save);
       conf (in_common, save);
       conf (result, save);
+      conf (automatic, save);
 
       switch (attr->flavor)
 	{
@@ -428,8 +430,8 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)
 	  case FL_BLOCK_DATA:
 	  case FL_MODULE:
 	  case FL_LABEL:
-	  case FL_DERIVED:
 	  case FL_PARAMETER:
+          case_struct_fl:
             a1 = gfc_code2string (flavors, attr->flavor);
             a2 = save;
 	    goto conflict;
@@ -455,6 +457,12 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)
   conf (pointer, elemental);
   conf (allocatable, elemental);
 
+  conf (in_common, automatic);
+  conf (in_equivalence, automatic);
+  conf (result, automatic);
+  conf (use_assoc, automatic);
+  conf (dummy, automatic);
+
   conf (target, external);
   conf (target, intrinsic);
 
@@ -694,7 +702,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)
 
       break;
 
-    case FL_DERIVED:
+    case_struct_fl:
       conf2 (dummy);
       conf2 (pointer);
       conf2 (target);
@@ -1095,6 +1103,21 @@ gfc_add_result (symbol_attribute *attr, const char *name, locus *where)
 
 
 gfc_try
+gfc_add_automatic (symbol_attribute *attr, const char *name, locus *where)
+{
+  if (check_used (attr, name, where))
+    return FAILURE;
+
+  if (attr->automatic && gfc_notify_std (GFC_STD_LEGACY, 
+      "Duplicate AUTOMATIC attribute specified at %L", where) == FAILURE)
+    return FAILURE;
+
+  attr->automatic = 1;
+  return check_conflict (attr, name, where);
+}
+
+
+gfc_try
 gfc_add_save (symbol_attribute *attr, save_state s, const char *name,
 	      locus *where)
 {
@@ -1454,7 +1477,7 @@ gfc_add_flavor (symbol_attribute *attr, sym_flavor f, const char *name,
 {
 
   if ((f == FL_PROGRAM || f == FL_BLOCK_DATA || f == FL_MODULE
-       || f == FL_PARAMETER || f == FL_LABEL || f == FL_DERIVED
+       || f == FL_PARAMETER || f == FL_LABEL || gfc_fl_struct (f)
        || f == FL_NAMELIST) && check_used (attr, name, where))
     return FAILURE;
 
@@ -1689,7 +1712,7 @@ gfc_add_type (gfc_symbol *sym, gfc_typespec *ts, locus *where)
   if (flavor == FL_PROGRAM || flavor == FL_BLOCK_DATA || flavor == FL_MODULE
       || flavor == FL_LABEL
       || (flavor == FL_PROCEDURE && sym->attr.subroutine)
-      || flavor == FL_DERIVED || flavor == FL_NAMELIST)
+      || gfc_fl_struct (flavor) || flavor == FL_NAMELIST)
     {
       gfc_error ("Symbol '%s' at %L cannot have a type", sym->name, where);
       return FAILURE;
@@ -1749,6 +1772,8 @@ gfc_copy_attr (symbol_attribute *dest, symbol_attribute *src, locus *where)
     goto fail;
   if (src->is_protected && gfc_add_protected (dest, NULL, where) == FAILURE)
     goto fail;
+  if (src->automatic && gfc_add_automatic (dest, NULL, where) == FAILURE)
+    goto fail;
   if (src->save && gfc_add_save (dest, src->save, NULL, where) == FAILURE)
     goto fail;
   if (src->value && gfc_add_value (dest, NULL, where) == FAILURE)
@@ -1835,7 +1860,6 @@ fail:
   return FAILURE;
 }
 
-
 /************** Component name management ************/
 
 /* Component names of a derived type form their own little namespaces
@@ -1854,6 +1878,11 @@ gfc_add_component (gfc_symbol *sym, const char *name,
 {
   gfc_component *p, *tail;
 
+  /* Check for existing components with the same name, but not for union
+     components or containers. Unions and maps are anonymous so they have
+     unique internal names which will never conflict.
+     Don't use gfc_find_component here because it calls gfc_use_derived,
+     but the derived type may not be fully defined yet. */
   tail = NULL;
 
   for (p = sym->components; p; p = p->next)
@@ -1869,7 +1898,7 @@ gfc_add_component (gfc_symbol *sym, const char *name,
     }
 
   if (sym->attr.extension
-	&& gfc_find_component (sym->components->ts.u.derived, name, true, true))
+	&& gfc_find_component (sym->components->ts.u.derived, name, true, true, NULL))
     {
       gfc_error ("Component '%s' at %C already in the parent type "
 		 "at %L", name, &sym->components->ts.u.derived->declared_at);
@@ -1960,7 +1989,7 @@ gfc_use_derived (gfc_symbol *sym)
       return NULL;
     }
 
-  if (s == NULL || s->attr.flavor != FL_DERIVED)
+  if (s == NULL || !gfc_fl_struct (s->attr.flavor))
     goto bad;
 
   /* Get rid of symbol sym, translating all references to s.  */
@@ -1993,30 +2022,110 @@ bad:
   return NULL;
 }
 
+   
+static gfc_component *
+find_union_component (gfc_symbol *un, const char *name,
+                      bool noaccess, gfc_ref **ref)
+{
+  gfc_component *m, *check;
+  gfc_ref *sref, *tmp;
+
+  for (m = un->components; m; m = m->next)
+  {
+    check = gfc_find_component (m->ts.u.derived, name, noaccess, true, &tmp);
+    if (check == NULL)
+      continue;
+
+    /* Found it somewhere in m; chain the refs together. */
+    if (ref)
+    {
+      /* Map ref. */
+      sref = gfc_get_ref ();
+      sref->type = REF_COMPONENT;
+      sref->u.c.component = m;
+      sref->u.c.sym = m->ts.u.derived;
+      sref->next = tmp;
+
+      *ref = sref;
+    }
+    /* Other checks (such as access) were done in the recursive calls.
+       Now we are done! */
+    return check;
+  }
+  return NULL;
+}
+
 
 /* Given a derived type node and a component name, try to locate the
    component structure.  Returns the NULL pointer if the component is
    not found or the components are private.  If noaccess is set, no access
-   checks are done.  */
+   checks are done. Unless silent is set, a gfc_error is generated when the
+   component cannot be found or accessed.
+   
+   If ref is not NULL, *ref is set to represent the chain of components
+   required to get to the ultimate component.
+
+   If the component is simply a direct subcomponent, or is inherited from a
+   parent derived type in the given derived type, this is a single ref with its
+   component set to the returned component.
+
+   Otherwise, *ref is constructed as a chain of subcomponents. This occurs
+   when the component is found through an implicit chain of nested union and
+   map components. Unions and maps are "anonymous" substructures in FORTRAN
+   which cannot be explicitly referenced, but the reference chain must be
+   considered as in C for backend translation to correctly compute layouts.
+   (For example, x.a may refer to x->(UNION)->(MAP)->(UNION)->(MAP)->a). */
 
 gfc_component *
 gfc_find_component (gfc_symbol *sym, const char *name,
-		    bool noaccess, bool silent)
+		    bool noaccess, bool silent, gfc_ref **ref)
 {
-  gfc_component *p;
+  gfc_component *p, *check;
+  gfc_ref *sref = NULL, *tmp = NULL;
 
   if (name == NULL || sym == NULL)
     return NULL;
 
-  sym = gfc_use_derived (sym);
+  if (sym->attr.flavor == FL_DERIVED)
+    sym = gfc_use_derived (sym);
+  else
+    gcc_assert (gfc_fl_struct (sym->attr.flavor));
 
   if (sym == NULL)
     return NULL;
 
+  /* Handle UNIONs specially. */
+  if (sym->attr.flavor == FL_UNION)
+    return find_union_component (sym, name, noaccess, ref);
+
+  if (ref) *ref = NULL;
   for (p = sym->components; p; p = p->next)
-    if (strcmp (p->name, name) == 0)
+  {
+    /* Nest search into union's maps. */
+    if (p->ts.type == BT_UNION)
+    {
+      check = find_union_component (p->ts.u.derived, name, noaccess, &tmp);
+      if (check != NULL)
+      {
+        /* Union ref. */
+        if (ref)
+        {
+          sref = gfc_get_ref ();
+          sref->type = REF_COMPONENT;
+          sref->u.c.component = p;
+          sref->u.c.sym = p->ts.u.derived;
+          sref->next = tmp;
+          *ref = sref;
+        }
+        return check;
+      }
+    }
+    else if (strcmp (p->name, name) == 0)
       break;
 
+    continue;
+  }
+
   if (p && sym->attr.use_assoc && !noaccess)
     {
       bool is_parent_comp = sym->attr.extension && (p == sym->components);
@@ -2032,12 +2141,14 @@ gfc_find_component (gfc_symbol *sym, const char *name,
 	}
     }
 
+  /* Look in the parent type. */
   if (p == NULL
+        && sym->attr.flavor == FL_DERIVED
 	&& sym->attr.extension
 	&& sym->components->ts.type == BT_DERIVED)
     {
       p = gfc_find_component (sym->components->ts.u.derived, name,
-			      noaccess, silent);
+			      noaccess, silent, ref);
       /* Do not overwrite the error.  */
       if (p == NULL)
 	return p;
@@ -2047,6 +2158,25 @@ gfc_find_component (gfc_symbol *sym, const char *name,
     gfc_error ("'%s' at %C is not a member of the '%s' structure",
 	       name, sym->name);
 
+  /* Component was found; build the ultimate component reference. */
+  if (p != NULL && ref)
+  {
+    tmp = gfc_get_ref ();
+    tmp->type = REF_COMPONENT;
+    tmp->u.c.component = p;
+    tmp->u.c.sym = sym;
+    /* Link the final component ref to the end of the chain of subrefs. */
+    if (sref)
+    {
+      *ref = sref;
+      for (; sref->next; sref = sref->next)
+        ;
+      sref->next = tmp;
+    }
+    else
+      *ref = tmp;
+  }
+
   return p;
 }
 
@@ -3115,11 +3245,9 @@ gfc_restore_last_undo_checkpoint (void)
 	  /* The derived type is saved in the symtree with the first
 	     letter capitalized; the all lower-case version to the
 	     derived type contains its associated generic function.  */
-	  if (p->attr.flavor == FL_DERIVED)
-	    gfc_delete_symtree (&p->ns->sym_root, gfc_get_string ("%c%s",
-                        (char) TOUPPER ((unsigned char) p->name[0]),
-                        &p->name[1]));
-	  else
+	  if (gfc_fl_struct (p->attr.flavor))
+	    gfc_delete_symtree (&p->ns->sym_root,gfc_dt_upper_string (p->name));
+          else
 	    gfc_delete_symtree (&p->ns->sym_root, p->name);
 
 	  gfc_release_symbol (p);
@@ -3636,6 +3764,10 @@ gfc_is_var_automatic (gfc_symbol *sym)
       && sym->ts.u.cl
       && !gfc_is_constant_expr (sym->ts.u.cl->length))
     return true;
+  /* Variables with explicit AUTOMATIC attribute. */
+  if (sym->attr.automatic)
+    return true;
+
   return false;
 }
 
@@ -3859,7 +3991,7 @@ verify_bind_c_derived_type (gfc_symbol *derived_sym)
         }
       
       /* BIND(C) derived types must have interoperable components.  */
-      if (curr_comp->ts.type == BT_DERIVED
+      if (gfc_bt_struct (curr_comp->ts.type)
 	  && curr_comp->ts.u.derived->ts.is_iso_c != 1 
           && curr_comp->ts.u.derived != derived_sym)
         {
@@ -4548,9 +4680,7 @@ generate_isocbinding_symbol (const char *mod_name, iso_c_binding_symbol s,
 	  gfc_component *tmp_comp = NULL;
 	  char comp_name[(GFC_MAX_SYMBOL_LEN * 2) + 1];
 
-	  hidden_name = gfc_get_string ("%c%s",
-			    (char) TOUPPER ((unsigned char) tmp_sym->name[0]),
-                            &tmp_sym->name[1]);
+	  hidden_name = gfc_dt_upper_string (tmp_sym->name);
 
 	  /* Generate real derived type.  */
 	  tmp_symtree = gfc_find_symtree (gfc_current_ns->sym_root,
@@ -4911,15 +5041,21 @@ gfc_type_compatible (gfc_typespec *ts1, gfc_typespec *ts2)
   bool is_class2 = (ts2->type == BT_CLASS);
   bool is_derived1 = (ts1->type == BT_DERIVED);
   bool is_derived2 = (ts2->type == BT_DERIVED);
+  bool is_union1 = (ts1->type == BT_UNION);
+  bool is_union2 = (ts2->type == BT_UNION);
 
   if (is_class1
       && ts1->u.derived->components
       && ts1->u.derived->components->ts.u.derived->attr.unlimited_polymorphic)
     return 1;
 
-  if (!is_derived1 && !is_derived2 && !is_class1 && !is_class2)
+  if (!is_derived1 && !is_derived2 && !is_class1 && !is_class2
+      && !is_union1 && !is_union2)
     return (ts1->type == ts2->type);
 
+  if (is_union1 && is_union2)
+    return gfc_compare_union_types (ts1->u.derived, ts2->u.derived);
+
   if (is_derived1 && is_derived2)
     return gfc_compare_derived_types (ts1->u.derived, ts2->u.derived);
 
@@ -4978,12 +5114,12 @@ gfc_find_dt_in_generic (gfc_symbol *sym)
 {
   gfc_interface *intr = NULL;
 
-  if (!sym || sym->attr.flavor == FL_DERIVED)
+  if (!sym || gfc_fl_struct (sym->attr.flavor))
     return sym;
 
   if (sym->attr.generic)
     for (intr = sym->generic; intr; intr = intr->next)
-      if (intr->sym->attr.flavor == FL_DERIVED)
+      if (gfc_fl_struct (intr->sym->attr.flavor))
         break;
   return intr ? intr->sym : NULL;
 }
diff --git a/gcc/fortran/target-memory.c b/gcc/fortran/target-memory.c
index 26a5de2326d..4fe7d5c23a4 100644
--- a/gcc/fortran/target-memory.c
+++ b/gcc/fortran/target-memory.c
@@ -107,8 +107,8 @@ gfc_element_size (gfc_expr *e)
 
     case BT_HOLLERITH:
       return e->representation.length;
-    case BT_DERIVED:
     case BT_CLASS:
+    case_struct_bt:
       {
 	/* Determine type size without clobbering the typespec for ISO C
 	   binding types.  */
@@ -279,6 +279,9 @@ gfc_target_encode_expr (gfc_expr *source, unsigned char *buffer,
   if (source == NULL)
     return 0;
 
+  /* Assumed no union will end up here. */
+  gcc_assert (source->ts.type != BT_UNION);
+
   if (source->expr_type == EXPR_ARRAY)
     return encode_array (source, buffer, buffer_size);
 
@@ -593,6 +596,11 @@ gfc_target_interpret_expr (unsigned char *buffer, size_t buffer_size,
       gcc_assert (result->representation.length >= 0);
       break;
 
+    /* TODO: Handle BT_UNION ? */
+    case BT_UNION:
+      gfc_warning_now ("Union binary representation unimplemented");
+      break;
+
     default:
       gfc_internal_error ("Invalid expression in gfc_target_interpret_expr.");
       break;
@@ -639,7 +647,7 @@ expr_to_char (gfc_expr *e, unsigned char *data, unsigned char *chk, size_t len)
 
   /* Take a derived type, one component at a time, using the offsets from the backend
      declaration.  */
-  if (e->ts.type == BT_DERIVED)
+  if (gfc_bt_struct (e->ts.type))
     {
       for (c = gfc_constructor_first (e->value.constructor),
 	   cmp = e->ts.u.derived->components;
diff --git a/gcc/fortran/trans-const.c b/gcc/fortran/trans-const.c
index a217c471411..60ce458a42d 100644
--- a/gcc/fortran/trans-const.c
+++ b/gcc/fortran/trans-const.c
@@ -308,7 +308,8 @@ gfc_conv_constant_to_tree (gfc_expr * expr)
 			gfc_get_int_type (expr->ts.kind),
 			gfc_build_string_const (expr->representation.length,
 						expr->representation.string));
-	  if (!integer_zerop (tmp) && !integer_onep (tmp))
+	  if (!integer_zerop (tmp) && !integer_onep (tmp)
+              && !gfc_option.flag_lazy_logicals)
 	    gfc_warning ("Assigning value other than 0 or 1 to LOGICAL"
 			 " has undefined result at %L", &expr->where);
 	  return fold_convert (gfc_get_logical_type (expr->ts.kind), tmp);
diff --git a/gcc/fortran/trans-decl.c b/gcc/fortran/trans-decl.c
index b473d660e73..6c6fd5bcf3d 100644
--- a/gcc/fortran/trans-decl.c
+++ b/gcc/fortran/trans-decl.c
@@ -593,7 +593,7 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)
     }
 
   /* Keep variables larger than max-stack-var-size off stack.  */
-  if (!sym->ns->proc_name->attr.recursive
+  if (!sym->ns->proc_name->attr.recursive && !sym->attr.automatic
       && INTEGER_CST_P (DECL_SIZE_UNIT (decl))
       && !gfc_can_put_var_on_stack (DECL_SIZE_UNIT (decl))
 	 /* Put variable length auto array pointers always into stack.  */
@@ -603,7 +603,43 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)
 	  || sym->attr.pointer
 	  || sym->attr.allocatable)
       && !DECL_ARTIFICIAL (decl))
-    TREE_STATIC (decl) = 1;
+    {
+      TREE_STATIC (decl) = 1;
+
+      /* Because the size of this variable isn't known until now, we may have
+         greedily added an initializer to this variable (in build_init_assign)
+         even though the max-stack-var-size indicates the variable should be
+         static. Therefore we rip out the automatic initializer here and
+         replace it with a static one.  */
+      gfc_symtree *st = gfc_find_symtree (sym->ns->sym_root, sym->name);
+      gfc_code *prev = NULL;
+      gfc_code *code = sym->ns->code;
+      while (code && code->op == EXEC_INIT_ASSIGN)
+        {
+          /* Look for an initializer meant for this symbol.  */
+          if (code->expr1->symtree == st)
+            {
+              if (prev)
+                prev->next = code->next;
+              else
+                sym->ns->code = code->next;
+
+              break;
+            }
+
+          prev = code;
+          code = code->next;
+        }
+      if (code && code->op == EXEC_INIT_ASSIGN)
+        {
+          /* Keep the init expression for a static initializer.  */
+          sym->value = code->expr2;
+          /* Cleanup the defunct code object, without freeing the init expr.  */
+          code->expr2 = NULL;
+          gfc_free_statement (code);
+          free (code);
+        }
+    }
 
   /* Handle threadprivate variables.  */
   if (sym->attr.threadprivate
@@ -693,14 +729,14 @@ gfc_get_module_backend_decl (gfc_symbol *sym)
 	  st->n.sym = sym;
 	  sym->refs++;
 	}
-      else if (sym->attr.flavor == FL_DERIVED)
+      else if (gfc_fl_struct (sym->attr.flavor))
 	{
 	  if (s && s->attr.flavor == FL_PROCEDURE)
 	    {
 	      gfc_interface *intr;
 	      gcc_assert (s->attr.generic);
 	      for (intr = s->generic; intr; intr = intr->next)
-		if (intr->sym->attr.flavor == FL_DERIVED)
+		if (gfc_fl_struct (intr->sym->attr.flavor))
 		  {
 		    s = intr->sym;
 		    break;
@@ -708,7 +744,12 @@ gfc_get_module_backend_decl (gfc_symbol *sym)
     	    }
 
 	  if (!s->backend_decl)
-	    s->backend_decl = gfc_get_derived_type (s);
+          {
+            if (s->attr.flavor == FL_UNION)
+              s->backend_decl = gfc_get_union_type (s);
+            else
+              s->backend_decl = gfc_get_derived_type (s);
+          }
 	  gfc_copy_dt_decls_ifequal (s, sym, true);
 	  return true;
 	}
@@ -1487,7 +1528,7 @@ gfc_get_symbol_decl (gfc_symbol * sym)
   if (TREE_STATIC (decl)
       && !(sym->attr.use_assoc && !intrinsic_array_parameter)
       && (sym->attr.save || sym->ns->proc_name->attr.is_main_program
-	  || gfc_option.flag_max_stack_var_size == 0
+	  || !gfc_can_put_var_on_stack (DECL_SIZE_UNIT (decl))
 	  || sym->attr.data || sym->ns->proc_name->attr.flavor == FL_MODULE)
       && (gfc_option.coarray != GFC_FCOARRAY_LIB
 	  || !sym->attr.codimension || sym->attr.allocatable))
@@ -4046,7 +4087,7 @@ gfc_create_module_variable (gfc_symbol * sym)
       && sym->ts.type == BT_DERIVED)
     sym->backend_decl = gfc_typenode_for_spec (&(sym->ts));
 
-  if (sym->attr.flavor == FL_DERIVED
+  if (gfc_fl_struct (sym->attr.flavor)
       && sym->backend_decl
       && TREE_CODE (sym->backend_decl) == RECORD_TYPE)
     {
@@ -4265,7 +4306,7 @@ check_constant_initializer (gfc_expr *expr, gfc_typespec *ts, bool array,
     }
   else switch (ts->type)
     {
-    case BT_DERIVED:
+    case_struct_bt:
       if (expr->expr_type != EXPR_STRUCTURE)
 	return false;
       cm = expr->ts.u.derived->components;
diff --git a/gcc/fortran/trans-expr.c b/gcc/fortran/trans-expr.c
index 456b2ceadff..ccb611dd06e 100644
--- a/gcc/fortran/trans-expr.c
+++ b/gcc/fortran/trans-expr.c
@@ -1550,6 +1550,7 @@ gfc_conv_component_ref (gfc_se * se, gfc_ref * ref)
   tree tmp;
   tree decl;
   tree field;
+  tree context;
 
   c = ref->u.c.component;
 
@@ -1560,15 +1561,20 @@ gfc_conv_component_ref (gfc_se * se, gfc_ref * ref)
   field = c->backend_decl;
   gcc_assert (field && TREE_CODE (field) == FIELD_DECL);
   decl = se->expr;
+  context = DECL_FIELD_CONTEXT (field);
 
   /* Components can correspond to fields of different containing
      types, as components are created without context, whereas
      a concrete use of a component has the type of decl as context.
      So, if the type doesn't match, we search the corresponding
      FIELD_DECL in the parent type.  To not waste too much time
-     we cache this result in norestrict_decl.  */
+     we cache this result in norestrict_decl. 
+     On the other hand, if the context is a UNION or a MAP (a
+     RECORD_TYPE within a UNION_TYPE) always use the given FIELD_DECL. */
 
-  if (DECL_FIELD_CONTEXT (field) != TREE_TYPE (decl))
+  if (context != TREE_TYPE (decl) 
+      && !(   TREE_CODE (TREE_TYPE (field)) == UNION_TYPE /* field is union */
+           || TREE_CODE (context) == UNION_TYPE))         /* field is map */
     {
       tree f2 = c->norestrict_decl;
       if (!f2 || DECL_FIELD_CONTEXT (f2) != TREE_TYPE (decl))
@@ -5686,8 +5692,8 @@ gfc_conv_initializer (gfc_expr * expr, gfc_typespec * ts, tree type,
     {
       switch (ts->type)
 	{
-	case BT_DERIVED:
 	case BT_CLASS:
+        case_struct_bt:
 	  gfc_init_se (&se, NULL);
 	  if (ts->type == BT_CLASS && expr->expr_type == EXPR_NULL)
 	    gfc_conv_structure (&se, gfc_class_null_initializer(ts, expr), 1);
@@ -5831,7 +5837,7 @@ gfc_trans_alloc_subarray_assign (tree dest, gfc_component * cm,
   gfc_add_modify (&block, dest, se.expr);
 
   /* Deal with arrays of derived types with allocatable components.  */
-  if (cm->ts.type == BT_DERIVED
+  if (gfc_bt_struct (cm->ts.type)
 	&& cm->ts.u.derived->attr.alloc_comp)
     tmp = gfc_copy_alloc_comp (cm->ts.u.derived,
 			       se.expr, dest,
@@ -6018,7 +6024,7 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr)
 	  gfc_add_expr_to_block (&block, tmp);
 	}
     }
-  else if (expr->ts.type == BT_DERIVED)
+  else if (gfc_bt_struct (cm->ts.type))
     {
       if (expr->expr_type != EXPR_STRUCTURE)
 	{
@@ -6125,6 +6131,23 @@ gfc_conv_structure (gfc_se * se, gfc_expr * expr, int init)
       return;
     }
 
+  /* Though unions appear to have multiple map components, they must only
+     have a single initializer since each map overlaps. */
+  if (expr->ts.type == BT_UNION)
+  {
+    c = gfc_constructor_first (expr->value.constructor);
+    cm = c->n.component;
+    val = gfc_conv_initializer (c->expr, &expr->ts,
+                                TREE_TYPE (cm->backend_decl),
+                                cm->attr.dimension, cm->attr.pointer,
+                                cm->attr.proc_pointer);
+    val = unshare_expr_without_location (val);
+
+    /* Append it to the constructor list.  */
+    CONSTRUCTOR_APPEND_ELT (v, cm->backend_decl, val);
+    goto finish;
+  }
+
   cm = expr->ts.u.derived->components;
 
   for (c = gfc_constructor_first (expr->value.constructor);
@@ -6165,6 +6188,7 @@ gfc_conv_structure (gfc_se * se, gfc_expr * expr, int init)
 	  CONSTRUCTOR_APPEND_ELT (v, cm->backend_decl, val);
 	}
     }
+finish:
   se->expr = build_constructor (type, v);
   if (init)
     TREE_CONSTANT (se->expr) = 1;
@@ -6838,7 +6862,7 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,
       gfc_trans_string_copy (&block, llen, lse->expr, ts.kind, rlen,
 			     rse->expr, ts.kind);
     }
-  else if (ts.type == BT_DERIVED && ts.u.derived->attr.alloc_comp)
+  else if (gfc_bt_struct (ts.type) && ts.u.derived->attr.alloc_comp)
     {
       cond = NULL_TREE;
 
@@ -6881,7 +6905,7 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,
 	  gfc_add_expr_to_block (&block, tmp);
 	}
     }
-  else if (ts.type == BT_DERIVED || ts.type == BT_CLASS)
+  else if (gfc_bt_struct (ts.type) || ts.type == BT_CLASS)
     {
       gfc_add_block_to_block (&block, &lse->pre);
       gfc_add_block_to_block (&block, &rse->pre);
@@ -7892,7 +7916,7 @@ copyable_array_p (gfc_expr * expr)
     case BT_CHARACTER:
       return false;
 
-    case BT_DERIVED:
+    case_struct_bt:
       return !expr->ts.u.derived->attr.alloc_comp;
 
     default:
diff --git a/gcc/fortran/trans-intrinsic.c b/gcc/fortran/trans-intrinsic.c
index 273c86ff4d7..38fd8f4c2d5 100644
--- a/gcc/fortran/trans-intrinsic.c
+++ b/gcc/fortran/trans-intrinsic.c
@@ -97,6 +97,12 @@ gfc_intrinsic_map_t;
     BUILT_IN_C ## ID ## L, true, true, true, NAME, NULL_TREE, NULL_TREE, \
     NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE},
 
+#define MATH_ALIAS_BUILTIN(NEWID, ID, NAME, TYPE) \
+  { GFC_ISYM_ ## NEWID, BUILT_IN_ ## ID ## F, BUILT_IN_ ## ID, \
+    BUILT_IN_ ## ID ## L, END_BUILTINS, END_BUILTINS, END_BUILTINS, \
+    true, false, true, NAME, NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE, \
+    NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE},
+
 #define LIB_FUNCTION(ID, NAME, HAVE_COMPLEX) \
   { GFC_ISYM_ ## ID, END_BUILTINS, END_BUILTINS, END_BUILTINS, \
     END_BUILTINS, END_BUILTINS, END_BUILTINS, \
@@ -125,6 +131,7 @@ static GTY(()) gfc_intrinsic_map_t gfc_intrinsic_map[] =
 };
 #undef OTHER_BUILTIN
 #undef LIB_FUNCTION
+#undef MATH_ALIAS_BUILTIN
 #undef DEFINE_MATH_BUILTIN
 #undef DEFINE_MATH_BUILTIN_C
 
@@ -654,6 +661,7 @@ gfc_build_intrinsic_lib_fndecls (void)
 
 #define DEFINE_MATH_BUILTIN(ID, NAME, ARGTYPE)
 #define DEFINE_MATH_BUILTIN_C(ID, NAME, ARGTYPE)
+#define MATH_ALIAS_BUILTIN(NEWID, ID, NAME, TYPE)
 #define LIB_FUNCTION(ID, NAME, HAVE_COMPLEX)
 
     /* Only these built-ins are actually needed here. These are used directly
@@ -667,6 +675,7 @@ gfc_build_intrinsic_lib_fndecls (void)
 
 #undef OTHER_BUILTIN
 #undef LIB_FUNCTION
+#undef MATH_ALIAS_BUILTIN
 #undef DEFINE_MATH_BUILTIN
 #undef DEFINE_MATH_BUILTIN_C
 
diff --git a/gcc/fortran/trans-io.c b/gcc/fortran/trans-io.c
index a11453d082d..231820169b3 100644
--- a/gcc/fortran/trans-io.c
+++ b/gcc/fortran/trans-io.c
@@ -1005,6 +1005,15 @@ gfc_trans_open (gfc_code * code)
     mask |= set_parameter_ref (&block, &post_block, var, IOPARM_open_newunit,
 			       p->newunit);
 
+  if (p->share)
+    mask |= set_string (&block, &post_block, var, IOPARM_open_share,
+                        p->share);
+
+  if (p->cc)
+    mask |= set_string (&block, &post_block, var, IOPARM_open_cc, p->cc);
+
+  mask |= set_parameter_const (&block, var, IOPARM_open_readonly, p->readonly);
+
   set_parameter_const (&block, var, IOPARM_common_flags, mask);
 
   if (p->unit)
@@ -1613,7 +1622,7 @@ transfer_namelist_element (stmtblock_t * block, const char * var_name,
       gfc_add_expr_to_block (block, tmp);
     }
 
-  if (ts->type == BT_DERIVED && ts->u.derived->components)
+  if (gfc_bt_struct (ts->type) && ts->u.derived->components)
     {
       gfc_component *cmp;
 
@@ -2149,7 +2158,7 @@ transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr, gfc_code * code)
 
       break;
 
-    case BT_DERIVED:
+    case_struct_bt:
       if (ts->u.derived->components == NULL)
 	return;
 
@@ -2268,7 +2277,7 @@ gfc_trans_transfer (gfc_code * code)
 	  gcc_assert (ref && ref->type == REF_ARRAY);
 	}
 
-      if (expr->ts.type != BT_DERIVED
+      if (!gfc_bt_struct (expr->ts.type)
 	    && ref && ref->next == NULL
 	    && !is_subref_array (expr))
 	{
diff --git a/gcc/fortran/trans-stmt.c b/gcc/fortran/trans-stmt.c
index 1d8588d6072..68cfb65c1fa 100644
--- a/gcc/fortran/trans-stmt.c
+++ b/gcc/fortran/trans-stmt.c
@@ -5471,7 +5471,7 @@ gfc_trans_deallocate (gfc_code *code)
 
       if (expr->rank || gfc_is_coarray (expr))
 	{
-	  if (expr->ts.type == BT_DERIVED && expr->ts.u.derived->attr.alloc_comp)
+	  if (gfc_bt_struct (expr->ts.type) && expr->ts.u.derived->attr.alloc_comp)
 	    {
 	      gfc_ref *ref;
 	      gfc_ref *last = NULL;
diff --git a/gcc/fortran/trans-types.c b/gcc/fortran/trans-types.c
index 30561ee7ecf..9430c5a5cec 100644
--- a/gcc/fortran/trans-types.c
+++ b/gcc/fortran/trans-types.c
@@ -1100,6 +1100,10 @@ gfc_typenode_for_spec (gfc_typespec * spec)
 	basetype = gfc_get_character_type (spec->kind, spec->u.cl);
       break;
 
+    case BT_UNION:
+      basetype = gfc_get_union_type (spec->u.derived);
+      break;
+
     case BT_DERIVED:
     case BT_CLASS:
       basetype = gfc_get_derived_type (spec->u.derived);
@@ -2323,6 +2327,61 @@ gfc_get_ppc_type (gfc_component* c)
   return build_pointer_type (build_function_type_list (t, NULL_TREE));
 }
 
+/* Build a tree node for a union type. Requires building each map
+   structure which is an element of the union. */
+
+tree
+gfc_get_union_type (gfc_symbol *un)
+{
+    gfc_component *map = NULL;
+    tree typenode = NULL, map_type = NULL, map_field = NULL;
+    tree *chain = NULL;
+
+    if (un->backend_decl)
+    {
+      if (TYPE_FIELDS (un->backend_decl) || un->attr.proc_pointer_comp)
+        return un->backend_decl;
+      else
+        typenode = un->backend_decl;
+    }
+    else
+    {
+      typenode = make_node (UNION_TYPE);
+      TYPE_NAME (typenode) = get_identifier (un->name);
+    }
+
+    /* Add each contained MAP as a field. */
+    for (map = un->components; map; map = map->next)
+    {
+        gcc_assert (map->ts.type == BT_DERIVED);
+
+        /* The map's type node, which is defined within this union's context. */
+        map_type = gfc_get_derived_type (map->ts.u.derived);
+        TYPE_CONTEXT (map_type) = typenode;
+
+        /* The map field's declaration. */
+        map_field = gfc_add_field_to_struct(typenode, get_identifier(map->name),
+                                            map_type, &chain);
+        if (map->loc.lb)
+          gfc_set_decl_location (map_field, &map->loc);
+        else if (un->declared_at.lb)
+          gfc_set_decl_location (map_field, &un->declared_at);
+
+        DECL_PACKED (map_field) |= TYPE_PACKED (typenode);
+        DECL_NAMELESS(map_field) = true;
+
+        /* We should never clobber another backend declaration for this map,
+           because each map component is unique. */
+        if (!map->backend_decl)
+          map->backend_decl = map_field;
+    }
+
+    un->backend_decl = typenode;
+    gfc_finish_type (typenode);
+
+    return typenode;
+}
+
 
 /* Build a tree node for a derived type.  If there are equal
    derived types, with different local names, these are built
@@ -2473,7 +2532,10 @@ gfc_get_derived_type (gfc_symbol * derived)
     return derived->backend_decl;
 
   /* Build the type member list. Install the newly created RECORD_TYPE
-     node as DECL_CONTEXT of each FIELD_DECL.  */
+     node as DECL_CONTEXT of each FIELD_DECL. In this case we must go
+     through only the top-level linked list of components so we correctly
+     build UNION_TYPE nodes for BT_UNION components. MAPs and other nested
+     types are built as part of gfc_get_union_type. */
   for (c = derived->components; c; c = c->next)
     {
       if (c->attr.proc_pointer)
diff --git a/gcc/fortran/trans.c b/gcc/fortran/trans.c
index d7bdf268a37..11e76d3c03f 100644
--- a/gcc/fortran/trans.c
+++ b/gcc/fortran/trans.c
@@ -1041,7 +1041,7 @@ gfc_build_final_call (gfc_typespec ts, gfc_expr *final_wrapper, gfc_expr *var,
   if (POINTER_TYPE_P (TREE_TYPE (final_fndecl)))
     final_fndecl = build_fold_indirect_ref_loc (input_location, final_fndecl);
 
-  if (ts.type == BT_DERIVED)
+  if (gfc_bt_struct (ts.type))
     {
       tree elem_size;
 
@@ -1186,7 +1186,7 @@ gfc_deallocate_scalar_with_status (tree pointer, tree status, bool can_fail,
   gfc_start_block (&non_null);
 
   /* Free allocatable components.  */
-  if (ts.type == BT_DERIVED && ts.u.derived->attr.alloc_comp)
+  if (gfc_bt_struct (ts.type) && ts.u.derived->attr.alloc_comp)
     {
       tmp = build_fold_indirect_ref_loc (input_location, pointer);
       tmp = gfc_deallocate_alloc_comp (ts.u.derived, tmp, 0);
diff --git a/gcc/testsuite/gfortran.dg/assert.inc b/gcc/testsuite/gfortran.dg/assert.inc
new file mode 100644
index 00000000000..40512b00393
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/assert.inc
@@ -0,0 +1,62 @@
+
+      subroutine assert(s, b)
+        character*(*) s
+        logical b
+        if (.not. b) then
+          print *, s
+          call abort
+        endif
+      endsubroutine
+
+      subroutine assertss(s, s1, s2)
+        character*(*) s, s1, s2
+        if (s1 /= s2) then
+          print *, s, ": expected ", s2, " but was ", s1
+          call abort
+        endif
+      endsubroutine
+
+      subroutine assertbb(s, b1, b2)
+        character*(*) s
+        integer(1) b1, b2
+        if (b1 .ne. b2) then
+          print *, s, ": expected ", b2, " but was ", b1
+          call abort
+        endif
+      endsubroutine
+
+      subroutine assertii(s, i1, i2)
+        character*(*) s
+        integer(2) i1, i2
+        if (i1 .ne. i2) then
+          print *, s, ": expected ", i2, " but was ", i1
+          call abort
+        endif
+      endsubroutine
+
+      subroutine assertll(s, l1, l2)
+        character*(*) s
+        integer(4) l1, l2
+        if (l1 .ne. l2) then
+          print *, s, ": expected ", l2, " but was ", l1
+          call abort
+        endif
+      endsubroutine
+
+      subroutine assertqq(s, q1, q2)
+        character*(*) s
+        integer(8) q1, q2
+        if (q1 .ne. q2) then
+          print *, s, ": expected ", q2, " but was ", q1
+          call abort
+        endif
+      endsubroutine
+
+      subroutine assertrr(s, r1, r2)
+        character*(*) s
+        real r1, r2
+        if (r1 .ne. r2) then
+          print *, s, ": expected ", r1, " but was ", r2
+          call abort
+        endif
+      endsubroutine
diff --git a/gcc/testsuite/gfortran.dg/auto_save_2.f90 b/gcc/testsuite/gfortran.dg/auto_save_2.f90
new file mode 100644
index 00000000000..0d39d484e52
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/auto_save_2.f90
@@ -0,0 +1,52 @@
+! { dg-do run }
+! { dg-options "-fno-automatic -finit-local-zero" }
+!
+! Make sure variables are saved with -fno-automatic except in
+! functions marked RECURSIVE, and that they are still initialized with
+! -finit-local-zero.
+!
+
+function f (x)
+implicit none
+  integer f, x
+  integer a ! should be SAVEd
+  a = a + x ! should increment by y every time
+  f = a
+  return
+endfunction
+
+recursive function g (x)
+implicit none
+  integer g, x
+  integer b ! should be automatic
+  b = b + x ! should be set to y every time
+  g = b
+  return
+endfunction
+
+implicit none
+integer f, g
+
+! Should return static value of a; accumulates y
+if ( f(3) .ne. 3 ) then
+  call abort ()
+endif
+if ( f(4) .ne. 7 ) then
+  call abort ()
+endif
+if ( f(2) .ne. 9 ) then
+  call abort ()
+endif
+
+! Should return automatic value of a; equal to y each time
+if ( g(3) .ne. 3 ) then
+  call abort ()
+endif
+if ( g(4) .ne. 4 ) then
+  call abort ()
+endif
+if ( g(2) .ne. 2 ) then
+  call abort ()
+endif
+
+end
diff --git a/gcc/testsuite/gfortran.dg/dec/README b/gcc/testsuite/gfortran.dg/dec/README
new file mode 100644
index 00000000000..56973d2c9f8
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/README
@@ -0,0 +1,12 @@
+This testsuite is for testing gfortran's support for the large suite of
+non-standard Digital Equipment Corporation (DEC) extensions.
+
+TODO:
+ o  Fix -fdec-io tests to test for correctness
+
+
+Copyright (C) 2004-2013 Free Software Foundation, Inc.
+
+Copying and distribution of this file, with or without modification,
+are permitted in any medium without royalty provided the copyright
+notice and this notice are preserved.
diff --git a/gcc/testsuite/gfortran.dg/dec/achar.f90 b/gcc/testsuite/gfortran.dg/dec/achar.f90
new file mode 100644
index 00000000000..eb49db896d9
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/achar.f90
@@ -0,0 +1,21 @@
+! { dg-do run }
+! { dg-options "-fbounds-check" }
+! Tests the fix for PR31257, in which achar caused an ICE because it had no
+! charlen.
+!
+! The code comes from http://www.star.le.ac.uk/~cgp/fortran.html (by Clive Page)
+! Reported by Thomas Koenig <tkoenig@gcc.gnu.org>
+!
+  if (any (Up ("AbCdEfGhIjKlM") .ne. (/"ABCDEFGHIJKLM"/))) call abort ()
+contains
+  Character (len=20) Function Up (string)
+    Character(len=*) string
+    Up =                                                                &
+     transfer(merge(achar(iachar(transfer(string,"x",len(string)))-     &
+     (ichar('a')-ichar('A')) ),                                         &
+     transfer(string,"x",len(string)) ,                                 &
+     transfer(string,"x",len(string)) >= "a" .and.                      &
+     transfer(string,"x",len(string)) <= "z"), repeat("x", len(string)))
+    return
+  end function Up
+end
diff --git a/gcc/testsuite/gfortran.dg/dec/assert.inc b/gcc/testsuite/gfortran.dg/dec/assert.inc
new file mode 100644
index 00000000000..40512b00393
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/assert.inc
@@ -0,0 +1,62 @@
+
+      subroutine assert(s, b)
+        character*(*) s
+        logical b
+        if (.not. b) then
+          print *, s
+          call abort
+        endif
+      endsubroutine
+
+      subroutine assertss(s, s1, s2)
+        character*(*) s, s1, s2
+        if (s1 /= s2) then
+          print *, s, ": expected ", s2, " but was ", s1
+          call abort
+        endif
+      endsubroutine
+
+      subroutine assertbb(s, b1, b2)
+        character*(*) s
+        integer(1) b1, b2
+        if (b1 .ne. b2) then
+          print *, s, ": expected ", b2, " but was ", b1
+          call abort
+        endif
+      endsubroutine
+
+      subroutine assertii(s, i1, i2)
+        character*(*) s
+        integer(2) i1, i2
+        if (i1 .ne. i2) then
+          print *, s, ": expected ", i2, " but was ", i1
+          call abort
+        endif
+      endsubroutine
+
+      subroutine assertll(s, l1, l2)
+        character*(*) s
+        integer(4) l1, l2
+        if (l1 .ne. l2) then
+          print *, s, ": expected ", l2, " but was ", l1
+          call abort
+        endif
+      endsubroutine
+
+      subroutine assertqq(s, q1, q2)
+        character*(*) s
+        integer(8) q1, q2
+        if (q1 .ne. q2) then
+          print *, s, ": expected ", q2, " but was ", q1
+          call abort
+        endif
+      endsubroutine
+
+      subroutine assertrr(s, r1, r2)
+        character*(*) s
+        real r1, r2
+        if (r1 .ne. r2) then
+          print *, s, ": expected ", r1, " but was ", r2
+          call abort
+        endif
+      endsubroutine
diff --git a/gcc/testsuite/gfortran.dg/dec/bijk_btest.f b/gcc/testsuite/gfortran.dg/dec/bijk_btest.f
new file mode 100644
index 00000000000..f21cb1a0ea5
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bijk_btest.f
@@ -0,0 +1,35 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-intrinsic-ints" }
+      !
+      ! Tests the extended integer formats on bitwise and other
+      ! functions (BIJK-prefixes).
+      !
+
+      PROGRAM MAIN
+      IMPLICIT NONE
+
+      INTEGER*1 :: IB = 9_1, BPOS = 3_1
+      INTEGER*2 :: II = 9_2, IPOS = 3_2
+      INTEGER*4 :: IJ = 9_4, JPOS = 3_4
+      INTEGER*8 :: IK = 9_8, KPOS = 3_8
+      INTEGER   :: I  = 9  ,  POS = 3
+
+      LOGICAL*1 :: LB
+      LOGICAL*2 :: LI
+      LOGICAL*4 :: LJ
+      LOGICAL*8 :: LK
+      LOGICAL   :: L
+
+      LB = BBTEST(IB, BPOS)
+      LI = BITEST(II, IPOS)
+      LJ = BJTEST(IJ, JPOS)
+      LK = BKTEST(IK, KPOS)
+      L  =  BTEST(I ,  POS)
+
+      LB = BBTEST(9_1, 3_1)
+      LI = BITEST(9_2, 3_2)
+      LJ = BJTEST(9_4, 3_4)
+      LK = BKTEST(9_8, 3_8)
+      L  =  BTEST(9  , 3  )
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bijk_float.f b/gcc/testsuite/gfortran.dg/dec/bijk_float.f
new file mode 100644
index 00000000000..deff9034dbf
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bijk_float.f
@@ -0,0 +1,28 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-intrinsic-ints" }
+      !
+      ! Tests the extended integer formats on bitwise and other
+      ! functions (BIJK-prefixes).
+      !
+
+      PROGRAM MAIN
+      IMPLICIT NONE
+
+      INTEGER*2 :: AI = 9_2
+      INTEGER*4 :: AJ = 9_4
+      INTEGER*8 :: AK = 9_8
+      INTEGER   :: A  = 9
+
+      REAL :: R
+
+      R = FLOATI(AI)
+      R = FLOATJ(AJ)
+      R = FLOATK(AK)
+      R = FLOAT (A )
+
+      R = FLOATI(9_2)
+      R = FLOATJ(9_4)
+      R = FLOATK(9_8)
+      R = FLOAT (9  )
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bijk_iabs.f b/gcc/testsuite/gfortran.dg/dec/bijk_iabs.f
new file mode 100644
index 00000000000..a7a553df0c0
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bijk_iabs.f
@@ -0,0 +1,29 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-intrinsic-ints" }
+      !
+      ! Tests the extended integer formats on bitwise and other
+      ! functions (BIJK-prefixes).
+      !
+
+      PROGRAM MAIN
+      IMPLICIT NONE
+
+      INTEGER*1 :: AB = -9_1, BB
+      INTEGER*2 :: AI = -9_2, BI
+      INTEGER*4 :: AJ = -9_4, BJ
+      INTEGER*8 :: AK = -9_8, BK
+      INTEGER   :: A  = -9  , B
+
+      BB =  BABS(AB)
+      BI = IIABS(AI)
+      BJ = JIABS(AJ)
+      BK = KIABS(AK)
+      B  =  IABS(A )
+
+      BB =  BABS(9_1)
+      BI = IIABS(9_2)
+      BJ = JIABS(9_4)
+      BK = KIABS(9_8)
+      B  =  IABS(9  )
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bijk_iand.f b/gcc/testsuite/gfortran.dg/dec/bijk_iand.f
new file mode 100644
index 00000000000..48fd07cdf14
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bijk_iand.f
@@ -0,0 +1,29 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-intrinsic-ints" }
+      !
+      ! Tests the extended integer formats on bitwise and other
+      ! functions (BIJK-prefixes).
+      !
+
+      PROGRAM MAIN
+      IMPLICIT NONE
+
+      INTEGER*1 :: AB = 9_1, BB = 3_1, CB
+      INTEGER*2 :: AI = 9_2, BI = 3_2, CI
+      INTEGER*4 :: AJ = 9_4, BJ = 3_4, CJ
+      INTEGER*8 :: AK = 9_8, BK = 3_8, CK
+      INTEGER   :: A  = 9  , B  = 3  , C
+
+      CB = BIAND(AB, BB)
+      CI = IIAND(AI, BI)
+      CJ = JIAND(AJ, BJ)
+      CK = KIAND(AK, BK)
+      C  =  IAND(A , B )
+
+      CB = BIAND(9_1, 3_1)
+      CI = IIAND(9_2, 3_2)
+      CJ = JIAND(9_4, 3_4)
+      CK = KIAND(9_8, 3_8)
+      C  =  IAND(9  , 3  )
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bijk_ibclr.f b/gcc/testsuite/gfortran.dg/dec/bijk_ibclr.f
new file mode 100644
index 00000000000..fccc6b4b6ff
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bijk_ibclr.f
@@ -0,0 +1,29 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-intrinsic-ints" }
+      !
+      ! Tests the extended integer formats on bitwise and other
+      ! functions (BIJK-prefixes).
+      !
+
+      PROGRAM MAIN
+      IMPLICIT NONE
+
+      INTEGER*1 :: IB = 9_1, BPOS = 3_1, CB
+      INTEGER*2 :: II = 9_2, IPOS = 3_2, CI
+      INTEGER*4 :: IJ = 9_4, JPOS = 3_4, CJ
+      INTEGER*8 :: IK = 9_8, KPOS = 3_8, CK
+      INTEGER   :: I  = 9  ,  POS = 3  , C
+
+      CB =  BBCLR(IB, BPOS)
+      CI = IIBCLR(II, IPOS)
+      CJ = JIBCLR(IJ, JPOS)
+      CK = KIBCLR(IK, KPOS)
+      C  =  IBCLR(I ,  POS)
+
+      CB =  BBCLR(9_1, 3_1)
+      CI = IIBCLR(9_2, 3_2)
+      CJ = JIBCLR(9_4, 3_4)
+      CK = KIBCLR(9_8, 3_8)
+      C  =  IBCLR(I ,  POS)
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bijk_ibset.f b/gcc/testsuite/gfortran.dg/dec/bijk_ibset.f
new file mode 100644
index 00000000000..5d39a0ad4d5
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bijk_ibset.f
@@ -0,0 +1,29 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-intrinsic-ints" }
+      !
+      ! Tests the extended integer formats on bitwise and other
+      ! functions (BIJK-prefixes).
+      !
+
+      PROGRAM MAIN
+      IMPLICIT NONE
+
+      INTEGER*1 :: IB = 9_1, BPOS = 3_1, CB
+      INTEGER*2 :: II = 9_2, IPOS = 3_2, CI
+      INTEGER*4 :: IJ = 9_4, JPOS = 3_4, CJ
+      INTEGER*8 :: IK = 9_8, KPOS = 3_8, CK
+      INTEGER   :: I  = 9  ,  POS = 3  , C
+
+      CB =  BBSET(IB, BPOS)
+      CI = IIBSET(II, IPOS)
+      CJ = JIBSET(IJ, JPOS)
+      CK = KIBSET(IK, KPOS)
+      C  =  IBSET(I ,  POS)
+
+      CB =  BBSET(9_1, 3_1)
+      CI = IIBSET(9_2, 3_2)
+      CJ = JIBSET(9_4, 3_4)
+      CK = KIBSET(9_8, 3_8)
+      C  =  IBSET(I ,  POS)
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bijk_ieor.f b/gcc/testsuite/gfortran.dg/dec/bijk_ieor.f
new file mode 100644
index 00000000000..f38ac9ef93b
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bijk_ieor.f
@@ -0,0 +1,29 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-intrinsic-ints" }
+      !
+      ! Tests the extended integer formats on bitwise and other
+      ! functions (BIJK-prefixes).
+      !
+
+      PROGRAM MAIN
+      IMPLICIT NONE
+
+      INTEGER*1 :: AB = 9_1, BB = 3_1, CB
+      INTEGER*2 :: AI = 9_2, BI = 3_2, CI
+      INTEGER*4 :: AJ = 9_4, BJ = 3_4, CJ
+      INTEGER*8 :: AK = 9_8, BK = 3_8, CK
+      INTEGER   :: A  = 9  , B  = 3  , C
+
+      CB = BIEOR(AB, BB)
+      CI = IIEOR(AI, BI)
+      CJ = JIEOR(AJ, BJ)
+      CK = KIEOR(AK, BK)
+      C  =  IEOR(A , B )
+
+      CB = BIEOR(9_1, 3_1)
+      CI = IIEOR(9_2, 3_2)
+      CJ = JIEOR(9_4, 3_4)
+      CK = KIEOR(9_8, 3_8)
+      C  =  IEOR(9  , 3  )
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bijk_ior.f b/gcc/testsuite/gfortran.dg/dec/bijk_ior.f
new file mode 100644
index 00000000000..70e9a2bd5c8
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bijk_ior.f
@@ -0,0 +1,29 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-intrinsic-ints" }
+      !
+      ! Tests the extended integer formats on bitwise and other
+      ! functions (BIJK-prefixes).
+      !
+
+      PROGRAM MAIN
+      IMPLICIT NONE
+
+      INTEGER*1 :: AB = 9_1, BB = 3_1, CB
+      INTEGER*2 :: AI = 9_2, BI = 3_2, CI
+      INTEGER*4 :: AJ = 9_4, BJ = 3_4, CJ
+      INTEGER*8 :: AK = 9_8, BK = 3_8, CK
+      INTEGER   :: A  = 9  , B  = 3  , C
+
+      CB = BIOR(AB, BB)
+      CI = IIOR(AI, BI)
+      CJ = JIOR(AJ, BJ)
+      CK = KIOR(AK, BK)
+      C  =  IOR(A , B )
+
+      CB = BIOR(9_1, 3_1)
+      CI = IIOR(9_2, 3_2)
+      CJ = JIOR(9_4, 3_4)
+      CK = KIOR(9_8, 3_8)
+      C  =  IOR(9  , 3  )
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bijk_mod.f b/gcc/testsuite/gfortran.dg/dec/bijk_mod.f
new file mode 100644
index 00000000000..6cf5822dd15
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bijk_mod.f
@@ -0,0 +1,29 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-intrinsic-ints" }
+      !
+      ! Tests the extended integer formats on bitwise and other
+      ! functions (BIJK-prefixes).
+      !
+
+      PROGRAM MAIN
+      IMPLICIT NONE
+
+      INTEGER*1 :: AB = 9_1, BB = 3_1, CB
+      INTEGER*2 :: AI = 9_2, BI = 3_2, CI
+      INTEGER*4 :: AJ = 9_4, BJ = 3_4, CJ
+      INTEGER*8 :: AK = 9_8, BK = 3_8, CK
+      INTEGER   :: A  = 9  , B  = 3  , C
+
+      CB = BMOD(AB, BB)
+      CI = IMOD(AI, BI)
+      CJ = JMOD(AJ, BJ)
+      CK = KMOD(AK, BK)
+      C  =  MOD(A , B )
+
+      CB = BMOD(9_1, 3_1)
+      CI = IMOD(9_2, 3_2)
+      CJ = JMOD(9_4, 3_4)
+      CK = KMOD(9_8, 3_8)
+      C  =  MOD(9  , 3  )
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_and1.f b/gcc/testsuite/gfortran.dg/dec/bits_and1.f
new file mode 100644
index 00000000000..eb184aeeecf
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_and1.f
@@ -0,0 +1,29 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*1 A, B, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 3
+      B = 5
+      C = 1
+      
+      OP     = A .and. B
+      FUNC   = iand(A, B)
+      OP_C   = 3 .and. 5
+      FUNC_C = iand(3, 5)
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ",  C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_and2.f b/gcc/testsuite/gfortran.dg/dec/bits_and2.f
new file mode 100644
index 00000000000..53205a274ba
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_and2.f
@@ -0,0 +1,29 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*2 A, B, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 3
+      B = 5
+      C = 1
+      
+      OP     = A .and. B
+      FUNC   = iand(A, B)
+      OP_C   = 3 .and. 5
+      FUNC_C = iand(3, 5)
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ",  C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_and4.f b/gcc/testsuite/gfortran.dg/dec/bits_and4.f
new file mode 100644
index 00000000000..968f85a7643
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_and4.f
@@ -0,0 +1,29 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*4 A, B, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 3
+      B = 5
+      C = 1
+      
+      OP     = A .and. B
+      FUNC   = iand(A, B)
+      OP_C   = 3 .and. 5
+      FUNC_C = iand(3, 5)
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ",  C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_and8.f b/gcc/testsuite/gfortran.dg/dec/bits_and8.f
new file mode 100644
index 00000000000..c5b9383f9ea
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_and8.f
@@ -0,0 +1,29 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*8 A, B, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 3
+      B = 5
+      C = 1
+      
+      OP     = A .and. B
+      FUNC   = iand(A, B)
+      OP_C   = 3 .and. 5
+      FUNC_C = iand(3, 5)
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ",  C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_eqv1.f b/gcc/testsuite/gfortran.dg/dec/bits_eqv1.f
new file mode 100644
index 00000000000..0e271f71f27
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_eqv1.f
@@ -0,0 +1,29 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*1 A, B, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 3
+      B = 5
+      C = -7
+      
+      OP     = A .eqv. B
+      FUNC   = not(ieor(A, B))
+      OP_C   = 3 .eqv. 5
+      FUNC_C = not(ieor(3, 5))
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ",  C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_eqv2.f b/gcc/testsuite/gfortran.dg/dec/bits_eqv2.f
new file mode 100644
index 00000000000..fc30234848a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_eqv2.f
@@ -0,0 +1,29 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*2 A, B, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 3
+      B = 5
+      C = -7
+      
+      OP     = A .eqv. B
+      FUNC   = not(ieor(A, B))
+      OP_C   = 3 .eqv. 5
+      FUNC_C = not(ieor(3, 5))
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ",  C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_eqv4.f b/gcc/testsuite/gfortran.dg/dec/bits_eqv4.f
new file mode 100644
index 00000000000..76802b81ec6
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_eqv4.f
@@ -0,0 +1,29 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*4 A, B, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 3
+      B = 5
+      C = -7
+      
+      OP     = A .eqv. B
+      FUNC   = not(ieor(A, B))
+      OP_C   = 3 .eqv. 5
+      FUNC_C = not(ieor(3, 5))
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ",  C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_eqv8.f b/gcc/testsuite/gfortran.dg/dec/bits_eqv8.f
new file mode 100644
index 00000000000..f9804cbe9cd
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_eqv8.f
@@ -0,0 +1,29 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*8 A, B, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 3
+      B = 5
+      C = -7
+      
+      OP     = A .eqv. B
+      FUNC   = not(ieor(A, B))
+      OP_C   = 3 .eqv. 5
+      FUNC_C = not(ieor(3, 5))
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ",  C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_neqv1.f b/gcc/testsuite/gfortran.dg/dec/bits_neqv1.f
new file mode 100644
index 00000000000..9463ad33522
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_neqv1.f
@@ -0,0 +1,29 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*1 A, B, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 3
+      B = 5
+      C = 6
+      
+      OP     = A .neqv. B
+      FUNC   = ieor(A, B)
+      OP_C   = 3 .neqv. 5
+      FUNC_C = ieor(3, 5)
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ",  C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_neqv2.f b/gcc/testsuite/gfortran.dg/dec/bits_neqv2.f
new file mode 100644
index 00000000000..cc0dca41254
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_neqv2.f
@@ -0,0 +1,29 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*2 A, B, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 3
+      B = 5
+      C = 6
+      
+      OP     = A .neqv. B
+      FUNC   = ieor(A, B)
+      OP_C   = 3 .neqv. 5
+      FUNC_C = ieor(3, 5)
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ",  C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_neqv4.f b/gcc/testsuite/gfortran.dg/dec/bits_neqv4.f
new file mode 100644
index 00000000000..e5eb3a7903e
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_neqv4.f
@@ -0,0 +1,29 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*4 A, B, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 3
+      B = 5
+      C = 6
+      
+      OP     = A .neqv. B
+      FUNC   = ieor(A, B)
+      OP_C   = 3 .neqv. 5
+      FUNC_C = ieor(3, 5)
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ",  C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_neqv8.f b/gcc/testsuite/gfortran.dg/dec/bits_neqv8.f
new file mode 100644
index 00000000000..1878e9941f5
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_neqv8.f
@@ -0,0 +1,29 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*8 A, B, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 3
+      B = 5
+      C = 6
+      
+      OP     = A .neqv. B
+      FUNC   = ieor(A, B)
+      OP_C   = 3 .neqv. 5
+      FUNC_C = ieor(3, 5)
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ",  C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_not1.f b/gcc/testsuite/gfortran.dg/dec/bits_not1.f
new file mode 100644
index 00000000000..4bd46a722fc
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_not1.f
@@ -0,0 +1,28 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*1 A, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 4
+      C = -5
+      
+      OP     = .not. A
+      FUNC   = not(A)
+      OP_C   = .not. 4
+      FUNC_C = not(4)
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ", C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_not2.f b/gcc/testsuite/gfortran.dg/dec/bits_not2.f
new file mode 100644
index 00000000000..11926d2aff7
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_not2.f
@@ -0,0 +1,28 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*2 A, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 4
+      C = -5
+      
+      OP     = .not. A
+      FUNC   = not(A)
+      OP_C   = .not. 4
+      FUNC_C = not(4)
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ", C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_not4.f b/gcc/testsuite/gfortran.dg/dec/bits_not4.f
new file mode 100644
index 00000000000..13dc8749ed2
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_not4.f
@@ -0,0 +1,28 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*4 A, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 4
+      C = -5
+      
+      OP     = .not. A
+      FUNC   = not(A)
+      OP_C   = .not. 4
+      FUNC_C = not(4)
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ", C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_not8.f b/gcc/testsuite/gfortran.dg/dec/bits_not8.f
new file mode 100644
index 00000000000..6b498d808c1
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_not8.f
@@ -0,0 +1,28 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*8 A, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 4
+      C = -5
+      
+      OP     = .not. A
+      FUNC   = not(A)
+      OP_C   = .not. 4
+      FUNC_C = not(4)
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ", C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_or1.f b/gcc/testsuite/gfortran.dg/dec/bits_or1.f
new file mode 100644
index 00000000000..83011c022cc
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_or1.f
@@ -0,0 +1,29 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*1 A, B, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 3
+      B = 5
+      C = 7
+      
+      OP     = A .or. B
+      FUNC   = ior(A, B)
+      OP_C   = 3 .or. 5
+      FUNC_C = ior(3, 5)
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ",  C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_or2.f b/gcc/testsuite/gfortran.dg/dec/bits_or2.f
new file mode 100644
index 00000000000..027f5709b48
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_or2.f
@@ -0,0 +1,29 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*2 A, B, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 3
+      B = 5
+      C = 7
+      
+      OP     = A .or. B
+      FUNC   = ior(A, B)
+      OP_C   = 3 .or. 5
+      FUNC_C = ior(3, 5)
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ",  C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_or4.f b/gcc/testsuite/gfortran.dg/dec/bits_or4.f
new file mode 100644
index 00000000000..01966c0e97e
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_or4.f
@@ -0,0 +1,29 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*4 A, B, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 3
+      B = 5
+      C = 7
+      
+      OP     = A .or. B
+      FUNC   = ior(A, B)
+      OP_C   = 3 .or. 5
+      FUNC_C = ior(3, 5)
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ",  C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_or8.f b/gcc/testsuite/gfortran.dg/dec/bits_or8.f
new file mode 100644
index 00000000000..66feb6ac835
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_or8.f
@@ -0,0 +1,29 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*8 A, B, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 3
+      B = 5
+      C = 7
+      
+      OP     = A .or. B
+      FUNC   = ior(A, B)
+      OP_C   = 3 .or. 5
+      FUNC_C = ior(3, 5)
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ",  C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/buffer.inc b/gcc/testsuite/gfortran.dg/dec/buffer.inc
new file mode 100644
index 00000000000..7a128c40467
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/buffer.inc
@@ -0,0 +1,40 @@
+	STRUCTURE /BUFFER/
+	UNION
+	 MAP
+	  byte		bbuf(L_bbuf)
+	 END MAP
+	 MAP
+	  character*8	abuf(L_bbuf/8)
+	 END MAP
+	 MAP
+	  integer*2	ibuf(L_bbuf/2)
+	 END MAP
+	 MAP
+	  integer*4	lbuf(L_bbuf/4)
+	 END MAP
+	 MAP
+	  real*4	fbuf(L_bbuf/4)
+	 END MAP
+!if !_PFC
+	 MAP
+	  integer*8	xbuf(L_bbuf/8)
+	 END MAP
+!endif
+	 MAP
+	  real*8	dbuf(L_bbuf/8)
+	 END MAP
+	 MAP
+	  complex*8	cfbuf(L_bbuf/8)
+	 END MAP
+	 MAP
+	  complex*16	cdbuf(L_bbuf/16)
+	 END MAP
+	 MAP
+!if _CNVX
+!
+!else
+	  character*(L_bbuf)  sbuf		! Sun/OSF/SOL/IRIX Fortran
+!endif
+	 END MAP
+	END UNION
+	END STRUCTURE
diff --git a/gcc/testsuite/gfortran.dg/dec/cray_assumed.f b/gcc/testsuite/gfortran.dg/dec/cray_assumed.f
new file mode 100644
index 00000000000..cffd04a5fb3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/cray_assumed.f
@@ -0,0 +1,15 @@
+      ! { dg-do compile }
+      ! { dg-options "-fcray-pointer" }
+      !
+      ! Allow assumed-size arrays which are derived-type Cray pointees.
+      !
+      program main
+
+      type test
+        integer*4 i
+      end type
+
+      type (test) y(*)
+      pointer (y_ptr, y)
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/dlines.f b/gcc/testsuite/gfortran.dg/dec/dlines.f
new file mode 100644
index 00000000000..41341309d26
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dlines.f
@@ -0,0 +1,18 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec" }
+      !
+      ! Test the recognition of debug lines as comments with -fdec.
+      !
+      program main
+
+      character*32 a, b
+
+      a = "debug lines"
+      b = "are comments"
+
+D     a = "no comments"
+D     b = "for these debug lines"
+
+      print *, a, b
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/dot1.f b/gcc/testsuite/gfortran.dg/dec/dot1.f
new file mode 100644
index 00000000000..5094c2c83a7
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot1.f
@@ -0,0 +1,19 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-member-dot" }
+      !
+      ! This should compile with -fdec-member-dot.
+      ! This tests to make sure operators beginning with '.' are not interpreted
+      ! as structure member accesses.
+      !
+      ! No output expected here.
+        program main
+
+        LOGICAL x, y, z
+        x = .TRUE.
+        y = .FALSE.
+        z = .FALSE.
+
+        if ( x .AND. y .OR. z ) then
+        endif
+
+        end program
diff --git a/gcc/testsuite/gfortran.dg/dec/dot10.f b/gcc/testsuite/gfortran.dg/dec/dot10.f
new file mode 100644
index 00000000000..0f2b25ae1c1
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot10.f
@@ -0,0 +1,40 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-member-dot" }
+      !
+      ! This should compile with -fdec-member-dot.
+      !
+      ! Tests whether integer literals as operands inhibit recognizing '.' as
+      ! a member separator. 
+      !
+      ! Output should be "pass".
+      PROGRAM MAIN
+      TYPE t
+          INTEGER :: i
+          INTEGER :: j
+      END TYPE
+
+      INTEGER :: tmp1 = 0
+      INTEGER :: tmp2 = 1
+      TYPE (t) tmp3
+      tmp3.i = 0
+      tmp3.j = 1
+
+      if     ( .not. (tmp1.eq.0)   ) then
+          print *, "FAIL!!!! 0"
+          call abort
+
+      elseif ( .not. (1.eq.tmp2)   ) then
+          print *, "FAIL!!!! 1"
+          call abort
+
+      elseif ( .not. (tmp3.i.eq.0) ) then
+          print *, "FAIL!!!! ->0"
+          call abort
+
+      elseif ( .not. (1.eq.tmp3.j) ) then
+          print *, "FAIL!!!! ->1"
+          call abort
+
+      endif
+
+      END PROGRAM MAIN
diff --git a/gcc/testsuite/gfortran.dg/dec/dot11.f b/gcc/testsuite/gfortran.dg/dec/dot11.f
new file mode 100644
index 00000000000..248f818f3bf
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot11.f
@@ -0,0 +1,40 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-member-dot" }
+      !
+      ! This should compile with -fdec-member-dot.
+      !
+      ! Tests whether string literals as operands inhibit recognizing '.' as
+      ! a member separator. 
+      !
+      ! Output should be "pass".
+      PROGRAM MAIN
+      TYPE t
+          CHARACTER*20 :: a
+          CHARACTER*20 :: b
+      END TYPE
+
+      CHARACTER*20 :: tmp1 = "HELLO"
+      CHARACTER*20 :: tmp2 = "GOODBYE"
+      TYPE (t) tmp3
+      tmp3.a = "HELLO"
+      tmp3.b = "GOODBYE"
+
+      if     ( .not. (tmp1.eq."HELLO")   ) then
+          print *, "FAIL!!!! Hello"
+          call abort
+
+      elseif ( .not. ("GOODBYE".eq.tmp2)   ) then
+          print *, "FAIL!!!! Goodbye"
+          call abort
+
+      elseif ( .not. (tmp3.a.eq."HELLO") ) then
+          print *, "FAIL!!!! ->Hello"
+          call abort
+
+      elseif ( .not. ("GOODBYE".eq.tmp3.b) ) then
+          print *, "FAIL!!!! ->Goodbye"
+          call abort
+
+      endif
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/dot12.f b/gcc/testsuite/gfortran.dg/dec/dot12.f
new file mode 100644
index 00000000000..395fc145d2d
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot12.f
@@ -0,0 +1,31 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-member-dot" }
+      !
+      ! This should compile with -fdec-member-dot.
+      ! This tests the precedence between member accesses and intrinsic
+      ! operators.
+      !
+      ! "x.and.y" should be interpreted as the nested access
+      ! (x->and)->y rather than the logical operation and(x,y). The result
+      ! should be OR'd with z. 
+      !
+      ! The output is unimportant; if the precedence described above is not
+      ! recognized, the program will fail to compile.
+      program main
+
+      TYPE bob
+          LOGICAL y
+      END TYPE
+
+      TYPE item
+          LOGICAL b
+          TYPE(bob) and
+      END TYPE
+
+      TYPE(item) x, y
+      LOGICAL z
+
+      if ( x .AND. y .OR. z ) then
+      endif
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/dot13.f b/gcc/testsuite/gfortran.dg/dec/dot13.f
new file mode 100644
index 00000000000..4642871eb9d
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot13.f
@@ -0,0 +1,47 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-member-dot" }
+      !
+      ! This is a horrible example of how twisted Fortran is:
+      ! "X.AND.AND.AND.AND" resolves to (X.AND.AND) .AND. (AND)
+      ! because ".AND." is defined to take (LOGICAL, T) parameters 
+      ! where "X.AND.AND" is type LOGICAL and "AND" is type T.
+      ! Without the knowledge of the type of parameters expected by the
+      ! user-defined ".AND.", this would be completely ambiguous.
+      module mod
+
+      TYPE t
+          logical and
+      END TYPE
+        
+      interface operator (.and.)
+          module procedure a
+      end interface operator (.and.)
+
+      contains
+
+      function a(x, y)
+          type(t), intent (in) :: x
+          logical, intent (in) :: y
+          logical a
+          print *, "called and"
+          a = (.not. x%and) .and. (.not. y)
+          return
+      end function a
+
+      end module mod
+
+      use mod
+
+      TYPE(t) :: x
+      LOGICAL  :: and
+      LOGICAL :: i
+      x.and = .true.
+      and   = .true.
+
+      i = x.and.and ! MUHAHAHAH this makes ifort (11.1) segfault!!!!
+
+      if ( i ) then ! (x->and) .AND. (z)
+          print *, .true.
+      endif
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/dot2.f b/gcc/testsuite/gfortran.dg/dec/dot2.f
new file mode 100644
index 00000000000..8f02f41d54d
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot2.f
@@ -0,0 +1,9 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-member-dot" }
+      !
+      ! Make sure logical names aren't interpreted as member accesses.
+      !
+      PROGRAM MAIN
+      LOGICAL :: AND
+      AND = AND.AND.AND.AND.AND
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/dot3.f b/gcc/testsuite/gfortran.dg/dec/dot3.f
new file mode 100644
index 00000000000..a29b1620eb0
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot3.f
@@ -0,0 +1,47 @@
+! { dg-do run }
+! { dg-options "-fdec-member-dot" }
+!
+! This should compile with -fdec-member-dot.
+! This tests the precedence between member accesses and intrinsic
+! operators.
+!
+! The first expression t2.eq.i should be evaluated as (t2->eq)->i
+! and return 0. The second expression (t2).eq.i should be evaluated
+! as the operation eq(t2,i) and call eq_func resulting in -10.
+       include 'assert.inc'
+       module mod
+       type T1_t
+           integer :: i
+       end type T1_t
+       type T2_t
+           type (T1_t) :: eq
+           integer :: i
+       end type T2_t
+        
+       interface operator (.eq.)
+           module procedure eq_func
+       end interface operator (.eq.)
+
+       contains
+
+       function eq_func(t2, i) result (rslt)
+           type(T2_t), intent (in) :: t2
+           integer, intent (in) :: i
+           rslt = t2%eq%i + i
+       end function eq_func
+
+       end module mod
+
+       use mod
+
+       type(T2_t) :: t2
+       integer :: i,j
+       t2%eq%i = 2
+       t2%i = -10
+       i = -10
+       j = t2 . eq . i    ! t2->eq->i
+       call assertll ("t2.eq.i", j, 2)
+       j = (t2) . eq . i  ! eq_func(t2, i)
+       call assertll ("(t2).eq.i", j, -8)
+       
+       end program
diff --git a/gcc/testsuite/gfortran.dg/dec/dot4.f b/gcc/testsuite/gfortran.dg/dec/dot4.f
new file mode 100644
index 00000000000..2900565358e
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot4.f
@@ -0,0 +1,17 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-member-dot" }
+      !
+      ! This should compile with -fdec-member-dot.
+      ! Test to make sure initializers and operators beginning with '.'
+      ! are not interpreted as structure member accesses.
+      ! Output should be "T T", and this should compile with -fdec-member-dot.
+      include 'assert.inc'
+      program main
+      implicit none
+
+      logical :: b = .TRUE.
+      logical :: c = .TRUE.
+      call assert ("b.eqv.c", b.eqv.c)
+      call assert ("(b).eqv.c", (b).eqv.c)
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/dot5.f b/gcc/testsuite/gfortran.dg/dec/dot5.f
new file mode 100644
index 00000000000..42979092dc8
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot5.f
@@ -0,0 +1,41 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-member-dot" }
+      !
+      ! This should compile with -fdec-member-dot.
+      ! This tests the precedence between member accesses and intrinsic
+      ! operators.
+      !
+      ! This is similar to dot-3, but t2 has no member 'eq' so t2.eq.i
+      ! should always be interpreted as eq(t2,i).
+      include 'assert.inc'
+      module mod
+       type T2_t
+           integer :: i
+       end type T2_t
+        
+       interface operator (.eq.)
+           module procedure eq_func
+       end interface operator (.eq.)
+
+       contains
+
+       function eq_func(t2, i) result (rslt)
+           type(T2_t), intent (in) :: t2
+           integer, intent (in) :: i
+           rslt = t2%i + i
+       end function eq_func
+
+       end module mod
+
+       use mod
+
+       type(T2_t) :: t2
+       integer :: i,j
+       i = 0
+       t2%i = -10
+       j = t2.eq.i    ! eq_func(t2, i)
+       call assertll ("t2.eq.i", j, -10)
+       j = (t2).eq.i  ! eq_func(t2, i)
+       call assertll ("(t2).eq.i", j, -10)
+
+       end program
diff --git a/gcc/testsuite/gfortran.dg/dec/dot6.f b/gcc/testsuite/gfortran.dg/dec/dot6.f
new file mode 100644
index 00000000000..28ebb26e5fb
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot6.f
@@ -0,0 +1,71 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-member-dot" }
+      !
+      ! This should compile with -fdec-member-dot.
+      ! This tests the precedence between member accesses, intrinsic
+      ! operators, and user-defined operators.
+      !
+      ! (1) t2.eq.i     should be the member access (t2->eq)->i
+      ! (2) (t2).eq.i   should be the operation eq(t2, i)
+      ! (3) t2.test.i   is the operation test(t2, i) (because Intel does that)
+      ! (4) (t2).test.i is still the operation test(t2, i) (ditto)
+      !
+      ! The output should be:
+      ! 1
+      ! 5
+      ! 6
+      ! 6
+      include 'assert.inc'
+      module mod
+      type T1_t
+          integer :: i
+      end type T1_t
+      type T2_t
+          integer :: i
+          type (T1_t) :: eq
+          type (T1_t) :: test
+      end type T2_t
+       
+      interface operator (.eq.)
+          module procedure eq_func
+      end interface operator (.eq.)
+
+      interface operator (.test.)
+          module procedure tstfunc
+      end interface operator (.test.)
+
+      contains
+
+      function eq_func(t2, i)
+          type(T2_t), intent (in) :: t2
+          integer, intent (in) :: i
+          integer eq_func
+          eq_func = t2%eq%i + i
+          return
+      end function eq_func
+
+      function tstfunc(t1, i)
+          type(T2_t), intent (in) :: t1
+          integer, intent (in) :: i
+          integer tstfunc
+          tstfunc = t1%i + i
+          return
+      end function tstfunc
+
+      end module mod
+
+      use mod
+
+      type(T2_t) :: t2
+      integer :: i
+      t2%eq%i = 1
+      t2%i = 2
+      t2%test%i = 3
+      i = 4
+
+      call assertll ("t2.eq.i",      t2  .eq. i, 1) ! (1) t2->eq->i = 1
+      call assertll ("(t2).eq.i",   (t2) .eq. i, 5) ! (2) eq_func(t2,i) = 5
+      call assertll ("t2.test.i",    t2 .test.i, 6) ! (3) tstfunc(t2,i) = 6
+      call assertll ("(t2).test.i", (t2).test.i, 6) ! (4) tstfunc(t2,i) = 6
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/dot7.f b/gcc/testsuite/gfortran.dg/dec/dot7.f
new file mode 100644
index 00000000000..8ef658c981f
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot7.f
@@ -0,0 +1,52 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-member-dot" }
+      !
+      ! This should compile with and without -fdec-member-dot.
+      ! This tests the precedence between member accesses and intrinsic
+      ! operators.
+      !
+      ! This is similar to dot-3, but the member 'eq' is not a derived type
+      ! variable so t2.eq.* should always evaluate to the operation eq(t2,*).
+      !
+      ! The output should be:
+      ! 5
+      ! 5
+
+      include 'assert.inc'
+      module mod
+      type T1_t
+          integer :: i
+      end type T1_t
+      type T2_t
+          integer :: i
+          integer :: eq
+      end type T2_t
+       
+      interface operator (.eq.)
+          module procedure eq_func
+      end interface operator (.eq.)
+
+      contains
+
+      function eq_func(t2, i)
+          type(T2_t), intent (in) :: t2
+          integer, intent (in) :: i
+          integer eq_func
+          eq_func = t2%eq + i
+          return
+      end function eq_func
+
+      end module mod
+
+      use mod
+
+      type(T2_t) :: t2
+      integer :: i
+      t2%eq = 1
+      t2%i = 2
+      i = 4
+
+      call assertll ("t2.eq.i",    t2 .eq.i, 5) ! eq_func(t2,i) = 5
+      call assertll ("(t2).eq.i", (t2).eq.i, 5) ! eq_func(t2,i) = 5
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/dot8.f b/gcc/testsuite/gfortran.dg/dec/dot8.f
new file mode 100644
index 00000000000..5efcd01e5e9
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot8.f
@@ -0,0 +1,46 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-member-dot" }
+      !
+      ! This should compile with -fdec-member-dot.
+      ! This tests nested member accesses without dots.
+      ! The output should be '1'.
+
+      include 'assert.inc'
+      program main
+
+      type tg
+          integer i
+      end type
+
+      type tf
+          type(tg) g
+      end type
+
+      type te
+          type(tf) f
+      end type
+
+      type td
+          type(te) e
+      end type
+
+      TYPE tc
+          type(td) d
+      end type
+
+      TYPE tb
+          type(tc) c
+      END TYPE
+
+      TYPE ta
+          TYPE(tb) b
+      END TYPE
+
+      TYPE(ta) a
+
+      integer i
+      a%b%c%d%e%f%g%i = 1
+      i = a%b%c%d%e%f%g%i
+      call assertll ("a%b%c%d%e%f%g%i", i, 1)
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/dot9.f b/gcc/testsuite/gfortran.dg/dec/dot9.f
new file mode 100644
index 00000000000..40ffe53dea2
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot9.f
@@ -0,0 +1,47 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-member-dot" }
+      !
+      ! This should compile with -fdec-member-dot.
+      ! This tests nested member accesses with dots.
+      ! The output should be '1'.
+
+      include 'assert.inc'
+      program main
+
+      type tg
+          integer i
+      end type
+
+      type tf
+          type(tg) g
+      end type
+
+      type te
+          type(tf) f
+      end type
+
+      type td
+          type(te) e
+      end type
+
+      TYPE tc
+          type(td) d
+      end type
+
+      TYPE tb
+          type(tc) c
+      END TYPE
+
+      TYPE ta
+          TYPE(tb) b
+      END TYPE
+
+      TYPE(ta) a
+
+      integer i
+      a.b.c.d.e.f.g.i = 1
+      i = a.b.c.d.e.f.g.i
+
+      call assertll ("a.b.c.d.e.f.g.i", i, 1)
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/dot_bad1.f b/gcc/testsuite/gfortran.dg/dec/dot_bad1.f
new file mode 100644
index 00000000000..35f7d7e2fcf
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot_bad1.f
@@ -0,0 +1,28 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-member-dot" }
+      !
+      ! This should NOT compile with -fdec-member-dot.
+      ! This tests the precedence between member accesses and intrinsic
+      ! operators.
+      !
+      ! Since the member 'eq' is not a derived type variable, the compiler
+      ! should attempt to use the intrinsic operator 'eq', even though it is
+      ! not applicable to t2.
+      program main
+      type T1_t
+          integer :: i
+      end type T1_t
+      type T2_t
+          integer :: i
+          integer :: eq
+      end type T2_t
+       
+      type(T2_t) :: t2
+      integer :: i
+      t2%eq = 1
+      t2%i = 2
+      i = 4
+      print *,  t2.eq.i    ! { dg-error "Operands of comparison" }
+      print *, (t2).eq.i   ! { dg-error "Operands of comparison" }
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/dot_bad2.f b/gcc/testsuite/gfortran.dg/dec/dot_bad2.f
new file mode 100644
index 00000000000..9e37600838a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot_bad2.f
@@ -0,0 +1,11 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-member-dot" }
+      !
+      ! This should NOT compile with or without -fdec-member-dot.
+      ! This tests the error message given for invalid member accesses.
+      program main
+
+      integer i,j,k
+      k = i.j ! { dg-error "Unclassifiable statement" }
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/dot_bad3.f b/gcc/testsuite/gfortran.dg/dec/dot_bad3.f
new file mode 100644
index 00000000000..1172fcdd83c
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot_bad3.f
@@ -0,0 +1,10 @@
+      ! { dg-do compile }
+      !
+      ! This should NOT compile with or without -fdec-member-dot.
+      ! This tests the error message given for invalid member accesses.
+      program main
+
+      integer i,j,k
+      k = i.j ! { dg-error "Unclassifiable statement" }
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/dot_bad4.f b/gcc/testsuite/gfortran.dg/dec/dot_bad4.f
new file mode 100644
index 00000000000..e998f6d40ad
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot_bad4.f
@@ -0,0 +1,18 @@
+      ! { dg-do compile }
+      !
+      ! This test should NOT compile with or without -fdec-member-dot.
+      ! This tests the error message given for member accesses on valid
+      ! derived-type variables to a missing/invalid member.
+      program main
+
+      type t
+          integer y
+      end type
+
+      type (t) x
+      integer i,j,k,l
+
+      i = x%y
+      j = x%z ! { dg-error "is not a member of" }
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/dot_bad5.f b/gcc/testsuite/gfortran.dg/dec/dot_bad5.f
new file mode 100644
index 00000000000..9df0916d18c
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot_bad5.f
@@ -0,0 +1,20 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-member-dot" }
+      !
+      ! This test should NOT compile with or without -fdec-member-dot.
+      ! This tests the error message given for member accesses on valid
+      ! derived-type variables to a missing/invalid member.
+      ! This test is the same as dot-11 but with '.' instead of '%'.
+      program main
+
+      type t
+          integer y
+      end type
+
+      type (t) x
+      integer i,j,k,l
+
+      i = x.y
+      j = x.z ! { dg-error "is not a member of" }
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/exint_1.f b/gcc/testsuite/gfortran.dg/dec/exint_1.f
new file mode 100644
index 00000000000..826753614ef
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/exint_1.f
@@ -0,0 +1,35 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-extended-int" }
+      !
+      ! Test the DEC extended integer format 'base#value' in several
+      ! contexts.
+      !
+
+      include 'assert.inc'
+      program main
+      implicit integer(a-z)
+      integer*3#11        :: H ! { dg-error "Old-style.*INTEGER.3" }
+      integer(kind=2#100) I    ! 100 base 2 => 4
+      integer(5#13)       J, K ! 13  base 5 => 8
+      I     = #3D + 2
+      J     = 16 # 3f
+      K     = 2 #  1000000 - 6   # 1 
+      L     = -(-4#3 + 5#231)
+      M     = '3F'X
+      N     = 36#1R
+      O     = (-1)#4        ! { dg-error "Unclassifiable statement" }
+      P     = 0#10          ! { dg-error ".0. out of range" }
+      Q     = 1#0000        ! { dg-error ".1. out of range" }
+      R     = 37#XYZ14      ! { dg-error ".37. out of range" }
+      S     = 10#123456789A ! { dg-error "Invalid digit .a." }
+      T     = 16#3hfba      ! { dg-error "Invalid digit .h." }
+      U     = 13#           ! { dg-error "Expected.*after .#." }
+      write (*,3#22) x'BEEF'! { dg-error "Syntax error" }
+3#22  format (z8)           ! { dg-error "character in" }
+      call assertll ("i", i,  63)
+      call assertqq ("j", j,  63_8) ! J should have kind 8
+      call assertqq ("k", k,  63_8) ! K should have kind 8
+      call assertll ("l", l, -63)
+      call assertll ("m", m,  63)
+      call assertll ("n", n,  63)
+      end program main
diff --git a/gcc/testsuite/gfortran.dg/dec/float_noe.f b/gcc/testsuite/gfortran.dg/dec/float_noe.f
new file mode 100644
index 00000000000..c4c1cc5d152
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/float_noe.f
@@ -0,0 +1,21 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-io" }
+      !
+      ! Tests the extension to libgfortran which allows a floating point
+      ! number such as '1e' to be recognized as '1e0'.
+      !
+
+      program main
+      implicit none
+      real*4 d
+      character*20 :: tmp = "1e"
+
+      read (tmp,*,ERR=20) d
+      if (d == 1e0) then
+        write (*,'(a,g10.4)') "pass", d
+        stop
+      endif
+
+20    print *, "FAIL!!!!"
+      call abort
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/init_default.f b/gcc/testsuite/gfortran.dg/dec/init_default.f
new file mode 100644
index 00000000000..62071774310
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/init_default.f
@@ -0,0 +1,27 @@
+      ! { dg-do run }
+      ! { dg-options "-finit-local-zero -finit-derived" }
+      !
+      ! Test -finit-derived with a component with a default initialization.
+      !
+      include 'assert.inc'
+
+      PROGRAM MAIN 
+
+      TYPE REPORT
+        CHARACTER (LEN=20) REPORT_NAME
+        INTEGER DAY
+        CHARACTER (LEN=3) MONTH
+        INTEGER :: YEAR = 1995 ! Only component with default
+      END TYPE REPORT ! initialization
+
+      TYPE (REPORT) :: SEP_REPORT
+      TYPE (REPORT), PARAMETER :: NOV_REPORT = REPORT ("Sales", 15,
+     &                                                 "NOV", 1996)
+      SEP_REPORT%MONTH = "SEP"
+      SEP_REPORT%REPORT_NAME = "Sept sales"
+
+      call assertll ("sep_report%year", sep_report%year, 1995)
+      call assertll ("sep_report%day", sep_report%day, 0)
+      call assertll ("nov_report%year", nov_report%year, 1996)
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/init_derived.f b/gcc/testsuite/gfortran.dg/dec/init_derived.f
new file mode 100644
index 00000000000..dcf1e69b138
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/init_derived.f
@@ -0,0 +1,48 @@
+      ! { dg-do run }
+      ! { dg-options "-finit-local-zero -finit-derived" }
+      !
+      ! Make sure -finit-derived initializes components of local derived type
+      ! variables.
+      !
+      include 'assert.inc'
+
+      function myfunc(i)
+          integer myfunc, i
+          TYPE item
+            INTEGER :: id ! = 0
+            INTEGER :: description  = 0
+            INTEGER :: noinit
+            REAL price
+          END TYPE
+
+          TYPE(item) pear
+          INTEGER x
+          pear%noinit = 0
+          if(i > 0) then
+              pear%id = i
+          endif
+          myfunc = x + i + pear%id
+      end function myfunc
+
+      program main
+      implicit none
+      TYPE item
+        INTEGER :: id ! = 0
+        INTEGER :: description  = 0
+        INTEGER :: noinit
+        REAL price
+      END TYPE
+
+      type(item) bob
+      integer :: i, j, myfunc
+
+      call assertll ("i", i, 0)
+      call assertll ("j", j, 0)
+      call assertll ("bob%id", bob%id, 0)
+      call assertll ("bob%description", bob%description, 0)
+      call assertll ("bob%noinit", bob%noinit, 0)
+      call assertll ("myfunc(0)", myfunc(0), 0)
+      call assertll ("myfunc(1)", myfunc(1), 2)
+      call assertll ("myfunc(0)", myfunc(0), 0)
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/init_old.f b/gcc/testsuite/gfortran.dg/dec/init_old.f
new file mode 100644
index 00000000000..bd414770357
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/init_old.f
@@ -0,0 +1,110 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-structure -fno-range-check" }
+      !
+      ! Test old-style initializations for structure components.
+      ! 
+      SUBROUTINE DUMP (X)
+      INTEGER,PARAMETER :: AS = 3
+      STRUCTURE /T/
+        CHARACTER*20 C
+        INTEGER*1 I
+        INTEGER*2 J
+        INTEGER   K
+        INTEGER*4 L
+        INTEGER   M(5)
+        INTEGER   N(5)
+        INTEGER   O(AS)
+        INTEGER   P(2,2)
+        REAL      Q(3)
+      END STRUCTURE
+      RECORD /T/ X
+
+      PRINT *, "C) ", X%C
+      PRINT *, "I) ", X%I
+      PRINT *, "J) ", X%J
+      PRINT *, "K) ", X%K
+      PRINT *, "L) ", X%L
+      PRINT *, "M) ", X%M
+      PRINT *, "N) ", X%N
+      PRINT *, "O) ", X%O
+      PRINT *, "P) ", X%P
+      WRITE (*,'(a4)',advance='no'), " Q) "
+      WRITE (*,'(f6.4,a1,f6.4,a1,f6.4)'), X%Q(1), "", X%Q(2), "", X%Q(3)
+
+      call abort
+      END SUBROUTINE
+
+      subroutine assert (x, s, i1, i2)
+        character*(*) s
+        integer i1, i2
+        logical b
+        INTEGER,PARAMETER :: AS = 3
+        STRUCTURE /T/
+          CHARACTER*20 C
+          INTEGER*1 I
+          INTEGER*2 J
+          INTEGER   K
+          INTEGER*4 L
+          INTEGER   M(5)
+          INTEGER   N(5)
+          INTEGER   O(AS)
+          INTEGER   P(2,2)
+          REAL      Q(3)
+        END STRUCTURE
+        RECORD /T/ X
+        if ( i1 .ne. i2 ) then
+          print *, s, ": expected ", i2, " but was ", i1
+          call dump (x)
+        endif
+      end subroutine
+
+      PROGRAM MAIN
+      INTEGER,PARAMETER :: AS = 3
+      STRUCTURE /T/
+        CHARACTER*20 C /"hello"/  ! OK
+        INTEGER*1 I /300_2/       ! bad, but still compiles; overflows int_1
+        INTEGER*2 J /300_4/       ! OK, converted
+        INTEGER   K /65536_8/     ! OK, implicit
+        INTEGER   L /200000/      ! OK, types match
+        INTEGER   M(5) /5,4,3,2,1/! OK
+        INTEGER   N(5) /1,3*2,1/  ! OK, with repeat spec (/1,2,2,2,1/)
+        INTEGER   O(AS) /AS*9/    ! OK, parameter array spec
+        INTEGER   P(2,2) /1,2,3,4/! OK
+        REAL      Q(3) /1_2,3.5,2.4e-12_8/ ! OK, with some implicit conversions
+      END STRUCTURE
+
+      RECORD /T/ X
+
+      ! do these by hand to avoid fortran type bs
+      if ( x%i .ne. 44 ) then
+        print *, "x%i: expected 44 but was ", x%i
+        call dump(x)
+      else if ( x%j .ne. 300 ) then
+        print *, "x%j: expected 300 but was ", x%j
+        call dump(x)
+      endif
+      call assert ( x, "x%k", x%k, 65536 )
+      call assert ( x, "x%l", x%l, 200000 )
+
+      call assert ( x, "x%m(1)", x%m(1), 5 )
+      call assert ( x, "x%m(2)", x%m(2), 4 )
+      call assert ( x, "x%m(3)", x%m(3), 3 )
+      call assert ( x, "x%m(4)", x%m(4), 2 )
+      call assert ( x, "x%m(5)", x%m(5), 1 )
+
+      call assert ( x, "x%n(1)", x%n(1), 1 )
+      call assert ( x, "x%n(2)", x%n(2), 2 )
+      call assert ( x, "x%n(3)", x%n(3), 2 )
+      call assert ( x, "x%n(4)", x%n(4), 2 )
+      call assert ( x, "x%n(5)", x%n(5), 1 )
+
+      call assert ( x, "x%o(1)", x%o(1), 9 )
+      call assert ( x, "x%o(2)", x%o(2), 9 )
+      call assert ( x, "x%o(3)", x%o(3), 9 )
+
+      call assert ( x, "x%p(1,1)", x%p(1,1), 1 )
+      call assert ( x, "x%p(2,1)", x%p(2,1), 2 )
+      call assert ( x, "x%p(1,2)", x%p(1,2), 3 )
+      call assert ( x, "x%p(2,2)", x%p(2,2), 4 )
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/init_old_bad.f b/gcc/testsuite/gfortran.dg/dec/init_old_bad.f
new file mode 100644
index 00000000000..4a6abd16ae2
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/init_old_bad.f
@@ -0,0 +1,19 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-structure" }
+      !
+      ! Test error checking for old-style initializations of structure components.
+      ! 
+
+      PROGRAM MAIN
+      INTEGER,PARAMETER :: AS = 3
+      STRUCTURE /T/
+        INTEGER   T(AS) /4*9/    ! { dg-error "Too many elements" }
+        INTEGER   U /1,2,3/      ! { dg-error "End of scalar initializer expected" }
+        INTEGER   V /"hi"/       ! { dg-error "Can't convert" }
+        INTEGER   W(3) /1,3/     ! { dg-error "Not enough elements" }
+        INTEGER   X(3) /1,3,5,7/ ! { dg-error "Too many elements" }
+        INTEGER   Y(3) /2*1/     ! { dg-error "Not enough elements" }
+        INTEGER   Z(3) /10*1/    ! { dg-error "Too many elements" }
+      END STRUCTURE
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/io_ccdef.f b/gcc/testsuite/gfortran.dg/dec/io_ccdef.f
new file mode 100644
index 00000000000..29c38914391
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/io_ccdef.f
@@ -0,0 +1,53 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-io" }
+      !
+      ! Control test for the cc*.for tests which test the DEC
+      ! CARRIAGECONTROL specifier. Should act like cclist.for.
+      !
+
+      subroutine writeall (s, fd1)
+        implicit none
+        character*(*) s
+        integer fd1
+        write (fd1,*) s
+      endsubroutine
+
+      subroutine readall (s, fd)
+        implicit none
+        integer i, fd, st
+        character*(*) s
+        character*19 buf
+        print *, "===> ", s, " <==="
+        st = 0
+        read (fd,'(a)',iostat=st) buf
+        do while (st .eq. 0)
+          print *, buf
+          read (fd,'(a)',iostat=st) buf
+        enddo
+      endsubroutine
+
+      program main
+
+      integer, parameter :: deffd=3
+      character*(*), parameter :: def   = "cc-def.txt"
+
+      open(unit=deffd,  file=def, action ="WRITE")
+
+      call writeall  ("+hi", deffd)
+      call writeall  ("-hi", deffd)
+      call writeall  ("0hi", deffd)
+      call writeall  ("1hi", deffd)
+      call writeall  ("$hi", deffd)
+      call writeall  (" hi", deffd)
+      call writeall  ("h	i", deffd)
+      call writeall  ("o k b y e n o w", deffd)
+
+      close(unit=deffd)
+
+      open(unit=deffd,  file=def, action ="READ")
+
+      call readall ("default", deffd)
+
+      close(unit=deffd)
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/io_ccfort.f b/gcc/testsuite/gfortran.dg/dec/io_ccfort.f
new file mode 100644
index 00000000000..daf2d4c9e58
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/io_ccfort.f
@@ -0,0 +1,54 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-io" }
+      !
+      ! Tests CARRIAGECONTROL='FORTRAN'.
+      !
+
+      subroutine writeall (s, fd1)
+        implicit none
+        character*(*) s
+        integer fd1
+        write (fd1,*) s
+      endsubroutine
+
+      subroutine readall (s, fd)
+        implicit none
+        integer i, fd, st
+        character*(*) s
+        character*19 buf
+        print *, "===> ", s, " <==="
+        st = 0
+        read (fd,'(a)',iostat=st) buf
+        do while (st .eq. 0)
+          print *, buf
+          read (fd,'(a)',iostat=st) buf
+        enddo
+      endsubroutine
+
+      program main
+
+      integer, parameter :: deffd=3
+      character*(*), parameter :: def   = "cc-fort.txt"
+
+      open(unit=deffd,  file=def, action ="WRITE",
+     &     carriagecontrol="FORTRAN")
+
+      call writeall  ("+hi", deffd)
+      call writeall  ("-hi", deffd)
+      call writeall  ("0hi", deffd)
+      call writeall  ("1hi", deffd)
+      call writeall  ("$hi", deffd)
+      call writeall  (" hi", deffd)
+      call writeall  ("h	i", deffd)
+      call writeall  ("o k b y e n o w", deffd)
+
+      close(unit=deffd)
+
+      open(unit=deffd,  file=def, action ="READ",
+     &     carriagecontrol="FORTRAN")
+
+      call readall ("fort", deffd)
+
+      close(unit=deffd)
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/io_cclist.f b/gcc/testsuite/gfortran.dg/dec/io_cclist.f
new file mode 100644
index 00000000000..c0ab30e721b
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/io_cclist.f
@@ -0,0 +1,54 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-io" }
+      !
+      ! Tests CARRIAGECONTROL='LIST'.
+      !
+
+      subroutine writeall (s, fd1)
+        implicit none
+        character*(*) s
+        integer fd1
+        write (fd1,*) s
+      endsubroutine
+
+      subroutine readall (s, fd)
+        implicit none
+        integer i, fd, st
+        character*(*) s
+        character*19 buf
+        print *, "===> ", s, " <==="
+        st = 0
+        read (fd,'(a)',iostat=st) buf
+        do while (st .eq. 0)
+          print *, buf
+          read (fd,'(a)',iostat=st) buf
+        enddo
+      endsubroutine
+
+      program main
+
+      integer, parameter :: deffd=3
+      character*(*), parameter :: def   = "cc-list.txt"
+
+      open(unit=deffd,  file=def, action ="WRITE",
+     &     carriagecontrol="LIST")
+
+      call writeall  ("+hi", deffd)
+      call writeall  ("-hi", deffd)
+      call writeall  ("0hi", deffd)
+      call writeall  ("1hi", deffd)
+      call writeall  ("$hi", deffd)
+      call writeall  (" hi", deffd)
+      call writeall  ("h	i", deffd)
+      call writeall  ("o k b y e n o w", deffd)
+
+      close(unit=deffd)
+
+      open(unit=deffd,  file=def, action ="READ",
+     &     carriagecontrol="LIST")
+
+      call readall ("list", deffd)
+
+      close(unit=deffd)
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/io_ccnone.f b/gcc/testsuite/gfortran.dg/dec/io_ccnone.f
new file mode 100644
index 00000000000..c31d289a7a7
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/io_ccnone.f
@@ -0,0 +1,55 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-io" }
+      !
+      ! Tests CARRIAGECONTROL='NONE'.
+      !
+
+      subroutine writeall (s, fd1)
+        implicit none
+        character*(*) s
+        integer fd1
+        write (fd1,*) s
+      endsubroutine
+
+      subroutine readall (s, fd)
+        implicit none
+        integer i, fd, st
+        character*(*) s
+        character*19 buf
+        print *, "===> ", s, " <==="
+        st = 0
+        read (fd,'(a)',iostat=st) buf
+        do while (st .eq. 0)
+          print *, buf
+          read (fd,'(a)',iostat=st) buf
+        enddo
+      endsubroutine
+
+      program main
+
+      integer, parameter :: deffd=3
+      character*(*), parameter :: def   = "cc-none.txt"
+      character*4 buf
+
+      open(unit=deffd,  file=def, action ="WRITE",
+     &     carriagecontrol="NONE")
+
+      call writeall  ("+hi", deffd)
+      call writeall  ("-hi", deffd)
+      call writeall  ("0hi", deffd)
+      call writeall  ("1hi", deffd)
+      call writeall  ("$hi", deffd)
+      call writeall  (" hi", deffd)
+      call writeall  ("h	i", deffd)
+      call writeall  ("o k b y e n o w", deffd)
+
+      close(unit=deffd)
+
+      open(unit=deffd,  file=def, action ="READ",
+     &     carriagecontrol="NONE")
+
+      call readall ("none", deffd)
+
+      close(unit=deffd)
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/io_readonly.f b/gcc/testsuite/gfortran.dg/dec/io_readonly.f
new file mode 100644
index 00000000000..06fbea016f9
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/io_readonly.f
@@ -0,0 +1,23 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-io" }
+      !
+      ! Tests the READONLY flag. A more complex test should be done
+      ! which actually exercises the runtime protection of delete on
+      ! close.
+      !
+      program main
+
+      character*20, parameter :: fname='test.txt'
+      integer :: fd = 1
+      !character*100 cdata
+
+      open (unit=fd, file=fname, readonly)
+
+      !read (fd,'(a)') cdata
+      !write (*,'(a)') cdata
+
+      !write (fd,'(a)') cdata ! should cause runtime error
+
+      close (unit=fd) !, status='delete') ! should cause runtime error/warning
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/io_shared.f b/gcc/testsuite/gfortran.dg/dec/io_shared.f
new file mode 100644
index 00000000000..b738e755d77
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/io_shared.f
@@ -0,0 +1,18 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-io" }
+      !
+      ! Tests compilation of the SHARE= specifier family. A more
+      ! complete test should be created which actually checks that the
+      ! correct fcntl() is made at runtime.
+      !
+      program main
+
+      character*20, parameter :: fname='test.txt'
+      integer fd
+
+      open (unit=fd, file=fname, action='read', shared)
+      open (unit=fd, file=fname, action='read', noshared)
+      open (unit=fd, file=fname, action='read', share='denynone')
+      open (unit=fd, file=fname, action='read', share='denyrw')
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/lazy_ints.f b/gcc/testsuite/gfortran.dg/dec/lazy_ints.f
new file mode 100644
index 00000000000..c19c68d2664
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/lazy_ints.f
@@ -0,0 +1,76 @@
+      ! { dg-options "-flazy-logicals" }
+      ! { dg-do run }
+      ! Tests the conversions between integers and logicals using
+      ! -flazy-types. This helps compatibility with old (albeit faulty) code.
+
+      subroutine abortis (i, s)
+        integer, intent(in) :: i
+        character(*), intent(in) :: s
+        write (*, '(a,i2,a,a)') "(int = ", i, ") ", s
+        call abort()
+      end subroutine
+
+      subroutine aborts (s)
+        character(*), intent(in) :: s
+        print *, s
+        call abort()
+      end subroutine
+
+      program main
+
+      integer tis(7) /1,-1, -5,-3,3,5,7/
+      integer fis(7) /0, 2, -6,-4,-2,4,6/
+      integer :: ii = 1            ! [ft]i = [ft]is(ii)
+      integer :: fi, ti            ! false int, true int
+      logical :: tl = .true.       ! true logical
+      logical :: fl = .false.      ! false logical
+
+      ! Test behavior of logicals with eq/ne instead of eqv/neqv
+      if (fl .ne. .false.) call aborts ("false logical .ne.")
+      if (tl .ne. .true.)  call aborts ("true  logical .ne.")
+      if (fl .eq. .false.) then
+      else
+        call aborts ("false logical .eq.")
+      endif
+      if (tl .eq. .true.) then
+      else
+        call aborts ("true  logical .eq.")
+      endif
+
+      ! Test how integers handle as logicals
+      ! For compatibility with Intel and other Fortran compilers, we
+      ! define an integer as true if its lsb is 1, false if it is 0.
+      do while ( ii .le. size(tis) )
+        fi = fis(ii)
+        ti = tis(ii)
+
+        if (fi) call abortis (fi, "false int")
+        if (.not. fi) then
+        else
+          call abortis (fi, "not false int")
+        endif
+c       In Intel FT, .false. is only .eq. 0
+        if (fi .eq. 0) then
+          if (tl.eq.fi) call abortis (fi, "true  logical ==  false int")
+          if (fl.ne.fi) call abortis (fi, "false logical !=  false int")
+        endif
+        if (tl .eqv. fi) call abortis (fi,"true  logical === false int")
+        if (fl .neqv. fi) call abortis(fi,"false logical !== false int")
+
+        if (.not. ti) call abortis (ti, "not true int")
+        if (ti) then
+        else
+          call abortis (ti, "true int")
+        endif
+c       In Intel FT, .true. is only .eq. -1
+        if (ti .eq. -1) then
+          if (tl.ne.ti) call abortis (ti,  "true  logical !=  true int")
+          if (fl.eq.ti) call abortis (ti,  "false logical ==  true int")
+        endif
+        if (tl .neqv. ti) call abortis (ti,"true  logical !== true int")
+        if (fl .eqv. ti) call abortis (ti, "false logical === true int")
+
+        ii = ii + 1
+      end do
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/linefeed_fixed.f b/gcc/testsuite/gfortran.dg/dec/linefeed_fixed.f
new file mode 100644
index 00000000000..a310e4d2ae4
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/linefeed_fixed.f
@@ -0,0 +1,10 @@
+! { dg-do compile }
+! { dg-options "-ffeed -ffixed-form" }
+!
+      PROGRAM MAIN
+
+      INTEGER*4 I   
+     INTEGER*4 K
+      INTEGER*4 J
+
+      END PROGRAM MAIN
diff --git a/gcc/testsuite/gfortran.dg/dec/linefeed_free.f b/gcc/testsuite/gfortran.dg/dec/linefeed_free.f
new file mode 100644
index 00000000000..6dd8fa084c9
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/linefeed_free.f
@@ -0,0 +1,10 @@
+! { dg-do compile }
+! { dg-options "-ffeed -ffree-form" }
+!
+PROGRAM MAIN
+
+  INTEGER*4 I
+ INTEGER*4 K 
+INTEGER*4 J
+
+END PROGRAM MAIN
diff --git a/gcc/testsuite/gfortran.dg/dec/loc_rval.f b/gcc/testsuite/gfortran.dg/dec/loc_rval.f
new file mode 100644
index 00000000000..2b8655e5033
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/loc_rval.f
@@ -0,0 +1,18 @@
+      ! { dg-do run }
+      ! { dg-options "-floc-rval" }
+      !
+      ! Test the usage of %loc as an rvalue with -floc-rval.
+      !
+
+      include 'assert.inc'
+      program main
+      integer j
+
+      integer :: i, k
+      
+      i =  loc ( j )
+      j = %loc ( j )
+
+      call assertll ("loc", i, j)
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/math.f90 b/gcc/testsuite/gfortran.dg/dec/math.f90
new file mode 100644
index 00000000000..d9960b1b4b3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/math.f90
@@ -0,0 +1,287 @@
+! { dg-options "-fdec-math" }
+! { dg-do run }
+!
+! Test extra math intrinsics offered by -fdec-math.
+!
+
+  subroutine cmpf(f1, f2, tolerance, str)
+    implicit none
+    real(4), intent(in) :: f1, f2, tolerance
+    character(len=*), intent(in) :: str
+    if ( abs(f2 - f1) .gt. tolerance ) then
+      write (*, '(A,F12.6,F12.6)') str, f1, f2
+      call abort()
+    endif
+  endsubroutine
+
+  subroutine cmpd(d1, d2, tolerance, str)
+    implicit none
+    real(8), intent(in) :: d1, d2, tolerance
+    character(len=*), intent(in) :: str
+    if ( dabs(d2 - d1) .gt. tolerance ) then
+      write (*, '(A,F12.6,F12.6)') str, d1, d2
+      call abort()
+    endif
+  endsubroutine
+
+implicit none
+
+  real(4), parameter :: pi_f = (4.0_4 *  atan(1.0_4))
+  real(8), parameter :: pi_d = (4.0_8 * datan(1.0_8))
+  real(4), parameter :: r2d_f = 180.0_4 / pi_f
+  real(8), parameter :: r2d_d = 180.0_8 / pi_d
+  real(4), parameter :: d2r_f = pi_f / 180.0_4
+  real(8), parameter :: d2r_d = pi_d / 180.0_8
+
+! inputs
+real(4) :: xf, f_i1, f_i2
+real(8) :: xd, d_i1, d_i2
+
+! expected outputs from (oe) default (oxe) expression
+real(4) :: f_oe, f_oxe
+real(8) :: d_oe, d_oxe
+
+! actual outputs from (oa) default (oc) constant (ox) expression
+real(4) :: f_oa, f_oc, f_ox
+real(8) :: d_oa, d_oc, d_ox
+
+! tolerance of the answer: assert |exp-act| <= tol
+real(4) :: f_tol
+real(8) :: d_tol
+
+! equivalence tolerance
+f_tol = 5e-5_4
+d_tol = 5e-6_8
+
+! multiplication factors to test non-constant expressions
+xf = 2.0_4
+xd = 2.0_8
+
+! Input
+f_i1 = 0.68032123_4
+d_i1 = 0.68032123_8
+
+! Expected
+f_oe =     r2d_f*acos (f_i1)
+f_oxe = xf*r2d_f*acos (f_i1)
+d_oe =     r2d_d*dacos(d_i1)
+d_oxe = xd*r2d_d*dacos(d_i1)
+
+! Actual
+f_oa =    acosd (f_i1)
+f_oc =    acosd (0.68032123_4)
+f_ox = xf*acosd (f_i1)
+d_oa =    dacosd (d_i1)
+d_oc =    dacosd (0.68032123_8)
+d_ox = xd*dacosd (0.68032123_8)
+
+call cmpf(f_oe,  f_oa, f_tol, "( ) acosd")
+call cmpf(f_oe,  f_oc, f_tol, "(c) acosd")
+call cmpf(f_oxe, f_ox, f_tol, "(x) acosd")
+call cmpd(d_oe,  d_oa, d_tol, "( ) dacosd")
+call cmpd(d_oe,  d_oc, d_tol, "(c) dacosd")
+call cmpd(d_oxe, d_ox, d_tol, "(x) dacosd")
+
+! Input
+f_i1 = 60.0_4
+d_i1 = 60.0_8
+
+! Expected
+f_oe  =    cos (d2r_f*f_i1)
+f_oxe = xf*cos (d2r_f*f_i1)
+d_oe  =    cos (d2r_d*d_i1)
+d_oxe = xd*cos (d2r_d*d_i1)
+
+! Actual
+f_oa =     cosd (f_i1)
+f_oc =     cosd (60.0_4)
+f_ox = xf* cosd (f_i1)
+d_oa =    dcosd (d_i1)
+d_oc =    dcosd (60.0_8)
+d_ox = xd* cosd (d_i1)
+
+call cmpf(f_oe,  f_oa, f_tol, "( ) cosd")
+call cmpf(f_oe,  f_oc, f_tol, "(c) cosd")
+call cmpf(f_oxe, f_ox, f_tol, "(x) cosd")
+call cmpd(d_oe,  d_oa, d_tol, "( ) dcosd")
+call cmpd(d_oe,  d_oc, d_tol, "(c) dcosd")
+call cmpd(d_oxe, d_ox, d_tol, "(x) cosd")
+
+! Input
+f_i1 = 0.79345021_4
+d_i1 = 0.79345021_8
+
+! Expected
+f_oe  =    r2d_f*asin (f_i1)
+f_oxe = xf*r2d_f*asin (f_i1)
+d_oe  =    r2d_d*asin (d_i1)
+d_oxe = xd*r2d_d*asin (d_i1)
+
+! Actual
+f_oa =     asind (f_i1)
+f_oc =     asind (0.79345021_4)
+f_ox = xf* asind (f_i1)
+d_oa =    dasind (d_i1)
+d_oc =    dasind (0.79345021_8)
+d_ox = xd* asind (d_i1)
+
+call cmpf(f_oe,  f_oa, f_tol, "( ) asind")
+call cmpf(f_oe,  f_oc, f_tol, "(c) asind")
+call cmpf(f_oxe, f_ox, f_tol, "(x) asind")
+call cmpd(d_oe,  d_oa, d_tol, "( ) dasind")
+call cmpd(d_oe,  d_oc, d_tol, "(c) dasind")
+call cmpd(d_oxe, d_ox, d_tol, "(x) asind")
+
+! Input
+f_i1 = 60.0_4
+d_i1 = 60.0_8
+
+! Expected
+f_oe  =    sin (d2r_f*f_i1)
+f_oxe = xf*sin (d2r_f*f_i1)
+d_oe  =    sin (d2r_d*d_i1)
+d_oxe = xd*sin (d2r_d*d_i1)
+
+! Actual
+f_oa =     sind (f_i1)
+f_oc =     sind (60.0_4)
+f_ox = xf* sind (f_i1)
+d_oa =    dsind (d_i1)
+d_oc =    dsind (60.0_8)
+d_ox = xd* sind (d_i1)
+
+call cmpf(f_oe,  f_oa, f_tol, "( ) sind")
+call cmpf(f_oe,  f_oc, f_tol, "(c) sind")
+call cmpf(f_oxe, f_ox, f_tol, "(x) sind")
+call cmpd(d_oe,  d_oa, d_tol, "( ) dsind")
+call cmpd(d_oe,  d_oc, d_tol, "(c) dsind")
+call cmpd(d_oxe, d_ox, d_tol, "(x) sind")
+
+! Input
+f_i1 = 2.679676_4
+f_i2 = 1.0_4
+d_i1 = 2.679676_8
+d_i2 = 1.0_8
+
+! Expected
+f_oe  =    r2d_f*atan2 (f_i1, f_i2)
+f_oxe = xf*r2d_f*atan2 (f_i1, f_i2)
+d_oe  =    r2d_d*atan2 (d_i1, d_i2)
+d_oxe = xd*r2d_d*atan2 (d_i1, d_i2)
+
+! Actual
+f_oa =     atan2d (f_i1, f_i2)
+f_oc =     atan2d (2.679676_4, 1.0_4)
+f_ox = xf* atan2d (f_i1, f_i2)
+d_oa =    datan2d (d_i1, d_i2)
+d_oc =    datan2d (2.679676_8, 1.0_8)
+d_ox = xd* atan2d (d_i1, d_i2)
+
+call cmpf(f_oe,  f_oa, f_tol, "( ) atan2d")
+call cmpf(f_oe,  f_oc, f_tol, "(c) atan2d")
+call cmpf(f_oxe, f_ox, f_tol, "(x) atan2d")
+call cmpd(d_oe,  d_oa, d_tol, "( ) datan2d")
+call cmpd(d_oe,  d_oc, d_tol, "(c) datan2d")
+call cmpd(d_oxe, d_ox, d_tol, "(x) atan2d")
+
+! Input
+f_i1 = 1.5874993_4
+d_i1 = 1.5874993_8
+
+! Expected
+f_oe  =    r2d_f*atan (f_i1)
+f_oxe = xf*r2d_f*atan (f_i1)
+d_oe  =    r2d_d*atan (d_i1)
+d_oxe = xd*r2d_d*atan (d_i1)
+
+! Actual
+f_oa =     atand (f_i1)
+f_oc =     atand (1.5874993_4)
+f_ox = xf* atand (f_i1)
+d_oa =    datand (d_i1)
+d_oc =    datand (1.5874993_8)
+d_ox = xd* atand (d_i1)
+
+call cmpf(f_oe,  f_oa, f_tol, "( ) atand")
+call cmpf(f_oe,  f_oc, f_tol, "(c) atand")
+call cmpf(f_oxe, f_ox, f_tol, "(x) atand")
+call cmpd(d_oe,  d_oa, d_tol, "( ) datand")
+call cmpd(d_oe,  d_oc, d_tol, "(c) datand")
+call cmpd(d_oxe, d_ox, d_tol, "(x) atand")
+
+! Input
+f_i1 = 0.6_4
+d_i1 = 0.6_8
+
+! Expected
+f_oe  =    cotan (d2r_f*f_i1)
+f_oxe = xf*cotan (d2r_f*f_i1)
+d_oe  =    cotan (d2r_d*d_i1)
+d_oxe = xd*cotan (d2r_d*d_i1)
+
+! Actual
+f_oa =     cotand (f_i1)
+f_oc =     cotand (0.6_4)
+f_ox = xf* cotand (f_i1)
+d_oa =    dcotand (d_i1)
+d_oc =    dcotand (0.6_8)
+d_ox = xd* cotand (d_i1)
+
+call cmpf(f_oe,  f_oa, f_tol, "( ) cotand")
+call cmpf(f_oe,  f_oc, f_tol, "(c) cotand")
+call cmpf(f_oxe, f_ox, f_tol, "(x) cotand")
+call cmpd(d_oe,  d_oa, d_tol, "( ) dcotand")
+call cmpd(d_oe,  d_oc, d_tol, "(c) dcotand")
+call cmpd(d_oxe, d_ox, d_tol, "(x) cotand")
+
+! Input
+f_i1 = 0.6_4
+d_i1 = 0.6_8
+
+! Expected
+f_oe  =     1.0_4/tan (f_i1)
+f_oxe = xf* 1.0_4/tan (f_i1)
+d_oe  =    1.0_8/dtan (d_i1)
+d_oxe = xd*1.0_8/dtan (d_i1)
+
+! Actual
+f_oa =     cotan (f_i1)
+f_oc =     cotan (0.6_4)
+f_ox = xf* cotan (f_i1)
+d_oa =    dcotan (d_i1)
+d_oc =    dcotan (0.6_8)
+d_ox = xd* cotan (d_i1)
+
+call cmpf(f_oe,  f_oa, f_tol, "( ) cotan")
+call cmpf(f_oe,  f_oc, f_tol, "(c) cotan")
+call cmpf(f_oxe, f_ox, f_tol, "(x) cotan")
+call cmpd(d_oe,  d_oa, d_tol, "( ) dcotan")
+call cmpd(d_oe,  d_oc, d_tol, "(c) dcotan")
+call cmpd(d_oxe, d_ox, d_tol, "(x) cotan")
+
+! Input
+f_i1 = 60.0_4
+d_i1 = 60.0_8
+
+! Expected
+f_oe  =    tan (d2r_f*f_i1)
+f_oxe = xf*tan (d2r_f*f_i1)
+d_oe  =    tan (d2r_d*d_i1)
+d_oxe = xd*tan (d2r_d*d_i1)
+
+! Actual
+f_oa =     tand (f_i1)
+f_oc =     tand (60.0_4)
+f_ox = xf* tand (f_i1)
+d_oa =    dtand (d_i1)
+d_oc =    dtand (60.0_8)
+d_ox = xd* tand (d_i1)
+
+call cmpf(f_oe,  f_oa, f_tol, "( ) tand")
+call cmpf(f_oe,  f_oc, f_tol, "(c) tand")
+call cmpf(f_oxe, f_ox, f_tol, "(x) tand")
+call cmpd(d_oe,  d_oa, d_tol, "( ) dtand")
+call cmpd(d_oe,  d_oc, d_tol, "(c) dtand")
+call cmpd(d_oxe, d_ox, d_tol, "(x) tand")
+
+end
diff --git a/gcc/testsuite/gfortran.dg/dec/nocomp/nocomp_dot1.for b/gcc/testsuite/gfortran.dg/dec/nocomp/nocomp_dot1.for
new file mode 100644
index 00000000000..514cd11e929
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/nocomp/nocomp_dot1.for
@@ -0,0 +1,66 @@
+! This is a horrible example of how twisted Fortran is:
+! "X.AND.AND.AND.AND" resolves to (X.AND.AND) .AND. (AND)
+! because ".AND." is defined to take (LOGICAL, T) parameters 
+! where "X.AND.AND" is type LOGICAL and "AND" is type T.
+! Without the knowledge of the type of parameters expected by the
+! user-defined ".AND.", this would be completely ambiguous.
+      module mod
+
+      TYPE t2
+          logical y
+      END TYPE
+
+      TYPE t1
+          logical and
+      END TYPE
+        
+      interface operator (.and.)
+          module procedure a
+      end interface operator (.and.)
+
+      interface operator (.or.)
+          module procedure b
+      end interface operator (.or.)
+
+      contains
+
+      function a(x, y)
+          type(t1), intent (in) :: x
+          logical, intent (in) :: y
+          logical a
+          print *, 'called and'
+          a = (.not. x%and) .and. (.not. y)
+          return
+      end function a
+
+      function b(x, y)
+          logical, intent (in) :: x
+          type(t2), intent (in) :: y
+          logical b
+          print *, 'called or'
+          b = (.not. x) .and. (.not. y%y)
+          return
+      end function b
+
+      end module mod
+
+      use mod
+
+      TYPE(t1) :: x
+      TYPE(t2) :: or
+      LOGICAL  :: y
+      LOGICAL :: i
+      x.and = .true.
+      or.y  = .true.
+      y = .true.
+
+      ! could be...
+      !   (x) .and. (or.y)  * but this is the chosen one
+      !   (x.and) .or. (y)
+      i = x.and.or.y 
+
+      if ( i ) then ! (x->and) .AND. (z)
+          print *, .true.
+      endif
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/nocomp/nocomp_dot2.for b/gcc/testsuite/gfortran.dg/dec/nocomp/nocomp_dot2.for
new file mode 100644
index 00000000000..49ac5789d76
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/nocomp/nocomp_dot2.for
@@ -0,0 +1,48 @@
+! { dg-do compile }
+! { dg-options "-fdec-member-dot }
+!
+! This is a horrible example of how twisted Fortran is:
+! "X.AND.AND.AND.AND" resolves to (X.AND.AND) .AND. (AND)
+! because ".AND." is defined to take (LOGICAL, T) parameters 
+! where "X.AND.AND" is type LOGICAL and "AND" is type T.
+! Without the knowledge of the type of parameters expected by the
+! user-defined ".AND.", this would be completely ambiguous.
+module mod
+
+TYPE t2
+    logical and
+END TYPE
+
+TYPE t
+    TYPE(t2) and
+END TYPE
+  
+interface operator (.and.)
+    module procedure a
+end interface operator (.and.)
+
+contains
+
+function a(x, y)
+    type(t), intent (in) :: y
+    logical, intent (in) :: x
+    logical a
+    print *, "called and"
+    a = (.not. x) .and. (.not. y%and%and)
+    return
+end function a
+
+end module mod
+
+use mod
+
+TYPE(t) :: and
+!and%and%and = .true.
+
+and.and.and = and.and.and.and.and
+
+if ( and.and.and ) then ! (x->and) .AND. (z)
+    print *, .true.
+endif
+
+end program
diff --git a/gcc/testsuite/gfortran.dg/dec/nocomp/others.for b/gcc/testsuite/gfortran.dg/dec/nocomp/others.for
new file mode 100644
index 00000000000..173020cd469
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/nocomp/others.for
@@ -0,0 +1,40 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-intrinsic-ints" }
+      !
+      ! Tests the extended integer formats on bitwise and other
+      ! functions (BIJK-prefixes).
+      ! The functions in this test may not be implemented.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*1 :: BA, BB, BC, BD
+      INTEGER*2 :: IA, IB, IC, ID
+      INTEGER*4 :: JA, JB, JC, JD
+      INTEGER*8 :: KA, KB, KC, KD
+
+      BA = BIBITS(357, 10, 5)
+      BB = BMVBITS(357, 8, 3, BA, 1)
+      BC = BISHFTC(BA, 6, 3)
+      BD = BISHFT(BC, -3)
+      BA = BNOT(BD)
+
+      IA = IIBITS(357, 10, 5)
+      IB = IMVBITS(357, 8, 3, IA, 1)
+      IC = IISHFTC(IA, 3, 6)
+      ID = IISHFT(IC, -3)
+      IA = INOT(ID)
+
+      JA = JIBITS(357, 10, 5)
+      JB = JMVBITS(357, 8, 3, JA, 1)
+      JC = JISHFTC(JA, 3, 6)
+      JD = JISHFT(JC, -3)
+      JA = JNOT(JD)
+
+      KA = KIBITS(357_8, 10_8, 5_8)
+      KB = KMVBITS(357_8, 8_8, 3_8, KA, 1_8)
+      KC = KISHFTC(KA, 3_8, 6_8)
+      KD = KISHFT(KC, -3_8)
+      KA = KNOT(KD)
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/nocomp/union_type.for b/gcc/testsuite/gfortran.dg/dec/nocomp/union_type.for
new file mode 100644
index 00000000000..a65172d7be2
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/nocomp/union_type.for
@@ -0,0 +1,20 @@
+      program main
+
+      type words_long
+        union 
+          map 
+            integer*2  w1, w2, w3 
+          end map 
+          map 
+            integer*4  long
+          end map 
+        end union 
+      end type
+
+      type (words_long) x
+
+      x%long = z'56781234'
+      write (*,8) x%w1, x%w2, x%w3
+8     format (z5,z5,z5)
+
+      end program main
diff --git a/gcc/testsuite/gfortran.dg/dec/parameter_1.f b/gcc/testsuite/gfortran.dg/dec/parameter_1.f
new file mode 100644
index 00000000000..69ffa53c806
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/parameter_1.f
@@ -0,0 +1,64 @@
+        ! { dg-do run }
+        ! { dg-options "-ffixed-form -std=legacy" }
+        !
+        ! Test DEC-style PARAMETER statements without parentheses in
+        ! fixed form.
+        !
+
+        subroutine sub1(t, x, y)
+          implicit real(8) (A-H,O-Z)
+          parameter   (pi_1 = 3.141592654d0, f_1 = 3.d08)
+          parameter    pi_2 = 3.141592654d0, f_2 = 3.d08
+          ! Note that if the parameter statements above are matched
+          ! incorrectly as assignments, the below specification
+          ! statements will be considered out-of-order and we see
+          ! 'unexpected specification statement'. A PARAMETER
+          ! statement should still be a specification statement.
+
+          real(8), intent(in) :: t
+          real(8), intent(out) :: x, y
+
+          real(8), volatile :: two
+          two = 2.0d0
+          x = two * pi_1 * f_1 * t
+          y = two * pi_2 * f_2 * t
+          z = two * pi_3 * f_3 * t
+          return
+        end subroutine
+
+        subroutine sub2(t, x, y, z)
+          implicit none
+          real(8) :: pi_1, pi_2, f_1, f_2
+                   parameter   (pi_1 = 3.141592654d0, f_1 = 3.d08)
+                   parameter    pi_2 = 3.141592654d0, f_2 = 3.d08
+          real(8), parameter :: pi_3 = 3.141592654d0, f_3 = 3.d08
+          ! Ditto sub1
+
+          real(8), intent(in) :: t
+          real(8), intent(out) :: x, y, z
+
+          real(8), volatile :: two
+          two = 2.0d0
+          x = two * pi_1 * f_1 * t
+          y = two * pi_2 * f_2 * t
+          z = two * pi_3 * f_3 * t
+        end subroutine
+
+        implicit none
+        real(8) :: x1, x2, y1, y2, z2
+        real(8), volatile :: t
+        t = 1.5e-6
+
+        call sub1(t, x1, y1)
+        call sub2(t, x2, y2, z2)
+
+        write(*,'(4D18.5)') t, x1, y1
+        write(*,'(4D18.5)') t, x2, y2, z2
+
+        if (x1 .ne. x2 .or. y1 .ne. y2
+     &      .or. x1 .ne. y1 .or. x2 .ne. y2
+     &      .or. y2 .ne. z2) then
+          call abort()
+        endif
+
+        end
diff --git a/gcc/testsuite/gfortran.dg/dec/parameter_2.f90 b/gcc/testsuite/gfortran.dg/dec/parameter_2.f90
new file mode 100644
index 00000000000..280f0007f93
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/parameter_2.f90
@@ -0,0 +1,63 @@
+! { dg-do run }
+! { dg-options "-ffree-form -std=legacy" }
+!
+! Test DEC-style PARAMETER statements without parentheses in free form.
+!
+
+subroutine sub1(t, x, y)
+  implicit real(8) (A-H,O-Z)
+  parameter   (pi_1 = 3.141592654d0, f_1 = 3.d08)
+  parameter    pi_2 = 3.141592654d0, f_2 = 3.d08 ! legacy PARAMETER
+  ! Note that if the parameter statements above are matched
+  ! incorrectly as assignments, the below specification
+  ! statements will be considered out-of-order and we see
+  ! 'unexpected specification statement'. A PARAMETER
+  ! statement should still be a specification statement.
+
+  real(8), intent(in) :: t
+  real(8), intent(out) :: x, y
+
+  real(8), volatile :: two
+  two = 2.0d0
+  x = two * pi_1 * f_1 * t
+  y = two * pi_2 * f_2 * t
+  z = two * pi_3 * f_3 * t
+  return
+end subroutine
+
+subroutine sub2(t, x, y, z)
+  implicit none
+  real(8) :: pi_1, pi_2, f_1, f_2
+           parameter   (pi_1 = 3.141592654d0, f_1 = 3.d08)
+           parameter    pi_2 = 3.141592654d0, f_2 = 3.d08 ! legacy PARAMETER
+  real(8), parameter :: pi_3 = 3.141592654d0, f_3 = 3.d08
+  ! Ditto sub1
+
+  real(8), intent(in) :: t
+  real(8), intent(out) :: x, y, z
+
+  real(8), volatile :: two
+  two = 2.0d0
+  x = two * pi_1 * f_1 * t
+  y = two * pi_2 * f_2 * t
+  z = two * pi_3 * f_3 * t
+end subroutine
+
+implicit none
+real(8) :: x1, x2, y1, y2, z2
+real(8), volatile :: t
+t = 1.5e-6
+
+call sub1(t, x1, y1)
+call sub2(t, x2, y2, z2)
+
+write(*,'(4D18.5)') t, x1, y1
+write(*,'(4D18.5)') t, x2, y2, z2
+
+if (x1 .ne. x2 .or. y1 .ne. y2 &
+    .or. x1 .ne. y1 .or. x2 .ne. y2 &
+    .or. y2 .ne. z2) then
+  call abort()
+endif
+
+end
diff --git a/gcc/testsuite/gfortran.dg/dec/parameter_3.f90 b/gcc/testsuite/gfortran.dg/dec/parameter_3.f90
new file mode 100644
index 00000000000..92f0f61bb66
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/parameter_3.f90
@@ -0,0 +1,13 @@
+! { dg-do compile }
+! { dg-options "-ffree-form -std=gnu" }
+!
+! Test warnings for DEC-style PARAMETER statements with std=gnu.
+!
+
+subroutine sub()
+  implicit real(8) (A-Z)
+  parameter pi = 3.1415926535d0 ! { dg-warning "Legacy Extension: PARAMETER" }
+  print *, pi
+end subroutine
+
+end
diff --git a/gcc/testsuite/gfortran.dg/dec/parameter_4.f90 b/gcc/testsuite/gfortran.dg/dec/parameter_4.f90
new file mode 100644
index 00000000000..280d56c424f
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/parameter_4.f90
@@ -0,0 +1,13 @@
+! { dg-do compile }
+! { dg-options "-ffree-form -std=f95" }
+!
+! Test errors for DEC-style PARAMETER statements with a real standard.
+!
+
+subroutine sub()
+  implicit real(8) (A-Z)
+  parameter pi = 3.1415926535d0 ! { dg-error "Legacy Extension: PARAMETER" }
+  print *, pi
+end subroutine
+
+end
diff --git a/gcc/testsuite/gfortran.dg/dec/static_1.f b/gcc/testsuite/gfortran.dg/dec/static_1.f
new file mode 100644
index 00000000000..85c4afa95aa
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/static_1.f
@@ -0,0 +1,31 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-static -finit-local-zero" }
+      !
+      ! Test AUTOMATIC and STATIC attributes.
+      !
+      include 'assert.inc'
+
+      function f (x, y)
+        integer f, x, y, a      ! only a can actually be saved
+        integer, automatic :: c ! should actually be automatic
+        save
+
+        ! a should be incremented by x every time and saved
+        a = a + x 
+        f = a
+
+        ! c should be zeroed every time, therefore equal y
+        c = c + y 
+        call assertll ("f%c", c, y)
+        return
+      endfunction
+
+      implicit none
+      integer f
+
+      ! Should return static value of a; accumulates x
+      call assertll ("f()", f(1,3), 1)
+      call assertll ("f()", f(1,4), 2)
+      call assertll ("f()", f(1,2), 3)
+
+      end
diff --git a/gcc/testsuite/gfortran.dg/dec/static_2.f b/gcc/testsuite/gfortran.dg/dec/static_2.f
new file mode 100644
index 00000000000..2da7d15944d
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/static_2.f
@@ -0,0 +1,50 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-static -fno-automatic -finit-local-zero" }
+      !
+      ! Make sure a warning is produced when variables marked AUTOMATIC
+      ! cannot be automatic due to compilation with -fno-automatic, and
+      ! that they are in fact still saved.
+      !
+      include 'assert.inc'
+
+      function f (x)
+      implicit none
+        integer f, x
+        integer, static :: a ! should be SAVEd
+        a = a + x ! should increment by x every time
+        f = a
+        return
+      endfunction
+
+      recursive subroutine g (x)
+      implicit none
+        integer x
+        integer, automatic :: a ! should be automatic (in recursive)
+        a = a + x ! should be set to x every time
+        call assertll ("g%a", a, x)
+      endsubroutine
+
+      subroutine h (x)
+      implicit none
+        integer x
+        integer, automatic :: a ! should be automatic (outside recursive)
+        a = a + x ! should be set to x every time
+        call assertll ("h%a", a, x)
+      endsubroutine
+
+      integer f
+
+      ! Should return static value of c; accumulates x
+      call assertll ("f()", f(3), 3)
+      call assertll ("f()", f(4), 7)
+      call assertll ("f()", f(2), 9)
+
+      call g(3)
+      call g(4)
+      call g(2)
+
+      call h(3)
+      call h(4)
+      call h(2)
+
+      end
diff --git a/gcc/testsuite/gfortran.dg/dec/struct_adhoc.f b/gcc/testsuite/gfortran.dg/dec/struct_adhoc.f
new file mode 100644
index 00000000000..5e2b9af08f9
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/struct_adhoc.f
@@ -0,0 +1,52 @@
+! { dg-do run }
+! { dg-options "-ffree-form -fdec-structure" }
+!
+! Test nested STRUCTURE definitions.
+!
+
+subroutine aborts (s)
+  character(*), intent(in) :: s
+  print *, s
+  call abort()
+end subroutine
+
+structure /s3/
+  real p
+  structure /s4/ recrd, recrd_a(3)
+    integer i, j
+  end structure
+  real q
+end structure
+
+record /s3/ r3
+record /s4/ r4
+
+r3.p = 1.3579
+r4.i = 0
+r4.j = 1
+r3.recrd = r4
+r3.recrd_a(1) = r3.recrd
+r3.recrd_a(2).i = 1
+r3.recrd_a(2).j = 0
+
+if (r3.p .ne. 1.3579) then
+  call aborts("r3.p")
+endif
+
+if (r4.i .ne. 0) then
+  call aborts("r4.i")
+endif
+
+if (r4.j .ne. 1) then
+  call aborts("r4.j")
+endif
+
+if (r3.recrd.i .ne. 0 .or. r3.recrd.j .ne. 1) then
+  call aborts("r3.recrd")
+endif
+
+if (r3.recrd_a(2).i .ne. 1 .or. r3.recrd_a(2).j .ne. 0) then
+  call aborts("r3.recrd_a(2)")
+endif
+
+end
diff --git a/gcc/testsuite/gfortran.dg/dec/struct_anon.f b/gcc/testsuite/gfortran.dg/dec/struct_anon.f
new file mode 100644
index 00000000000..9a80ebc3091
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/struct_anon.f
@@ -0,0 +1,32 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-structure" }
+      !
+      ! Test anonymous ad-hoc structure components.
+      !
+      include 'assert.inc'
+
+      program main
+
+      structure /appointment/
+      structure time_start, time_end
+        integer*1       hour, minute 
+      end structure 
+      logical         app_flag 
+      end structure
+
+      record /appointment/ tomorrow
+
+      tomorrow.time_start.hour = 15
+      tomorrow.time_start.minute = 0
+      tomorrow.time_end.hour = 16
+      tomorrow.time_end.minute = 0
+      tomorrow.app_flag = .true.
+
+      call assertbb ("time_start.hour", tomorrow.time_start.hour, 15_1)
+      call assertbb ("time_start.minute", tomorrow.time_start.minute, 
+     & 0_1)
+      call assertbb ("time_end.hour", tomorrow.time_end.hour, 16_1)
+      call assertbb ("time_end.minute", tomorrow.time_end.minute, 0_1)
+      call assert   ("app_flag", tomorrow.app_flag)
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/struct_array.f b/gcc/testsuite/gfortran.dg/dec/struct_array.f
new file mode 100644
index 00000000000..730431320b9
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/struct_array.f
@@ -0,0 +1,27 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-structure" }
+      !
+      ! Test arrays of structures.
+      !
+      include 'assert.inc'
+      program main
+      implicit none
+
+      structure /t/
+        integer z
+      end structure
+
+      structure /big/
+        integer x
+        record /t/ y
+      end structure
+
+      record /big/ array(10)
+      integer i 
+
+      array(3).y.z = 10
+      i = array(3).y.z
+
+      call assertll ("array(3).y.z", i, 10)
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/struct_basic.f b/gcc/testsuite/gfortran.dg/dec/struct_basic.f
new file mode 100644
index 00000000000..c8291b2e744
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/struct_basic.f
@@ -0,0 +1,60 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-structure" }
+      !
+      ! Test basic semantics of the STRUCTURE extension.
+      !
+      include 'assert.inc'
+
+      program main
+
+      ! Declaring a structure named ``item'' and containing three fields:
+      ! an integer ID, an description string and a floating-point price.
+      STRUCTURE /item/
+        INTEGER id
+        LOGICAL expensive
+        CHARACTER(LEN=200) description
+        REAL price
+      END STRUCTURE
+
+      ! Equivalent to:
+      !TYPE item
+      !  INTEGER id
+      !  LOGICAL expensive
+      !  CHARACTER(LEN=200) description
+      !  REAL price
+      !END TYPE
+
+      ! Define two variables, an single record of type ``item''
+      ! named ``pear'', and an array of items named ``store_catalog''
+      RECORD /item/ pear, store_catalog(100)
+      ! equivalent to:
+      !TYPE(item) pear, store_catalog(100)
+
+      ! We can directly access the fields of both variables
+      pear.id = 92316
+      pear.description = "juicy D'Anjou pear"
+      pear.price = 0.15
+      pear.expensive = .FALSE.
+      store_catalog(7).id = 7831
+      store_catalog(7).description = "milk bottle"
+      store_catalog(7).price = 1.2
+
+      ! Instead of using a dot (.) to access fields of a record, the
+      ! standard syntax uses a percent sign (%)
+      !pear%id = 92316
+      !pear%description = "juicy D'Anjou pear"
+      !pear%price = 0.15
+      !store_catalog(7)%id = 7831
+      !store_catalog(7)%description = "milk bottle"
+      !store_catalog(7)%price = 1.2
+
+      ! Assignments of a whole variable do not change
+      store_catalog(12) = pear
+
+      call assertll ("pear.id", pear%id, 92316)
+      call assertrr ("pear.price", pear%price, 0.15)
+      call assertll ("store_catalog(7).id", store_catalog(7)%id, 7831)
+      call assertrr ("store_catalog(7).price", store_catalog(7)%price,
+     & 1.2)
+
+      end program main
diff --git a/gcc/testsuite/gfortran.dg/dec/struct_fill_bad.f b/gcc/testsuite/gfortran.dg/dec/struct_fill_bad.f
new file mode 100644
index 00000000000..acb1bfe7e5c
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/struct_fill_bad.f
@@ -0,0 +1,18 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-structure" }
+      !
+      ! Test error handling for %FILL
+      !
+      program main
+
+      structure /s/
+        integer*2 i /3/
+        integer*2 %fill /4/ ! { dg-error "Unnamed field.*initializer" }
+        integer*2, pointer :: %fill ! { dg-error "Unnamed field.*attribute" }
+      end structure
+
+      type t
+        integer %fill ! { dg-error "Unnamed field.*allowed" }
+      endtype
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/struct_fill_fixed.f b/gcc/testsuite/gfortran.dg/dec/struct_fill_fixed.f
new file mode 100644
index 00000000000..2d4268c55ac
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/struct_fill_fixed.f
@@ -0,0 +1,32 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-structure" }
+      !
+      ! Test the %FILL component extension.
+      !
+      include 'assert.inc'
+
+      program main
+
+      structure /s/
+        integer*2 i
+        integer*2 %fill
+        integer*2 j
+      end structure
+
+      structure /s2/
+        character buf(6)
+      end structure
+
+      record /s/ x
+      record /s2/ y
+      equivalence (x, y)
+
+      x.i = z'3130'
+      x.j = z'3332'
+
+      call assertss ("[0]", y.buf(1), "0")
+      call assertss ("[1]", y.buf(2), "1")
+      call assertss ("[2]", y.buf(5), "2")
+      call assertss ("[3]", y.buf(6), "3")
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/struct_fill_free.f b/gcc/testsuite/gfortran.dg/dec/struct_fill_free.f
new file mode 100644
index 00000000000..b0c1a97e3cc
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/struct_fill_free.f
@@ -0,0 +1,32 @@
+! { dg-do compile }
+! { dg-options "-fdec-structure -ffree-form" }
+!
+! Test the %FILL component extension.
+!
+include 'assert.inc'
+
+program main
+
+structure /s/
+  integer*2 i
+  integer*2 %fill
+  integer*2 j
+end structure
+
+structure /s2/
+  character buf(6)
+end structure
+
+record /s/ x
+record /s2/ y
+equivalence (x, y)
+
+x.i = z'3130'
+x.j = z'3332'
+
+call assertss ("[0]", y.buf(1), "0")
+call assertss ("[1]", y.buf(2), "1")
+call assertss ("[2]", y.buf(5), "2")
+call assertss ("[3]", y.buf(6), "3")
+
+end program
diff --git a/gcc/testsuite/gfortran.dg/dec/struct_name_comp.f b/gcc/testsuite/gfortran.dg/dec/struct_name_comp.f
new file mode 100644
index 00000000000..d82bda75279
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/struct_name_comp.f
@@ -0,0 +1,17 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-structure" }
+      !
+      ! Make sure the name of a component does not conflict with the name of a
+      ! variable. 
+      !
+      program main
+
+      structure /t1/
+        integer*4 comp
+      end structure
+      record /t1/ comp
+      structure /t2/
+        integer*4 comp
+      end structure
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/struct_name_share.f b/gcc/testsuite/gfortran.dg/dec/struct_name_share.f
new file mode 100644
index 00000000000..7177a7327e3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/struct_name_share.f
@@ -0,0 +1,13 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-structure" }
+      !
+      ! Make sure variables can share names with structures.
+      !
+      program main
+
+      structure /TY/
+        integer i
+      end structure
+      record /TY/ ty
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/struct_record.f b/gcc/testsuite/gfortran.dg/dec/struct_record.f
new file mode 100644
index 00000000000..6af87d477f2
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/struct_record.f
@@ -0,0 +1,39 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-structure" }
+      !
+      ! Verify a structure containing a record.
+      !
+      include 'assert.inc'
+
+      program main
+
+      structure /person/ 
+          character(20) name
+          integer(1) age
+      end structure
+
+      structure /car/
+          record /person/ owner
+          character(10)   make
+          character(10)   model
+          integer(4)      year
+      end structure
+
+      record /person/ me
+      record /car/ mycar
+
+      me.name = "fritz"
+      me.age = 21
+
+      mycar.owner = me
+      mycar.make = "volkswagen"
+      mycar.model = "jetta"
+      mycar.year = 2013
+
+      call assertss ("me.name", me.name, "fritz")
+      call assertbb ("me.age", me.age,  21_1)
+      call assertss ("mycar.make", mycar.make,  "volkswagen")
+      call assertss ("mycar.model", mycar.model, "jetta")
+      call assertll ("mycar.year", mycar.year,  2013)
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/structure_13.f90 b/gcc/testsuite/gfortran.dg/dec/structure_13.f90
new file mode 100644
index 00000000000..209c7da597d
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/structure_13.f90
@@ -0,0 +1,79 @@
+! { dg-do compile }
+! { dg-options "-fdec-structure" }
+!
+! Verify that the comparisons in gfc_compare_derived_types can correctly
+! match nested anonymous subtypes.
+!
+
+subroutine sub0 (u)
+  structure /t/
+    structure sub
+      integer i
+    end structure
+  endstructure
+  record /t/ u
+  u.sub.i = 0
+end subroutine sub0
+
+subroutine sub1 ()
+  structure /t/
+    structure sub
+      integer i
+    end structure
+  endstructure
+  record /t/ u
+
+  interface
+    subroutine sub0 (u) ! regression: Interface mismatch.*Type mismatch
+      structure /t/
+        structure sub
+          integer i
+        end structure
+      endstructure
+        record /t/ u
+    end subroutine
+  end interface
+
+  call sub0(u) ! regression: Type mismatch in argument
+end subroutine
+
+subroutine sub3(u)
+  structure /tu/
+    union
+      map
+        integer i
+      end map
+      map
+        real r
+      end map
+    end union
+  end structure
+  record /tu/ u
+  u.r = 1.0
+end subroutine
+
+structure /t/
+  structure sub
+    integer i
+  end structure
+endstructure
+
+structure /tu/
+  union
+    map
+      integer i
+    end map
+    map
+      real r
+    end map
+  end union
+end structure
+
+record /t/ u
+record /tu/ u2
+
+call sub0(u) ! regression: Type mismatch in argument
+call sub1()
+call sub2(u2)
+
+end
diff --git a/gcc/testsuite/gfortran.dg/dec/test.txt b/gcc/testsuite/gfortran.dg/dec/test.txt
new file mode 100644
index 00000000000..1e3cfd54d1f
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/test.txt
@@ -0,0 +1,4 @@
+This is a line from a file.
+This file has two lines.
+Actually there are more than two lines.
+What does this mean? I don't know.
diff --git a/gcc/testsuite/gfortran.dg/dec/teststructs.inc b/gcc/testsuite/gfortran.dg/dec/teststructs.inc
new file mode 100644
index 00000000000..1277a088bb5
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/teststructs.inc
@@ -0,0 +1,26 @@
+      IMPLICIT NONE
+      STRUCTURE /T1/
+        UNION
+        MAP
+        INTEGER*4 I
+        END MAP
+        MAP
+        INTEGER*2 IH
+        INTEGER*2 IL
+        END MAP
+        END UNION
+        INTEGER*4 IT1
+      END STRUCTURE
+
+      STRUCTURE /T2/
+        UNION
+        MAP
+        INTEGER*4 J
+        END MAP
+        MAP
+        INTEGER*2 JH
+        INTEGER*2 JL
+        END MAP
+        END UNION
+        INTEGER*4 IT2
+      END STRUCTURE
diff --git a/gcc/testsuite/gfortran.dg/dec/union_basic1.f b/gcc/testsuite/gfortran.dg/dec/union_basic1.f
new file mode 100644
index 00000000000..b30ac72bbed
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/union_basic1.f
@@ -0,0 +1,27 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-structure" }
+      !
+      ! Tests a basic union.
+      !
+
+      include 'assert.inc'
+      program main
+
+      structure /test/
+        union
+        map
+          integer a
+        end map
+        map
+          real b
+        end map
+        end union
+      end structure
+
+      record /test/ x
+
+      x.b = 1.357e2
+
+      call assertll ("(int) 1.357e2", x.a, 1124578099)
+
+      end program main
diff --git a/gcc/testsuite/gfortran.dg/dec/union_basic2.f b/gcc/testsuite/gfortran.dg/dec/union_basic2.f
new file mode 100644
index 00000000000..1c366bf165c
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/union_basic2.f
@@ -0,0 +1,34 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-structure" }
+      !
+      ! Tests a basic union.
+      !
+
+      include 'assert.inc'
+      program main
+
+      structure /test/
+        integer*4 long
+      end structure
+
+      structure /words_long/ 
+        union 
+          map 
+            integer*2  w1, w2
+          end map 
+          map 
+            integer*4  long
+          end map 
+        end union 
+      end structure 
+
+      record /words_long/ x
+      record /test/ t
+      integer*2, parameter :: w1 = z'1234', w2 = z'5678'
+
+      x.long = z'56781234'
+
+      call assertii ("x.w1", x.w1, w1)
+      call assertii ("x.w2", x.w2, w2)
+
+      end program main
diff --git a/gcc/testsuite/gfortran.dg/dec/union_compare.f b/gcc/testsuite/gfortran.dg/dec/union_compare.f
new file mode 100644
index 00000000000..4ea1e48bc55
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/union_compare.f
@@ -0,0 +1,35 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-structure" }
+      !
+      ! teststructs.inc contains declarations for types T1 and T2, which are
+      ! equivalent but with different member names (so not equal)
+
+      SUBROUTINE COMPARE (A, B)
+      include 'teststructs.inc'
+
+      RECORD /T1/ A
+      RECORD /T1/ B
+
+      if ( A.I .eq. B.I ) then
+        PRINT *, "(cmp) pass"
+      else
+        PRINT *, "FAIL!!!!"
+        call abort
+      endif
+      END SUBROUTINE
+
+
+      PROGRAM MAIN
+      include 'teststructs.inc'
+
+      RECORD /T1/ X
+      RECORD /T2/ Y
+
+      X.IT1 = 200
+      X.I = 100
+      Y.J = 100
+
+      CALL COMPARE (X, X)
+      !CALL COMPARE (X, Y) ! should complain (?)
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/union_copy.f b/gcc/testsuite/gfortran.dg/dec/union_copy.f
new file mode 100644
index 00000000000..6429258160c
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/union_copy.f
@@ -0,0 +1,71 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-structure" }
+      !
+      ! Tests whether union backend declarations are correctly /not/
+      ! copied when they are not in fact equal.
+
+      include 'assert.inc'
+
+      function test1 (x)
+      implicit none
+      integer x, test1
+
+      ! The BUFFER structure is first seen here.
+      integer*4 L_bbuf
+      parameter (L_bbuf=1024)
+      include 'buffer.inc'
+      record /buffer/ buf
+
+      buf.lbuf(1) = z'badbeef'
+      buf.lbuf(2) = z'badbeef'
+      buf.lbuf(3) = z'badbeef'
+      buf.lbuf(4) = z'badbeef'
+
+      if (x .ge. 0 .and. x .le. 4) then
+        test1 = buf.lbuf(x)
+      else
+        test1 = buf.lbuf(1)
+      endif
+
+      return
+      endfunction
+
+      function test2 (x)
+      implicit none
+      integer x, test2
+
+      ! This is the second BUFFER structure, seen with different
+      ! parameters. Though the declarations are identical, the backend
+      ! from the first union should NOT be copied since it is of
+      ! different size. If it is in fact copied, this may cause
+      ! discrepancies in translation leading to overwriting important
+      ! pieces of the stack due to initialization (such as the return value).
+      integer*4 L_bbuf
+      parameter (L_bbuf=65536)
+      include 'buffer.inc'
+      record /buffer/ buf
+
+      buf.lbuf(1) = z'beefbad'
+      buf.lbuf(2) = z'beefbad'
+      buf.lbuf(3) = z'beefbad'
+      buf.lbuf(4) = z'beefbad'
+
+      if (x .ge. 0 .and. x .le. 4) then
+        test2 = buf.lbuf(x)
+      else
+        test2 = buf.lbuf(1)
+      endif
+
+      return
+      endfunction
+
+      program main
+      implicit none
+      integer x, y, test1, test2
+
+      x = test1(2)
+      y = test2(3)
+      call assertll ("test1", x, 195935983) ! 0xbadbeef
+      call assertll ("test2", y, 200211373) ! 0xbeefbad
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/union_dup.f b/gcc/testsuite/gfortran.dg/dec/union_dup.f
new file mode 100644
index 00000000000..53cd8d9d381
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/union_dup.f
@@ -0,0 +1,39 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-structure" }
+      !
+      ! Tests whether the compiler correctly complains when a member has been
+      ! declared twice in unions, including a nested sense.
+      !
+
+      program main
+
+      structure /test/
+        union
+
+          map
+            integer x ! { dg-error "already declared" }
+          end map
+
+          map
+            integer y ! { dg-error "already declared" }
+
+            union 
+
+              map
+                integer x ! { dg-error "already declared" }
+              end map
+
+              map
+                structure y ! { dg-error "already declared" }
+                  integer*1 hour, minute 
+                end structure  ! { dg-error "Expecting END MAP" }
+              end map
+
+            end union
+
+          end map
+
+        end union
+      end structure
+
+      end program main
diff --git a/gcc/testsuite/gfortran.dg/dec/union_empty.f b/gcc/testsuite/gfortran.dg/dec/union_empty.f
new file mode 100644
index 00000000000..65abd0a357e
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/union_empty.f
@@ -0,0 +1,17 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-structure" }
+      !
+      ! Allow compilation of a structure with an empty union.
+      !
+      program main
+      structure /test/
+        integer i
+        union
+          map
+          end map
+          map
+          end map
+        end union
+      end structure
+      end program main
+
diff --git a/gcc/testsuite/gfortran.dg/dec/union_init_def.f b/gcc/testsuite/gfortran.dg/dec/union_init_def.f
new file mode 100644
index 00000000000..b5ce998c2c2
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/union_init_def.f
@@ -0,0 +1,38 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-structure -finit-local-zero -finit-derived" }
+      !
+      ! Test initialization of a structure containing a union with -finit-derived.
+      !
+
+      include 'assert.inc'
+      program main
+
+      structure /test/
+        integer*4 long
+      end structure
+
+      structure /words_long/ 
+        union 
+          map 
+      integer*2  w1, w2, w3 
+          end map 
+          map 
+      integer*4  long
+          end map 
+        end union 
+      end structure 
+
+      record /words_long/ x
+      record /test/ t
+
+      call assertii ("x.w1", x.w1, 0_2)
+      call assertii ("x.w2", x.w2, 0_2)
+      call assertii ("x.w3", x.w3, 0_2)
+
+      x.long = z'56781234'
+
+      call assertii ("x.w1", x.w1, 4660_2)  ! 0x1234
+      call assertii ("x.w2", x.w2, 22136_2) ! 0x5678
+      call assertii ("x.w3", x.w3, 0_2)     ! untouched
+
+      end program main
diff --git a/gcc/testsuite/gfortran.dg/dec/union_init_exp.f b/gcc/testsuite/gfortran.dg/dec/union_init_exp.f
new file mode 100644
index 00000000000..21a9cd993a0
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/union_init_exp.f
@@ -0,0 +1,36 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-structure -finit-derived -finit-local-zero" }
+      !
+      ! Test explicit initialization expressions within unions mixed with
+      ! -finit-derived.
+      !
+
+      include 'assert.inc'
+      program main
+
+      structure /test/
+      integer :: i = 8
+      union
+      map
+      integer*2 :: x = 1600
+      integer*2 :: y = 1600
+      end map
+      map
+      integer*2 a,b,c,d,e
+      end map
+      end union
+      end structure
+
+      record /test/ t
+
+      call assertll ("i", t.i, 8)
+      call assertii ("x", t.x, 1600_2)
+      call assertii ("x", t.x, 1600_2)
+
+      call assertii ("a", t.a, 1600_2)
+      call assertii ("b", t.b, 1600_2)
+      call assertii ("c", t.c, 0_2)
+      call assertii ("d", t.d, 0_2)
+      call assertii ("e", t.e, 0_2)
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/union_init_overlap.f b/gcc/testsuite/gfortran.dg/dec/union_init_overlap.f
new file mode 100644
index 00000000000..5c8c8efc319
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/union_init_overlap.f
@@ -0,0 +1,38 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-structure" }
+      !
+      ! This program gives a warning with gfortran because the
+      ! initialization of Z overwrites the initializations given in X
+      ! and Y.
+
+      ! The Intel documentation states that the last initializer to
+      ! appear is the prevailing initializer; however, ifort 11.1 does
+      ! not seem to follow this (it seems to use the initializers for X
+      ! and Y rather than Z).
+
+      ! The correct behavior in the future is to initialize the first
+      ! four bytes of the union with 7777777 and the last two bytes
+      ! with 100.
+      program main
+
+      structure /test/
+      integer :: i = 8
+      union
+      map ! { dg-warning "overwritten by initializer" }
+      integer*2 :: x = 1600
+      integer*2 :: y = 1600
+      end map
+      map ! { dg-warning "overwritten by initializer" }
+      integer*4 :: z = 7777777
+      end map
+      map ! { dg-warning "overwritten by initializer" }
+      integer*4 a,b,c,d
+      integer*2 :: e = 100
+      end map
+      end union
+      end structure
+
+      record /test/ t
+      print *, t.z
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/union_interface.f b/gcc/testsuite/gfortran.dg/dec/union_interface.f
new file mode 100644
index 00000000000..9c8e18fcfc3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/union_interface.f
@@ -0,0 +1,55 @@
+! { dg-do compile }
+! { dg-options "-fdec-structure" }
+! This tests regressions for a bug where calling gfc_use_derived from
+! gfc_find_component in build_struct caused the structure type symbol to be
+! immediately switched out for the previously declared s0, freeing the actual
+! type symbol being parsed.
+!
+! Apparently gfc_find_component is intended to be used only during resolution;
+! the fix to this was to only call gfc_use_derived on FL_DERIVED type symbols.
+! They should be completely parsed by the time gfc_find_component is used,
+! whereas structure-like types aren't fully defined when they need to be used.
+!
+
+      subroutine sub0(a)
+        structure /s0/
+          union
+            map
+              real d
+            end map
+          end union
+        end structure
+        record /s0/ a
+
+        a.d = 0
+      end subroutine
+
+      subroutine sub1()
+        structure /s0/
+          union
+            map
+              real d
+            end map
+          end union
+        end structure
+        record /s0/ a
+
+        interface
+          subroutine sub0 (a)
+            structure /s0/
+              union
+                map
+                  real d ! formerly gfc_use_derived here freed this s0 typesym
+                end map
+              end union
+            end structure
+            record /s0/ a
+          end subroutine
+        end interface
+
+        call sub0(a)
+      end subroutine
+
+      program main
+        call sub1()
+      end
diff --git a/gcc/testsuite/gfortran.dg/dec/union_nested1.f b/gcc/testsuite/gfortran.dg/dec/union_nested1.f
new file mode 100644
index 00000000000..82a0b343392
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/union_nested1.f
@@ -0,0 +1,72 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-structure -fno-range-check" }
+      !
+      ! Test the correctness of nested unions.
+      !
+
+      include 'assert.inc'
+      program main
+      implicit none
+
+      structure /nest/
+      integer*4 a
+
+      union     ! u1
+      map ! u1.m1
+        integer*4 b
+        integer*4 c
+      end map
+      map ! u1.m2
+        integer*2 d
+        integer*2 e
+        integer*4 f
+      end map
+      map ! u1.m3
+        integer*4 w
+        union   ! u1.u2
+        map     ! u1.u2.m1
+          integer*2 x 
+          integer*2 y
+        end map
+        map     ! u1.u2.m2
+          integer*4 z
+        end map
+        end union
+      end map
+      end union
+
+      union     ! u2
+      map ! u2.m1
+        integer*8 g
+        integer*4 h
+      end map
+
+      map ! u2.m2
+        integer*4 i
+        integer*8 j
+      end map
+      end union
+
+      end structure
+
+
+      record /nest/ s
+      ! Use parameters to get around casting problems with hex
+      integer*4, parameter :: b = z'0000ABCD'
+      integer*4, parameter :: c = z'FEEDBEEF'
+      integer*4, parameter :: h = z'FEFEDCBA'
+      integer*4, parameter :: i = z'87654321'
+
+      s.w = z'abcd'
+      s.x = z'beef'
+      s.y = z'feed'
+
+      s.g = z'1234567887654321'
+      S.J = z'ABCDEFeFFeFEDCBA'
+
+      call assertll ("s.b", s.b, b)
+      call assertll ("s.c", s.c, c)
+      call assertll ("s.h", s.h, h)
+      call assertll ("s.i", s.i, i)
+
+      end program main
diff --git a/gcc/testsuite/gfortran.dg/dec/union_nested2.f b/gcc/testsuite/gfortran.dg/dec/union_nested2.f
new file mode 100644
index 00000000000..aca046daef5
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/union_nested2.f
@@ -0,0 +1,80 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-structure -fno-range-check" }
+      !
+      ! Simulation of 64-bit intel register and its various access modes
+      ! using the fortran union construct. Tests correctness of nested unions.
+      !
+
+      include 'assert.inc'
+      program main
+
+      structure /reg/
+
+      union     ! rax
+      map
+        integer*8 rx
+        end map
+      map
+        integer*4 rh
+
+        union   ! eax
+        map
+          integer*4 rl
+          end map
+        map
+          integer*4 ex
+          end map
+        map
+          integer*2 eh
+
+          union ! ax
+          map
+      integer*2 el
+      end map
+          map
+      integer*2 x
+      end map
+          map
+      integer*1 h
+      integer*1 l
+          end map
+          end union
+
+        end map
+        end union
+
+      end map
+      end union
+
+      end structure
+
+
+      record /reg/ a ! rax
+
+      integer*8, parameter :: rax = z'AABBCCCCFFFFFFFF'
+      integer*4, parameter :: rah =         z'FFFFFFFF'
+      integer*4, parameter :: ral = z'AABBCCCC'
+
+      integer*4, parameter :: eax = z'AABBCCCC'
+      integer*2, parameter :: eah =     z'CCCC'
+      integer*2, parameter :: eal = z'AABB'
+
+      integer*2, parameter ::  ax = z'AABB'
+      integer*1, parameter ::  ah =   z'BB'
+      integer*1, parameter ::  al = z'AA'
+
+      a.rx = z'AABBCCCCFFFFFFFF'
+
+      call assertqq ('rax', a.rx, rax)
+      call assertll ('rah', a.rh, rah)
+      call assertll ('ral', a.rl, ral)
+
+      call assertll ('eax', a.ex, eax)
+      call assertii ('eah', a.eh, eah)
+      call assertii ('eal', a.el, eal)
+
+      call assertii (' ax',  a.x,  ax)
+      call assertbb (' ah',  a.h,  ah)
+      call assertbb (' al',  a.l,  al)
+
+      end program main
diff --git a/gcc/testsuite/gfortran.dg/dec/union_ref.f b/gcc/testsuite/gfortran.dg/dec/union_ref.f
new file mode 100644
index 00000000000..d64502a04ad
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/union_ref.f
@@ -0,0 +1,29 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-structure -fno-range-check" }
+      !
+      ! Ensure array and component references are calculated correctly for
+      ! unions.
+      !
+
+      include 'assert.inc'
+      program main
+
+      structure /test/
+      union
+        map
+          character*20 m
+        end map
+        map
+          integer*4 a, b, c
+        end map
+      end union
+      end structure
+
+      record /test/ x
+
+      x.m = "CDEFGHIJKLMNOPQRSTUV"
+
+      call assert ('x.m(1:1)', x.m(1:1).eq.'C')
+
+      END PROGRAM MAIN
+
diff --git a/gcc/testsuite/gfortran.dg/dec/warn_argtypes_1.for b/gcc/testsuite/gfortran.dg/dec/warn_argtypes_1.for
new file mode 100644
index 00000000000..c4d82fee865
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/warn_argtypes_1.for
@@ -0,0 +1,26 @@
+! { dg-do compile }
+! { dg-options "-Wargtype-mismatch" }
+!
+! Warn when %val()/%loc() cause type mismatches in arguments
+!
+
+subroutine printt (x)
+type t
+  real r
+end type
+type (t), intent(in) :: x
+print *, x%r
+end subroutine
+
+type t
+  real r
+end type
+type (t) y
+
+integer :: i
+i = loc(y)
+call printt (%loc(y)) ! { dg-warning "Type mismatch in argument" }
+call printt (%val(i)) ! { dg-warning "Type mismatch in argument" }
+
+end
+
diff --git a/gcc/testsuite/gfortran.dg/dec/warn_argtypes_2.for b/gcc/testsuite/gfortran.dg/dec/warn_argtypes_2.for
new file mode 100644
index 00000000000..a5e742f7640
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/warn_argtypes_2.for
@@ -0,0 +1,26 @@
+! { dg-do compile }
+! { dg-options "-Wno-argtype-mismatch" }
+!
+! Don't warn when %val()/%loc() cause type mismatches in arguments
+!
+
+subroutine printt (x)
+type t
+  real r
+end type
+type (t), intent(in) :: x
+print *, x%r
+end subroutine
+
+type t
+  real r
+end type
+type (t) y
+
+integer :: i
+i = loc(y)
+call printt (%loc(y))
+call printt (%val(i))
+
+end
+
diff --git a/gcc/testsuite/gfortran.dg/dec/xor.f b/gcc/testsuite/gfortran.dg/dec/xor.f
new file mode 100644
index 00000000000..ba251421a4b
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/xor.f
@@ -0,0 +1,27 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-logical-xor -ffixed-form" }
+      !
+      ! Test the logical XOR operator.
+      !
+
+      program main
+      implicit none
+      logical a, b, c, n, x, d(2)
+      integer i, j
+      d(1) = .true.
+      d(2) = .false.
+      do 10 i = 1,2
+        do 11 j = 1,2
+            a = d(j)
+            b = d(i)
+            n = a .neqv. b
+            x = a .xor. b
+            if ( n .neqv. x ) then
+                print *, "(",a,b,") fail!!!! NEQV: ", n, "  XOR: ", x
+                call abort
+            else
+                print *, "(",a,b,") PASS"
+            endif
+11      enddo
+10    enddo
+      end program main
diff --git a/gcc/testsuite/gfortran.dg/dg.exp b/gcc/testsuite/gfortran.dg/dg.exp
index 795ac8ee6b8..e3dfdfc9716 100644
--- a/gcc/testsuite/gfortran.dg/dg.exp
+++ b/gcc/testsuite/gfortran.dg/dg.exp
@@ -29,6 +29,10 @@ if ![info exists DEFAULT_FFLAGS] then {
 dg-init
 
 # Main loop.
+
+gfortran-dg-runtest [lsort \
+       [glob -nocomplain $srcdir/$subdir/dec/*.\[fF\] ] ] $DEFAULT_FFLAGS
+
 gfortran-dg-runtest [lsort \
        [glob -nocomplain $srcdir/$subdir/*.\[fF\]{,90,95,03,08} ] ] $DEFAULT_FFLAGS
 
diff --git a/gcc/testsuite/gfortran.dg/fmt_pf.f90 b/gcc/testsuite/gfortran.dg/fmt_pf.f90
new file mode 100644
index 00000000000..6cefa86e4a8
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/fmt_pf.f90
@@ -0,0 +1,226 @@
+! { dg-do run }
+! PR70235 Incorrect output with PF format.
+! Test case provided by Antoine Gardeux.
+program pr70235
+use ISO_FORTRAN_ENV
+    implicit none
+    integer, parameter :: j(size(real_kinds)+4)=[REAL_KINDS, [4, 4, 4, 4]]
+    logical :: l_skip(4) = .false.
+    integer :: i
+    integer :: n_tst = 0, n_cnt = 0, n_skip = 0
+    character(len=20) :: s, s1
+
+!   Check that the default rounding mode is to nearest and to even on tie.
+    do i=1,size(real_kinds)
+      if (i == 1) then
+        write(s, '(2F4.1,2F4.0)') real(-9.49999905,kind=j(1)), &
+                                  real(9.49999905,kind=j(1)),  &
+                                  real(9.5,kind=j(1)), real(8.5,kind=j(1))
+        write(s1, '(3PE10.3,2PE10.3)') real(987350.,kind=j(1)), &
+                                       real(98765.0,kind=j(1))
+      else if (i == 2) then
+        write(s, '(2F4.1,2F4.0)') real(-9.49999905,kind=j(2)), &
+                                  real(9.49999905,kind=j(2)),  &
+                                  real(9.5,kind=j(2)), real(8.5,kind=j(2))
+        write(s1, '(3PE10.3,2PE10.3)') real(987350.,kind=j(2)), &
+                                       real(98765.0,kind=j(2))
+      else if (i == 3) then
+        write(s, '(2F4.1,2F4.0)') real(-9.49999905,kind=j(3)), &
+                                  real(9.49999905,kind=j(3)),  &
+                                  real(9.5,kind=j(3)), real(8.5,kind=j(3))
+        write(s1, '(3PE10.3,2PE10.3)') real(987350.,kind=j(3)), &
+                                       real(98765.0,kind=j(3))
+      else if (i == 4) then
+        write(s, '(2F4.1,2F4.0)') real(-9.49999905,kind=j(4)), &
+                                  real(9.49999905,kind=j(4)),  &
+                                  real(9.5,kind=j(4)), real(8.5,kind=j(4))
+        write(s1, '(3PE10.3,2PE10.3)') real(987350.,kind=j(4)), &
+                                       real(98765.0,kind=j(4))
+      end if
+      if (s /= '-9.5 9.5 10.  8.' .or. s1 /= ' 987.4E+03 98.76E+03') then
+        l_skip(i) = .true.
+!        print "('Unsupported rounding for real(',i0,')')", j(i)
+      end if
+    end do
+        
+
+! Original test.
+    call checkfmt("(-6PF8.3)", 1.0e4,    "   0.010")
+    call checkfmt("(-6PF8.3)",   0.0,    "   0.000")
+
+! Test for the bug in comment 6.
+    call checkfmt("(-8pf18.3)", 643.125, "             0.000")
+    call checkfmt("(-7pf18.3)", 643.125, "             0.000")
+    call checkfmt("(-6pf18.3)", 643.125, "             0.001")
+    call checkfmt("(-5pf18.3)", 643.125, "             0.006")
+    call checkfmt("(-4pf18.3)", 643.125, "             0.064")
+    call checkfmt("(-3pf18.3)", 643.125, "             0.643")
+    call checkfmt("(-2pf18.3)", 643.125, "             6.431")
+    call checkfmt("(-1pf18.3)", 643.125, "            64.312")
+    call checkfmt("( 0pf18.3)", 643.125, "           643.125")
+
+    call checkfmt("(ru,-8pf18.3)", 643.125, "             0.001")
+    call checkfmt("(ru,-7pf18.3)", 643.125, "             0.001")
+    call checkfmt("(ru,-6pf18.3)", 643.125, "             0.001")
+    call checkfmt("(ru,-5pf18.3)", 643.125, "             0.007")
+    call checkfmt("(ru,-4pf18.3)", 643.125, "             0.065")
+    call checkfmt("(ru,-3pf18.3)", 643.125, "             0.644")
+    call checkfmt("(ru,-2pf18.3)", 643.125, "             6.432")
+    call checkfmt("(ru,-1pf18.3)", 643.125, "            64.313")
+    call checkfmt("(ru, 0pf18.3)", 643.125, "           643.125")
+
+    call checkfmt("(rd,-8pf18.3)", 643.125, "             0.000")
+    call checkfmt("(rd,-7pf18.3)", 643.125, "             0.000")
+    call checkfmt("(rd,-6pf18.3)", 643.125, "             0.000")
+    call checkfmt("(rd,-5pf18.3)", 643.125, "             0.006")
+    call checkfmt("(rd,-4pf18.3)", 643.125, "             0.064")
+    call checkfmt("(rd,-3pf18.3)", 643.125, "             0.643")
+    call checkfmt("(rd,-2pf18.3)", 643.125, "             6.431")
+    call checkfmt("(rd,-1pf18.3)", 643.125, "            64.312")
+    call checkfmt("(rd, 0pf18.3)", 643.125, "           643.125")
+
+    call checkfmt("(rz,-8pf18.3)", 643.125, "             0.000")
+    call checkfmt("(rz,-7pf18.3)", 643.125, "             0.000")
+    call checkfmt("(rz,-6pf18.3)", 643.125, "             0.000")
+    call checkfmt("(rz,-5pf18.3)", 643.125, "             0.006")
+    call checkfmt("(rz,-4pf18.3)", 643.125, "             0.064")
+    call checkfmt("(rz,-3pf18.3)", 643.125, "             0.643")
+    call checkfmt("(rz,-2pf18.3)", 643.125, "             6.431")
+    call checkfmt("(rz,-1pf18.3)", 643.125, "            64.312")
+    call checkfmt("(rz, 0pf18.3)", 643.125, "           643.125")
+
+    call checkfmt("(rc,-8pf18.3)", 643.125, "             0.000")
+    call checkfmt("(rc,-7pf18.3)", 643.125, "             0.000")
+    call checkfmt("(rc,-6pf18.3)", 643.125, "             0.001")
+    call checkfmt("(rc,-5pf18.3)", 643.125, "             0.006")
+    call checkfmt("(rc,-4pf18.3)", 643.125, "             0.064")
+    call checkfmt("(rc,-3pf18.3)", 643.125, "             0.643")
+    call checkfmt("(rc,-2pf18.3)", 643.125, "             6.431")
+    call checkfmt("(rc,-1pf18.3)", 643.125, "            64.313")
+    call checkfmt("(rc, 0pf18.3)", 643.125, "           643.125")
+
+    call checkfmt("(rn,-8pf18.3)", 643.125, "             0.000")
+    call checkfmt("(rn,-7pf18.3)", 643.125, "             0.000")
+    call checkfmt("(rn,-6pf18.3)", 643.125, "             0.001")
+    call checkfmt("(rn,-5pf18.3)", 643.125, "             0.006")
+    call checkfmt("(rn,-4pf18.3)", 643.125, "             0.064")
+    call checkfmt("(rn,-3pf18.3)", 643.125, "             0.643")
+    call checkfmt("(rn,-2pf18.3)", 643.125, "             6.431")
+    call checkfmt("(rn,-1pf18.3)", 643.125, "            64.312")
+    call checkfmt("(rn, 0pf18.3)", 643.125, "           643.125")
+
+    call checkfmt("(rp,-8pf18.3)", 643.125, "             0.000")
+    call checkfmt("(rp,-7pf18.3)", 643.125, "             0.000")
+    call checkfmt("(rp,-6pf18.3)", 643.125, "             0.001")
+    call checkfmt("(rp,-5pf18.3)", 643.125, "             0.006")
+    call checkfmt("(rp,-4pf18.3)", 643.125, "             0.064")
+    call checkfmt("(rp,-3pf18.3)", 643.125, "             0.643")
+    call checkfmt("(rp,-2pf18.3)", 643.125, "             6.431")
+    call checkfmt("(rp,-1pf18.3)", 643.125, "            64.312")
+    call checkfmt("(rp, 0pf18.3)", 643.125, "           643.125")
+
+    call checkfmt("(-8pf18.3)", -643.125, "            -0.000")
+    call checkfmt("(-7pf18.3)", -643.125, "            -0.000")
+    call checkfmt("(-6pf18.3)", -643.125, "            -0.001")
+    call checkfmt("(-5pf18.3)", -643.125, "            -0.006")
+    call checkfmt("(-4pf18.3)", -643.125, "            -0.064")
+    call checkfmt("(-3pf18.3)", -643.125, "            -0.643")
+    call checkfmt("(-2pf18.3)", -643.125, "            -6.431")
+    call checkfmt("(-1pf18.3)", -643.125, "           -64.312")
+    call checkfmt("( 0pf18.3)", -643.125, "          -643.125")
+
+    call checkfmt("(ru,-8pf18.3)", -643.125, "            -0.000")
+    call checkfmt("(ru,-7pf18.3)", -643.125, "            -0.000")
+    call checkfmt("(ru,-6pf18.3)", -643.125, "            -0.000")
+    call checkfmt("(ru,-5pf18.3)", -643.125, "            -0.006")
+    call checkfmt("(ru,-4pf18.3)", -643.125, "            -0.064")
+    call checkfmt("(ru,-3pf18.3)", -643.125, "            -0.643")
+    call checkfmt("(ru,-2pf18.3)", -643.125, "            -6.431")
+    call checkfmt("(ru,-1pf18.3)", -643.125, "           -64.312")
+    call checkfmt("(ru, 0pf18.3)", -643.125, "          -643.125")
+
+    call checkfmt("(rd,-8pf18.3)", -643.125, "            -0.001")
+    call checkfmt("(rd,-7pf18.3)", -643.125, "            -0.001")
+    call checkfmt("(rd,-6pf18.3)", -643.125, "            -0.001")
+    call checkfmt("(rd,-5pf18.3)", -643.125, "            -0.007")
+    call checkfmt("(rd,-4pf18.3)", -643.125, "            -0.065")
+    call checkfmt("(rd,-3pf18.3)", -643.125, "            -0.644")
+    call checkfmt("(rd,-2pf18.3)", -643.125, "            -6.432")
+    call checkfmt("(rd,-1pf18.3)", -643.125, "           -64.313")
+    call checkfmt("(rd, 0pf18.3)", -643.125, "          -643.125")
+
+    call checkfmt("(rz,-8pf18.3)", -643.125, "            -0.000")
+    call checkfmt("(rz,-7pf18.3)", -643.125, "            -0.000")
+    call checkfmt("(rz,-6pf18.3)", -643.125, "            -0.000")
+    call checkfmt("(rz,-5pf18.3)", -643.125, "            -0.006")
+    call checkfmt("(rz,-4pf18.3)", -643.125, "            -0.064")
+    call checkfmt("(rz,-3pf18.3)", -643.125, "            -0.643")
+    call checkfmt("(rz,-2pf18.3)", -643.125, "            -6.431")
+    call checkfmt("(rz,-1pf18.3)", -643.125, "           -64.312")
+    call checkfmt("(rz, 0pf18.3)", -643.125, "          -643.125")
+
+    call checkfmt("(rc,-8pf18.3)", -643.125, "            -0.000")
+    call checkfmt("(rc,-7pf18.3)", -643.125, "            -0.000")
+    call checkfmt("(rc,-6pf18.3)", -643.125, "            -0.001")
+    call checkfmt("(rc,-5pf18.3)", -643.125, "            -0.006")
+    call checkfmt("(rc,-4pf18.3)", -643.125, "            -0.064")
+    call checkfmt("(rc,-3pf18.3)", -643.125, "            -0.643")
+    call checkfmt("(rc,-2pf18.3)", -643.125, "            -6.431")
+    call checkfmt("(rc,-1pf18.3)", -643.125, "           -64.313")
+    call checkfmt("(rc, 0pf18.3)", -643.125, "          -643.125")
+
+    call checkfmt("(rn,-8pf18.3)", -643.125, "            -0.000")
+    call checkfmt("(rn,-7pf18.3)", -643.125, "            -0.000")
+    call checkfmt("(rn,-6pf18.3)", -643.125, "            -0.001")
+    call checkfmt("(rn,-5pf18.3)", -643.125, "            -0.006")
+    call checkfmt("(rn,-4pf18.3)", -643.125, "            -0.064")
+    call checkfmt("(rn,-3pf18.3)", -643.125, "            -0.643")
+    call checkfmt("(rn,-2pf18.3)", -643.125, "            -6.431")
+    call checkfmt("(rn,-1pf18.3)", -643.125, "           -64.312")
+    call checkfmt("(rn, 0pf18.3)", -643.125, "          -643.125")
+
+    call checkfmt("(rp,-8pf18.3)", -643.125, "            -0.000")
+    call checkfmt("(rp,-7pf18.3)", -643.125, "            -0.000")
+    call checkfmt("(rp,-6pf18.3)", -643.125, "            -0.001")
+    call checkfmt("(rp,-5pf18.3)", -643.125, "            -0.006")
+    call checkfmt("(rp,-4pf18.3)", -643.125, "            -0.064")
+    call checkfmt("(rp,-3pf18.3)", -643.125, "            -0.643")
+    call checkfmt("(rp,-2pf18.3)", -643.125, "            -6.431")
+    call checkfmt("(rp,-1pf18.3)", -643.125, "           -64.312")
+    call checkfmt("(rp, 0pf18.3)", -643.125, "          -643.125")
+
+    ! print *, n_tst, n_cnt, n_skip
+    if (n_cnt /= 0) call abort
+    if (all(.not. l_skip)) print *, "All kinds rounded to nearest"
+
+contains
+    subroutine checkfmt(fmt, x, cmp)
+        implicit none
+        integer :: i
+        character(len=*), intent(in) :: fmt
+        real, intent(in) :: x
+        character(len=*), intent(in) :: cmp
+        do i=1,size(real_kinds)
+          if (i == 1) then
+            write(s, fmt) real(x,kind=j(1))
+          else if (i == 2) then
+            write(s, fmt) real(x,kind=j(2))
+          else if (i == 3) then
+            write(s, fmt) real(x,kind=j(3))
+          else if (i == 4) then
+            write(s, fmt) real(x,kind=j(4))
+          end if
+          n_tst = n_tst + 1
+          if (s /= cmp) then
+            if (l_skip(i)) then
+              n_skip = n_skip + 1
+            else
+              print "(a,1x,a,' expected: ',1x,a)", fmt, s, cmp
+              n_cnt = n_cnt + 1
+            end if
+          end if
+        end do
+        
+    end subroutine
+end program
+! { dg-output "All kinds rounded to nearest" { xfail { i?86-*-solaris2.9* hppa*-*-hpux* } } }
diff --git a/gcc/testsuite/gfortran.dg/init_derived_1.f b/gcc/testsuite/gfortran.dg/init_derived_1.f
new file mode 100644
index 00000000000..c187203963d
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/init_derived_1.f
@@ -0,0 +1,72 @@
+! { dg-do run }
+! { dg-options "-finit-local-zero -finit-derived -fbackslash" }
+!
+! Make sure -finit-derived with -finit-local-zero initializes components
+! of local derived type variables to zero without overwriting explicit default
+! initializers.
+!
+      include 'assert.inc'
+
+      implicit none
+
+      type ty
+        ! Make sure components are initialized to zero
+        integer i1
+        real r1
+        logical l1
+        character c1
+        ! Make sure explicit default initializers are not overwritten
+        integer :: i2 = 1
+        real :: r2 = 1.0
+        logical :: l2 = .true.
+        character :: c2 = 'x'
+      end type
+      type(ty) t
+      ! Make sure explicit symbol initializer is not overwritten
+      type(ty) :: t2 = ty(1,1.0,.true.,'x',0,0.0,.false.,'\0')
+
+      ! Make sure locals are still initialized to zero
+      integer ii1
+      real rr1
+      logical ll1
+      character cc1
+
+      ! Make sure locals' initializers are not overwritten
+      integer :: ii2 = 1
+      real :: rr2 = 1.0
+      logical :: ll2 = .true.
+      character :: cc2 = 'x'
+
+      ! Local simply typed variables
+      call assertll ("ii1",  ii1,  0)
+      call assertrr ("rr1",  rr1,  0.0)
+      call assert   ("ll1",  .not. ll1)
+      call assertss ("cc1", cc1, '\0')
+
+      call assertll ("ii2",  ii2,  1)
+      call assertrr ("rr2",  rr2,  1.0)
+      call assert   ("ll2",  ll2)
+      call assertss ("cc2", cc2, 'x')
+
+      ! Local derived type variables
+      call assertll ("t%i1",  t%i1,  0)
+      call assertrr ("t%r1",  t%r1,  0.0)
+      call assert   ("t%l1",  .not. t%l1)
+      call assertss ("t%c1", t%c1, '\0')
+
+      call assertll ("t%i2",  t%i2,  1)
+      call assertrr ("t%r2",  t%r2,  1.0)
+      call assert   ("t%l2",  t%l2)
+      call assertss ("t%c2",  t%c2, 'x')
+
+      call assertll ("t2%i1",  t2%i1,  1)
+      call assertrr ("t2%r1",  t2%r1,  1.0)
+      call assert   ("t2%l1",  t2%l1)
+      call assertss ("t2%c1",  t2%c1, 'x')
+
+      call assertll ("t2%i2",  t2%i2,  0)
+      call assertrr ("t2%r2",  t2%r2,  0.0)
+      call assert   ("t2%l2",  .not. t2%l2)
+      call assertss ("t2%c2",  t2%c2, '\0')
+
+      end
diff --git a/gcc/testsuite/gfortran.dg/init_derived_2.f b/gcc/testsuite/gfortran.dg/init_derived_2.f
new file mode 100644
index 00000000000..36ba36dc3d4
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/init_derived_2.f
@@ -0,0 +1,38 @@
+! { dg-do run }
+! { dg-options "-finit-integer=5 -finit-real=nan -finit-logical=true -finit-character=32 -finit-derived -fbackslash" }
+!
+! Make sure -finit-derived initializes components of local derived type
+! variables to parameters given on the command line.
+!
+      include 'assert.inc'
+
+      implicit none
+
+      type ty
+        ! Make sure components are initialized appropriately
+        integer i   ! = 5
+        real r      ! = nan
+        logical l   ! = .true.
+        character c ! = ' ' (32)
+      end type
+      type(ty) t
+
+      ! Make sure locals are still initialized appropriately
+      integer ii   ! = 5
+      real rr      ! = nan
+      logical ll   ! = .true.
+      character cc ! = ' ' (32)
+
+      ! Local simply typed variables
+      call assertll ("ii",  ii,   5)
+      call assert   ("isnan(rr)", ISNAN(rr))
+      call assert   ("ll",  ll)
+      call assertss ("cc",  cc,   ' ')
+
+      ! Local derived type variables
+      call assertll ("t%i",  t%i,  5)
+      call assert   ("isnan(t%r)", ISNAN(t%r))
+      call assert   ("t%l",  t%l)
+      call assertss ("t%c",  t%c,  ' ')
+
+      end
diff --git a/gcc/testsuite/gfortran.dg/pr71523_1.f90 b/gcc/testsuite/gfortran.dg/pr71523_1.f90
new file mode 100644
index 00000000000..a0bfc64486e
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr71523_1.f90
@@ -0,0 +1,20 @@
+! { dg-do compile }
+! { dg-options "-fdump-tree-original -finit-local-zero -fautomatic -fmax-stack-var-size=8" }
+!
+! Make sure that variables larger than max-stack-var-size which become
+! static are not given automatic initializers on function entry.
+!
+
+function set(idx, val)
+  implicit none
+  integer, intent(in) :: idx, val
+  integer set
+  integer arr(100)
+
+  set = arr(idx)
+  arr(idx) = val
+  return
+end function
+
+! There should be no automatic initializer for arr
+! { dg-final { scan-tree-dump-times "arr = " 0 "original" } }
diff --git a/gcc/testsuite/gfortran.dg/pr71523_2.f90 b/gcc/testsuite/gfortran.dg/pr71523_2.f90
new file mode 100644
index 00000000000..3b234de7cd8
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr71523_2.f90
@@ -0,0 +1,36 @@
+! { dg-do run }
+! { dg-options "-finit-integer=12345 -fautomatic -fmax-stack-var-size=8" }
+!
+! Make sure that variables larger than max-stack-var-size become
+! static and are given the correct _static_ initializer.
+!
+
+function set(idx, val)
+  implicit none
+  integer, intent(in) :: idx, val
+  integer set
+  integer arr(100)
+
+  set = arr(idx)
+  arr(idx) = val
+  return
+end function
+
+  integer set, val
+
+  val = set(1, 5)
+  if (val .ne. 12345) then
+    call abort()
+  endif
+
+  val = set(1, 10)
+  if (val .ne. 5) then
+    call abort()
+  endif
+
+  val = set(1, 100)
+  if (val .ne. 10) then
+    call abort()
+  endif
+
+end
diff --git a/libgfortran/io/close.c b/libgfortran/io/close.c
index fa9c1137f03..871d72133f3 100644
--- a/libgfortran/io/close.c
+++ b/libgfortran/io/close.c
@@ -66,6 +66,8 @@ st_close (st_parameter_close *clp)
   u = find_unit (clp->common.unit);
   if (u != NULL)
     {
+      if (close_fcntl (u))
+        generate_error (&clp->common, LIBERROR_OS, "Problem in CLOSE");
       if (u->flags.status == STATUS_SCRATCH)
 	{
 	  if (status == CLOSE_KEEP)
@@ -80,12 +82,18 @@ st_close (st_parameter_close *clp)
 	{
 	  if (status == CLOSE_DELETE)
             {
+              if (u->flags.readonly)
+                generate_warning (&clp->common, "STATUS set to DELETE on CLOSE"
+                                  " but file protected by READONLY specifier");
+              else
+              {
 #if HAVE_UNLINK_OPEN_FILE
 	      delete_file (u);
 #else
 	      path = (char *) gfc_alloca (u->file_len + 1);
               unpack_filename (path, u->file, u->file_len);
 #endif
+              }
             }
 	}
 
diff --git a/libgfortran/io/file_pos.c b/libgfortran/io/file_pos.c
index 8b4fda3dd91..93c564ad47b 100644
--- a/libgfortran/io/file_pos.c
+++ b/libgfortran/io/file_pos.c
@@ -362,6 +362,8 @@ st_endfile (st_parameter_filepos *fpp)
 	  u_flags.sign = SIGN_UNSPECIFIED;
 	  u_flags.status = STATUS_UNKNOWN;
 	  u_flags.convert = GFC_CONVERT_NATIVE;
+          u_flags.share = SHARE_UNSPECIFIED;
+          u_flags.cc = CC_UNSPECIFIED;
 
 	  opp.common = fpp->common;
 	  opp.common.flags &= IOPARM_COMMON_MASK;
diff --git a/libgfortran/io/io.h b/libgfortran/io/io.h
index e78f3151bbd..62cb4e62904 100644
--- a/libgfortran/io/io.h
+++ b/libgfortran/io/io.h
@@ -209,6 +209,18 @@ typedef enum
 unit_async;
 
 typedef enum
+{ SHARE_DENYRW, SHARE_DENYNONE,
+  SHARE_UNSPECIFIED
+}
+unit_share;
+
+typedef enum
+{ CC_LIST, CC_FORTRAN, CC_NONE,
+  CC_UNSPECIFIED
+}
+unit_cc;
+
+typedef enum
 { SIGN_S, SIGN_SS, SIGN_SP }
 unit_sign_s;
 
@@ -239,6 +251,9 @@ typedef struct
   CHARACTER1 (sign);
   CHARACTER2 (asynchronous);
   GFC_INTEGER_4 *newunit;
+  GFC_INTEGER_4 (readonly);
+  CHARACTER1 (share);
+  CHARACTER2 (cc);
 }
 st_parameter_open;
 
@@ -494,17 +509,20 @@ typedef struct
   unit_blank blank;
   unit_delim delim;
   unit_form form;
-  int is_notpadded;
   unit_position position;
   unit_status status;
   unit_pad pad;
   unit_convert convert;
-  int has_recl;
   unit_decimal decimal;
   unit_encoding encoding;
   unit_round round;
   unit_sign sign;
   unit_async async;
+  unit_share share;
+  unit_cc cc;
+  int is_notpadded : 1;
+  int has_recl     : 1;
+  int readonly     : 1;
 }
 unit_flags;
 
diff --git a/libgfortran/io/list_read.c b/libgfortran/io/list_read.c
index 2b80838fc9f..7f847060f7f 100644
--- a/libgfortran/io/list_read.c
+++ b/libgfortran/io/list_read.c
@@ -1618,7 +1618,10 @@ read_real (st_parameter_dt *dtp, void * dest, int length)
 
  exp2:
   if (!isdigit (c))
-    goto bad_real;
+  {
+    push_char (dtp, '0');
+    goto done; /* Extension: exponent defaults to 1 when ommitted. */
+  }
   push_char (dtp, c);
 
   for (;;)
diff --git a/libgfortran/io/open.c b/libgfortran/io/open.c
index d9cfde853f5..c539a4d4568 100644
--- a/libgfortran/io/open.c
+++ b/libgfortran/io/open.c
@@ -48,6 +48,21 @@ static const st_option action_opt[] =
   { NULL, 0}
 };
 
+static const st_option share_opt[] =
+{
+  { "denyrw", SHARE_DENYRW },
+  { "denynone", SHARE_DENYNONE },
+  { NULL, 0}
+};
+
+static const st_option cc_opt[] =
+{
+  { "list", CC_LIST },
+  { "fortran", CC_FORTRAN },
+  { "none", CC_NONE },
+  { NULL, 0}
+};
+
 static const st_option blank_opt[] =
 {
   { "null", BLANK_NULL},
@@ -191,6 +206,14 @@ edit_modes (st_parameter_open *opp, gfc_unit * u, unit_flags * flags)
     generate_error (&opp->common, LIBERROR_BAD_OPTION,
 		    "Cannot change ACTION parameter in OPEN statement");
 
+  if (flags->share != SHARE_UNSPECIFIED && u->flags.share != flags->share)
+    generate_error (&opp->common, LIBERROR_BAD_OPTION,
+                    "Cannot change SHARE parameter in OPEN statement");
+
+  if (flags->cc != CC_UNSPECIFIED && u->flags.cc != flags->cc)
+    generate_error (&opp->common, LIBERROR_BAD_OPTION,
+                  "Cannot change CARRIAGECONTROL parameter in OPEN statement");
+
   /* Status must be OLD if present.  */
 
   if (flags->status != STATUS_UNSPECIFIED && flags->status != STATUS_OLD &&
@@ -326,6 +349,16 @@ new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags * flags)
   if (flags->status == STATUS_UNSPECIFIED)
     flags->status = STATUS_UNKNOWN;
 
+  if (flags->cc == CC_UNSPECIFIED)
+    flags->cc = flags->form == FORM_UNFORMATTED ? CC_NONE : CC_LIST;
+  else if (flags->form == FORM_UNFORMATTED && flags->cc != CC_NONE)
+    {
+      generate_error (&opp->common, LIBERROR_OPTION_CONFLICT,
+          "CARRIAGECONTROL parameter conflicts with UNFORMATTED form in "
+          "OPEN statement");
+      goto fail;
+    }
+
   /* Checks.  */
 
   if (flags->delim == DELIM_UNSPECIFIED)
@@ -726,6 +759,7 @@ st_open (st_parameter_open *opp)
   library_start (&opp->common);
 
   /* Decode options.  */
+  flags.readonly = !(cf & IOPARM_OPEN_HAS_READONLY) ? 0 : opp->readonly;
 
   flags.access = !(cf & IOPARM_OPEN_HAS_ACCESS) ? ACCESS_UNSPECIFIED :
     find_option (&opp->common, opp->access, opp->access_len,
@@ -735,6 +769,14 @@ st_open (st_parameter_open *opp)
     find_option (&opp->common, opp->action, opp->action_len,
 		 action_opt, "Bad ACTION parameter in OPEN statement");
 
+  flags.share = !(cf & IOPARM_OPEN_HAS_SHARE) ? SHARE_UNSPECIFIED :
+    find_option (&opp->common, opp->share, opp->share_len,
+                 share_opt, "Bad SHARE parameter in OPEN statement");
+
+  flags.cc = !(cf & IOPARM_OPEN_HAS_CC) ? CC_UNSPECIFIED :
+    find_option (&opp->common, opp->cc, opp->cc_len,
+                 cc_opt, "Bad CARRIAGECONTROL parameter in OPEN statement");
+
   flags.blank = !(cf & IOPARM_OPEN_HAS_BLANK) ? BLANK_UNSPECIFIED :
     find_option (&opp->common, opp->blank, opp->blank_len,
 		 blank_opt, "Bad BLANK parameter in OPEN statement");
diff --git a/libgfortran/io/read.c b/libgfortran/io/read.c
index f45e1b4edfe..9e82d238fec 100644
--- a/libgfortran/io/read.c
+++ b/libgfortran/io/read.c
@@ -1056,7 +1056,7 @@ exponent:
      the d parameter before explict conversion takes place.  */
 
   if (w == 0)
-    goto bad_float;
+    goto done; /* Extension: exponent defaults to 1 when ommitted. */
 
   if (dtp->u.p.blank_status == BLANK_UNSPECIFIED)
     {
@@ -1220,7 +1220,8 @@ read_x (st_parameter_dt *dtp, int n)
       q = fbuf_getc (dtp->u.p.current_unit);
       if (q == EOF)
 	break;
-      else if (q == '\n' || q == '\r')
+      else if (dtp->u.p.current_unit->flags.cc != CC_NONE
+               && (q == '\n' || q == '\r'))
 	{
 	  /* Unexpected end of line. Set the position.  */
 	  dtp->u.p.sf_seen_eor = 1;
diff --git a/libgfortran/io/transfer.c b/libgfortran/io/transfer.c
index 87c67bf6a3d..25fcbf6aef9 100644
--- a/libgfortran/io/transfer.c
+++ b/libgfortran/io/transfer.c
@@ -306,7 +306,8 @@ read_sf (st_parameter_dt *dtp, int * length)
       q = fbuf_getc (dtp->u.p.current_unit);
       if (q == EOF)
 	break;
-      else if (q == '\n' || q == '\r')
+      else if (dtp->u.p.current_unit->flags.cc != CC_NONE
+               && (q == '\n' || q == '\r'))
 	{
 	  /* Unexpected end of line. Set the position.  */
 	  dtp->u.p.sf_seen_eor = 1;
@@ -2415,6 +2416,9 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)
       u_flags.async = ASYNC_UNSPECIFIED;
       u_flags.round = ROUND_UNSPECIFIED;
       u_flags.sign = SIGN_UNSPECIFIED;
+      u_flags.share = SHARE_UNSPECIFIED;
+      u_flags.cc = CC_UNSPECIFIED;
+      u_flags.readonly = 0;
 
       u_flags.status = STATUS_UNKNOWN;
 
@@ -3036,6 +3040,9 @@ next_record_r (st_parameter_dt *dtp, int done)
   int bytes_left;
   char p;
   int cc;
+  unit_flags flags;
+
+  flags = dtp->u.p.current_unit->flags;
 
   switch (current_mode (dtp))
     {
@@ -3100,7 +3107,7 @@ next_record_r (st_parameter_dt *dtp, int done)
 	    } 
 	  break;
 	}
-      else 
+      else if (flags.cc != CC_NONE)
 	{
 	  do
 	    {
@@ -3289,8 +3296,11 @@ static void
 next_record_w (st_parameter_dt *dtp, int done)
 {
   gfc_offset m, record, max_pos;
+  unit_flags flags;
   int length;
 
+  flags = dtp->u.p.current_unit->flags;
+
   /* Zero counters for X- and T-editing.  */
   max_pos = dtp->u.p.max_pos;
   dtp->u.p.max_pos = dtp->u.p.skips = dtp->u.p.pending_spaces = 0;
@@ -3432,11 +3442,15 @@ next_record_w (st_parameter_dt *dtp, int done)
       else
 	{
 #ifdef HAVE_CRLF
-	  const int len = 2;
+	  static const int lflen = 2;
 #else
-	  const int len = 1;
+	  static const int lflen = 1;
 #endif
+          const int len = flags.cc == CC_NONE ? 0 : lflen;
           fbuf_seek (dtp->u.p.current_unit, 0, SEEK_END);
+          /* Skip newlines for CC_NONE */
+          if (flags.cc != CC_NONE)
+          {
           char * p = fbuf_alloc (dtp->u.p.current_unit, len);
           if (!p)
             goto io_error;
@@ -3444,6 +3458,7 @@ next_record_w (st_parameter_dt *dtp, int done)
           *(p++) = '\r';
 #endif
           *p = '\n';
+          }
 	  if (is_stream_io (dtp))
 	    {
 	      dtp->u.p.current_unit->strm_pos += len;
diff --git a/libgfortran/io/unix.c b/libgfortran/io/unix.c
index 185d0dca157..95c30c6a2a4 100644
--- a/libgfortran/io/unix.c
+++ b/libgfortran/io/unix.c
@@ -1341,6 +1341,41 @@ regular_file (st_parameter_open *opp, unit_flags *flags)
   return fd;			/* failure */
 }
 
+/* Use fcntl to modify the given file descriptor based on flags.
+   Return value semantics are the same as fcntl.
+   Does not operate on stdin, stdout, or stderr. */
+
+static int
+open_fcntl (int fd, unit_flags *flags)
+{
+  int r = 0;
+  struct flock f;
+
+  if (fd == STDOUT_FILENO || fd == STDERR_FILENO || fd == STDIN_FILENO)
+    return 0;
+
+  f.l_start = 0;
+  f.l_len = 0;
+  f.l_whence = SEEK_SET;
+
+  switch (flags->share)
+  {
+    case SHARE_DENYNONE:
+      f.l_type = F_RDLCK;
+      r |= fcntl (fd, F_SETLK, &f);
+      break;
+    case SHARE_DENYRW:
+      f.l_type = F_WRLCK;
+      r |= fcntl (fd, F_SETLK, &f);
+      break;
+    case SHARE_UNSPECIFIED:
+    default:
+      break;
+  }
+
+  return r;
+}
+
 
 /* open_external()-- Open an external file, unix specific version.
  * Change flags->action if it is ACTION_UNSPECIFIED on entry.
@@ -1374,6 +1409,10 @@ open_external (st_parameter_open *opp, unit_flags *flags)
     return NULL;
   fd = fix_fd (fd);
 
+  /* Apply any required FCNTL calls to the file descriptor based on flags. */
+  if (open_fcntl (fd, flags) < 0)
+    return NULL;
+
   return fd_to_stream (fd);
 }
 
@@ -1642,6 +1681,38 @@ flush_all_units (void)
 }
 
 
+/* Apply any fcntls required based on the unit. */
+
+int
+close_fcntl (gfc_unit *u)
+{
+  int r = 0;
+  unix_stream *s = (unix_stream *)u->s;
+  int fd = s->fd;
+  struct flock f;
+
+  /* Unlock any OS-level locks. */
+  switch (u->flags.share)
+  {
+    case SHARE_DENYRW:
+    case SHARE_DENYNONE:
+      if (fd != STDOUT_FILENO && fd != STDERR_FILENO && fd != STDIN_FILENO)
+      {
+        f.l_start = 0;
+        f.l_len = 0;
+        f.l_whence = SEEK_SET;
+        f.l_type = F_UNLCK;
+        r = fcntl (fd, F_SETLK, &f);
+      }
+    case SHARE_UNSPECIFIED:
+    default:
+      break;
+  }
+
+  return r;
+}
+
+
 /* delete_file()-- Given a unit structure, delete the file associated
  * with the unit.  Returns nonzero if something went wrong. */
 
diff --git a/libgfortran/io/unix.h b/libgfortran/io/unix.h
index bf59a8ee1fc..a90869af3f4 100644
--- a/libgfortran/io/unix.h
+++ b/libgfortran/io/unix.h
@@ -134,6 +134,9 @@ internal_proto(compare_file_filename);
 extern gfc_unit *find_file (const char *file, gfc_charlen_type file_len);
 internal_proto(find_file);
 
+extern int close_fcntl (gfc_unit *);
+internal_proto(close_fcntl);
+
 extern int delete_file (gfc_unit *);
 internal_proto(delete_file);
 
diff --git a/libgfortran/io/write.c b/libgfortran/io/write.c
index 4ef5586a657..9e605808148 100644
--- a/libgfortran/io/write.c
+++ b/libgfortran/io/write.c
@@ -1548,7 +1548,7 @@ list_formatted_write_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,
   if (dtp->u.p.first_item)
     {
       dtp->u.p.first_item = 0;
-      write_char (dtp, ' ');
+      if (dtp->u.p.current_unit->flags.cc != CC_FORTRAN) write_char (dtp, ' ');
     }
   else
     {
diff --git a/libgfortran/io/write_float.def b/libgfortran/io/write_float.def
index acfa125cf16..b24c061cf5d 100644
--- a/libgfortran/io/write_float.def
+++ b/libgfortran/io/write_float.def
@@ -184,9 +184,6 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,
 	      memmove (digits + nbefore, digits + nbefore + 1, p);
 	      digits[nbefore + p] = '.';
 	      nbefore += p;
-	      nafter = d - p;
-	      if (nafter < 0)
-		nafter = 0;
 	      nafter = d;
 	      nzero = 0;
 	    }
@@ -204,12 +201,27 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,
 		{
 		  nzero = -(nbefore + p);
 		  memmove (digits + 1, digits, nbefore);
-		  digits++;
-		  nafter = d + nbefore;
+		  nafter = d - nzero;
+		  if (nafter == 0 && d > 0)
+		    {
+		      /* This is needed to get the correct rounding. */
+		      memmove (digits + 1, digits, ndigits - 1);
+		      digits[1] = '0';
+		      nafter = 1;
+		      nzero = d - 1;
+		    }
+		  else if (nafter < 0)
+		    {
+		      /* Reset digits to 0 in order to get correct rounding
+			 towards infinity. */
+		      for (i = 0; i < ndigits; i++)
+			digits[i] = '0';
+		      digits[ndigits - 1] = '1';
+		      nafter = d;
+		      nzero = 0;
+		    }
 		  nbefore = 0;
 		}
-	      if (nzero > d)
-		nzero = d;
 	    }
 	}
       else
diff --git a/libgfortran/libgfortran.h b/libgfortran/libgfortran.h
index 9a713d852d3..fa3f8ef5aa8 100644
--- a/libgfortran/libgfortran.h
+++ b/libgfortran/libgfortran.h
@@ -634,6 +634,9 @@ st_parameter_common;
 #define IOPARM_OPEN_HAS_SIGN		(1 << 21)
 #define IOPARM_OPEN_HAS_ASYNCHRONOUS	(1 << 22)
 #define IOPARM_OPEN_HAS_NEWUNIT		(1 << 23)
+#define IOPARM_OPEN_HAS_READONLY        (1 << 24)
+#define IOPARM_OPEN_HAS_SHARE           (1 << 25)
+#define IOPARM_OPEN_HAS_CC              (1 << 26)
 
 /* library start function and end macro.  These can be expanded if needed
    in the future.  cmp is st_parameter_common *cmp  */
