diff --git a/gcc/fortran/ChangeLog b/gcc/fortran/ChangeLog
index 44c59c7..3b040c3 100644
--- a/gcc/fortran/ChangeLog
+++ b/gcc/fortran/ChangeLog
@@ -1,3 +1,31 @@
+2014-08-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/61999
+	* simplify.c (gfc_simplify_dot_product): Convert types of
+	vectors before calculating the result.
+
+2014-07-19  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk.
+	PR fortran/61780
+	* dependency.c (gfc_dep_resolver): Index the 'reverse' array so
+	that elements are skipped. This then correctly aligns 'reverse'
+	with the scalarizer loops.
+
+2014-07-08  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/61459
+	PR fortran/58883
+	* trans-expr.c (fcncall_realloc_result): Use the natural type
+	for the address expression of 'res_desc'.
+
+2014-07-02  Jakub Jelinek  <jakub@redhat.com>
+	    Fritz Reese  <Reese-Fritz@zai.com>
+
+	* decl.c (variable_decl): Reject old style initialization
+	for derived type components.
+
 2014-05-22  Release Manager
 
 	* GCC 4.8.3 released.
diff --git a/gcc/fortran/check.c b/gcc/fortran/check.c
index c9520f6..9c9908f 100644
--- a/gcc/fortran/check.c
+++ b/gcc/fortran/check.c
@@ -203,6 +203,25 @@ double_check (gfc_expr *d, int n)
 }
 
 
+/* Make sure the expression is a quad precision real.  */
+
+static gfc_try
+quad_check (gfc_expr *d, int n)
+{
+    if (type_check (d, n, BT_REAL) == FAILURE)
+      return FAILURE;
+
+    if (d->ts.kind != 16)
+      {
+        gfc_error ("'%s' argument of '%s' intrinsic at %L must be quad "
+                   "precision", gfc_current_intrinsic_arg[n]->name,
+                   gfc_current_intrinsic, &d->where);
+        return FAILURE;
+      }
+    
+    return SUCCESS;
+}
+
 static gfc_try
 coarray_check (gfc_expr *e, int n)
 {
@@ -1716,6 +1735,17 @@ gfc_check_fn_d (gfc_expr *a)
   return SUCCESS;
 }
 
+/* A single quad-precision real argument. */
+
+gfc_try
+gfc_check_fn_q (gfc_expr *a)
+{
+    if (quad_check (a, 0) == FAILURE)
+      return FAILURE;
+    
+    return SUCCESS;
+}
+
 /* A single real or complex argument.  */
 
 gfc_try
@@ -2119,7 +2149,7 @@ gfc_check_kill_sub (gfc_expr *pid, gfc_expr *sig, gfc_expr *status)
 gfc_try
 gfc_check_kind (gfc_expr *x)
 {
-  if (x->ts.type == BT_DERIVED)
+  if (gfc_bt_struct (x->ts.type))
     {
       gfc_error ("'%s' argument of '%s' intrinsic at %L must be a "
 		 "non-derived type", gfc_current_intrinsic_arg[0]->name,
diff --git a/gcc/fortran/class.c b/gcc/fortran/class.c
index 55c072b..9841e41 100644
--- a/gcc/fortran/class.c
+++ b/gcc/fortran/class.c
@@ -71,12 +71,11 @@ insert_component_ref (gfc_typespec *ts, gfc_ref **ref, const char * const name)
   gcc_assert (ts->type == BT_DERIVED || ts->type == BT_CLASS);
   type_sym = ts->u.derived;
 
-  new_ref = gfc_get_ref ();
-  new_ref->type = REF_COMPONENT;
-  new_ref->next = *ref;
-  new_ref->u.c.sym = type_sym;
-  new_ref->u.c.component = gfc_find_component (type_sym, name, true, true);
+  gfc_find_component (type_sym, name, true, true, &new_ref);
   gcc_assert (new_ref->u.c.component);
+  while (new_ref->next)
+    new_ref = new_ref->next;
+  new_ref->next = *ref;
 
   if (new_ref->next)
     {
@@ -199,8 +198,9 @@ gfc_fix_class_refs (gfc_expr *e)
 void
 gfc_add_component_ref (gfc_expr *e, const char *name)
 {
+  gfc_component *c;
   gfc_ref **tail = &(e->ref);
-  gfc_ref *next = NULL;
+  gfc_ref *ref, *next = NULL;
   gfc_symbol *derived = e->symtree->n.sym->ts.u.derived;
   while (*tail != NULL)
     {
@@ -219,14 +219,13 @@ gfc_add_component_ref (gfc_expr *e, const char *name)
     }
   if (*tail != NULL && strcmp (name, "_data") == 0)
     next = *tail;
-  (*tail) = gfc_get_ref();
-  (*tail)->next = next;
-  (*tail)->type = REF_COMPONENT;
-  (*tail)->u.c.sym = derived;
-  (*tail)->u.c.component = gfc_find_component (derived, name, true, true);
-  gcc_assert((*tail)->u.c.component);
+  c = gfc_find_component (derived, name, true, true, tail);
+  gcc_assert (c);
+  for (ref = *tail; ref->next; ref = ref->next)
+    ;
+  ref->next = next;
   if (!next)
-    e->ts = (*tail)->u.c.component->ts;
+    e->ts = c->ts;
 }
 
 
@@ -462,8 +461,7 @@ get_unique_type_string (char *string, gfc_symbol *derived)
   if (derived->attr.unlimited_polymorphic)
     strcpy (dt_name, "STAR");
   else
-    strcpy (dt_name, derived->name);
-  dt_name[0] = TOUPPER (dt_name[0]);
+    strcpy (dt_name, gfc_dt_upper_string (derived->name));
   if (derived->attr.unlimited_polymorphic)
     sprintf (string, "_%s", dt_name);
   else if (derived->module)
@@ -687,7 +685,7 @@ add_proc_comp (gfc_symbol *vtype, const char *name, gfc_typebound_proc *tb)
   if (tb->non_overridable)
     return;
 
-  c = gfc_find_component (vtype, name, true, true);
+  c = gfc_find_component (vtype, name, true, true, NULL);
 
   if (c == NULL)
     {
@@ -754,7 +752,7 @@ copy_vtab_proc_comps (gfc_symbol *declared, gfc_symbol *vtype)
 
   for (cmp = vtab->ts.u.derived->components; cmp; cmp = cmp->next)
     {
-      if (gfc_find_component (vtype, cmp->name, true, true))
+      if (gfc_find_component (vtype, cmp->name, true, true, NULL))
 	continue;
 
       add_proc_comp (vtype, cmp->name, cmp->tb);
@@ -2300,7 +2298,8 @@ gfc_find_derived_vtab (gfc_symbol *derived)
 		  gfc_set_sym_referenced (def_init);
 		  def_init->ts.type = BT_DERIVED;
 		  def_init->ts.u.derived = derived;
-		  def_init->value = gfc_default_initializer (&def_init->ts);
+		  def_init->value = gfc_default_initializer (&def_init->ts,
+                                                             false);
 
 		  c->initializer = gfc_lval_expr_from_sym (def_init);
 		}
@@ -2392,7 +2391,7 @@ gfc_find_derived_vtab (gfc_symbol *derived)
 
 have_vtype:
 	  vtab->ts.u.derived = vtype;
-	  vtab->value = gfc_default_initializer (&vtab->ts);
+	  vtab->value = gfc_default_initializer (&vtab->ts, false);
 	}
     }
 
@@ -2666,7 +2665,7 @@ gfc_find_intrinsic_vtab (gfc_typespec *ts)
 	      c->initializer = gfc_get_null_expr (NULL);
 	    }
 	  vtab->ts.u.derived = vtype;
-	  vtab->value = gfc_default_initializer (&vtab->ts);
+	  vtab->value = gfc_default_initializer (&vtab->ts, false);
 	}
     }
 
diff --git a/gcc/fortran/decl.c b/gcc/fortran/decl.c
index 7dec803..3282b63 100644
--- a/gcc/fortran/decl.c
+++ b/gcc/fortran/decl.c
@@ -53,6 +53,7 @@ static gfc_typespec current_ts;
 static symbol_attribute current_attr;
 static gfc_array_spec *current_as;
 static int colon_seen;
+static int attr_seen;
 
 /* The current binding label (if any).  */
 static const char* curr_binding_label;
@@ -93,7 +94,6 @@ gfc_symbol *gfc_new_block;
 
 bool gfc_matching_function;
 
-
 /********************* DATA statement subroutines *********************/
 
 static bool in_match_data = false;
@@ -377,13 +377,13 @@ match_data_constant (gfc_expr **result)
 
   if (sym == NULL
       || (sym->attr.flavor != FL_PARAMETER
-	  && (!dt_sym || dt_sym->attr.flavor != FL_DERIVED)))
+	  && (!dt_sym || !gfc_fl_struct (dt_sym->attr.flavor))))
     {
       gfc_error ("Symbol '%s' must be a PARAMETER in DATA statement at %C",
 		 name);
       return MATCH_ERROR;
     }
-  else if (dt_sym && dt_sym->attr.flavor == FL_DERIVED)
+  else if (dt_sym && gfc_fl_struct (dt_sym->attr.flavor))
     return gfc_match_structure_constructor (dt_sym, result);
 
   /* Check to see if the value is an initialization array expression.  */
@@ -582,6 +582,147 @@ cleanup:
 
 /************************ Declaration statements *********************/
 
+/* Like gfc_match_init_expr, but matches a 'clist' (old-style initialization
+   list). The difference here is the expression is a list of constants
+   and is surrounded by '/'. 
+   The typespec ts must match the typespec of the variable which the
+   clist is initializing.
+   The scalar parameter tells whether this should match a scalar
+   initialization or a list of constants corresponding to array elements. */
+match
+gfc_match_clist_expr (gfc_expr **result, gfc_typespec *ts, gfc_array_spec *as)
+{
+  gfc_constructor_base array_head = NULL;
+  gfc_expr *expr = NULL;
+  match m;
+  locus where;
+  mpz_t repeat, size;
+  bool scalar;
+  int cmp;
+
+  gcc_assert (ts);
+
+  mpz_init_set_ui (repeat, 0);
+  mpz_init (size);
+  scalar = !as || !as->rank;
+
+  /* We have already matched "/". Now look for a constant list, as with
+     top_val_list from decl.c, but append the result to an array constructor. */
+  if (gfc_match ("/") == MATCH_YES)
+  {
+    gfc_error ("Empty old style initializer list at %C");
+    goto cleanup;
+  }
+
+  where = gfc_current_locus;
+  for (;;)
+    {
+      m = match_data_constant (&expr);
+      if (m == MATCH_NO)
+        goto syntax;
+      if (m == MATCH_ERROR)
+        goto cleanup;
+
+      /* Found a repeat specification; match again the actual constant. */
+      if (expr->ts.type == BT_INTEGER && gfc_match_char ('*') == MATCH_YES)
+      {
+        if (scalar)
+        {
+          gfc_error ("Invalid scalar initializer at %C");
+          goto cleanup;
+        }
+        mpz_set (repeat, expr->value.integer);
+        gfc_free_expr (expr);
+        expr = NULL;
+
+        m = match_data_constant (&expr);
+        if (m == MATCH_NO)
+          goto syntax;
+        if (m == MATCH_ERROR)
+          goto cleanup;
+      }
+      else
+        mpz_set_ui (repeat, 1);
+
+      if (!scalar)
+      {
+        /* Add the constant initializer as many times as repeated. */
+        for (; mpz_cmp_ui (repeat, 0) > 0; mpz_sub_ui (repeat, repeat, 1))
+        {
+          /* Make sure types of elements match */
+          if(ts && !gfc_compare_types (&expr->ts, ts)
+                && gfc_convert_type (expr, ts, 1) == FAILURE)
+            goto cleanup;
+
+          gfc_constructor_append_expr (&array_head,
+              gfc_copy_expr (expr), &gfc_current_locus);
+        }
+
+        gfc_free_expr (expr);
+      }
+      /* For scalar initializers quit after one element. */
+      else
+      {
+        if(gfc_match_char ('/') != MATCH_YES)
+        {
+          gfc_error ("End of scalar initializer expected at %C");
+          goto cleanup;
+        }
+        break;
+      }
+
+      if (gfc_match_char ('/') == MATCH_YES)
+        break;
+      if (gfc_match_char (',') == MATCH_NO)
+        goto syntax;
+    }
+
+  /* Set up expr as an array constructor. */
+  if (!scalar)
+  {
+    expr = gfc_get_array_expr (ts->type, ts->kind, &where);
+    expr->ts = *ts;
+    expr->value.constructor = array_head;
+
+    expr->rank = as->rank;
+    expr->shape = gfc_get_shape (expr->rank);
+
+    /* Validate sizes. */
+    gcc_assert (gfc_array_size (expr, &size) == SUCCESS);
+    gcc_assert (spec_size (as, &repeat) == SUCCESS);
+    cmp = mpz_cmp (size, repeat);
+    if (cmp < 0)
+      gfc_error ("Not enough elements in array initializer at %C");
+    else if (cmp > 0)
+      gfc_error ("Too many elements in array initializer at %C");
+    if (cmp)
+      goto cleanup;
+  }
+
+  /* Make sure scalar types match. */
+  else if (!gfc_compare_types (&expr->ts, ts)
+           && gfc_convert_type (expr, ts, 1) == FAILURE)
+    goto cleanup;
+
+  if (expr->ts.u.cl)
+    expr->ts.u.cl->length_from_typespec = 1;
+
+  *result = expr;
+  mpz_clear (size);
+  mpz_clear (repeat);
+  return MATCH_YES;
+
+syntax:
+  gfc_error ("Syntax error in old style initializer list at %C");
+
+cleanup:
+  gfc_constructor_free (array_head);
+  expr->value.constructor = NULL;
+  gfc_free_expr (expr);
+  mpz_clear (size);
+  mpz_clear (repeat);
+  return MATCH_ERROR;
+}
 
 /* Auxiliary function to merge DIMENSION and CODIMENSION array specs.  */
 
@@ -1344,7 +1485,7 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)
 
       /* Check if the assignment can happen. This has to be put off
 	 until later for derived type variables and procedure pointers.  */
-      if (sym->ts.type != BT_DERIVED && init->ts.type != BT_DERIVED
+      if (!gfc_bt_struct (sym->ts.type) && !gfc_bt_struct (init->ts.type)
 	  && sym->ts.type != BT_CLASS && init->ts.type != BT_CLASS
 	  && !sym->attr.proc_pointer
 	  && gfc_check_assign_symbol (sym, NULL, init) == FAILURE)
@@ -1464,7 +1605,7 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)
 	 If we mark my_int as iso_c (since we can see it's value
 	 is equal to one of the named constants), then my_int_2
 	 will be considered C interoperable.  */
-      if (sym->ts.type != BT_CHARACTER && sym->ts.type != BT_DERIVED)
+      if (sym->ts.type != BT_CHARACTER && !gfc_bt_struct (sym->ts.type))
 	{
 	  sym->ts.is_iso_c |= init->ts.is_iso_c;
 	  sym->ts.is_c_interop |= init->ts.is_c_interop;
@@ -1522,6 +1663,7 @@ static gfc_try
 build_struct (const char *name, gfc_charlen *cl, gfc_expr **init,
 	      gfc_array_spec **as)
 {
+  gfc_state_data *s;
   gfc_component *c;
   gfc_try t = SUCCESS;
 
@@ -1545,6 +1687,32 @@ build_struct (const char *name, gfc_charlen *cl, gfc_expr **init,
 	}
     }
 
+  /* If we are in a nested union/map definition, gfc_add_component will not
+     properly find repeated components because they are implicitly chained.
+     Since union and map blocks are not actually linked as components of their
+     parent structures until after they are parsed, we must traverse up the
+     parse stack until we find the top level structure declaration, searching
+     for the component in each block along the way. */
+  s = gfc_state_stack;
+  if (s->state == COMP_UNION || s->state == COMP_MAP)
+  {
+    while (s->state == COMP_UNION || s->state == COMP_MAP
+           || gfc_comp_is_derived (s->state))
+    {
+      c = gfc_find_component (s->sym, name, true, true, NULL);
+      if (c != NULL)
+      {
+        gfc_error_now ("Component '%s' at %C already declared at %L",
+                       name, &c->loc);
+        return FAILURE;
+      }
+      /* Break after we've searched the ultimate parent of the current union. */
+      if (s->state == COMP_DERIVED || s->state == COMP_STRUCTURE)
+        break;
+      s = s->previous;
+    }
+  }
+
   if (gfc_add_component (gfc_current_block (), name, &c) == FAILURE)
     return FAILURE;
 
@@ -1566,51 +1734,7 @@ build_struct (const char *name, gfc_charlen *cl, gfc_expr **init,
     }
   *as = NULL;
 
-  /* Should this ever get more complicated, combine with similar section
-     in add_init_expr_to_sym into a separate function.  */
-  if (c->ts.type == BT_CHARACTER && !c->attr.pointer && c->initializer
-      && c->ts.u.cl
-      && c->ts.u.cl->length && c->ts.u.cl->length->expr_type == EXPR_CONSTANT)
-    {
-      int len;
-
-      gcc_assert (c->ts.u.cl && c->ts.u.cl->length);
-      gcc_assert (c->ts.u.cl->length->expr_type == EXPR_CONSTANT);
-      gcc_assert (c->ts.u.cl->length->ts.type == BT_INTEGER);
-
-      len = mpz_get_si (c->ts.u.cl->length->value.integer);
-
-      if (c->initializer->expr_type == EXPR_CONSTANT)
-	gfc_set_constant_character_len (len, c->initializer, -1);
-      else if (mpz_cmp (c->ts.u.cl->length->value.integer,
-			c->initializer->ts.u.cl->length->value.integer))
-	{
-	  gfc_constructor *ctor;
-	  ctor = gfc_constructor_first (c->initializer->value.constructor);
-
-	  if (ctor)
-	    {
-	      int first_len;
-	      bool has_ts = (c->initializer->ts.u.cl
-			     && c->initializer->ts.u.cl->length_from_typespec);
-
-	      /* Remember the length of the first element for checking
-		 that all elements *in the constructor* have the same
-		 length.  This need not be the length of the LHS!  */
-	      gcc_assert (ctor->expr->expr_type == EXPR_CONSTANT);
-	      gcc_assert (ctor->expr->ts.type == BT_CHARACTER);
-	      first_len = ctor->expr->value.character.length;
-
-	      for ( ; ctor; ctor = gfc_constructor_next (ctor))
-		if (ctor->expr->expr_type == EXPR_CONSTANT)
-		{
-		  gfc_set_constant_character_len (len, ctor->expr,
-						  has_ts ? -1 : first_len);
-		  ctor->expr->ts.u.cl->length = gfc_copy_expr (c->ts.u.cl->length);
-		}
-	    }
-	}
-    }
+  gfc_apply_init (&c->ts, &c->attr, c->initializer);
 
   /* Check array components.  */
   if (!c->attr.dimension)
@@ -1727,7 +1851,7 @@ match_pointer_init (gfc_expr **init, int procptr)
 {
   match m;
 
-  if (gfc_pure (NULL) && gfc_state_stack->state != COMP_DERIVED)
+  if (gfc_pure (NULL) && !gfc_comp_is_derived(gfc_state_stack->state))
     {
       gfc_error ("Initialization of pointer at %C is not allowed in "
 		 "a PURE procedure");
@@ -1798,6 +1922,7 @@ static match
 variable_decl (int elem)
 {
   char name[GFC_MAX_SYMBOL_LEN + 1];
+  static int fill_id = 0;
   gfc_expr *initializer, *char_len;
   gfc_array_spec *as;
   gfc_array_spec *cp_as; /* Extra copy for Cray Pointees.  */
@@ -1815,9 +1940,44 @@ variable_decl (int elem)
   /* When we get here, we've just matched a list of attributes and
      maybe a type and a double colon.  The next thing we expect to see
      is the name of the symbol.  */
-  m = gfc_match_name (name);
+
+  /* If we are parsing a structure, we allow the name of the symbol to
+     be '%FILL', which gives it an anonymous (inaccessible) name. */
+  m = MATCH_NO;
+  gfc_gobble_whitespace ();
+  if (gfc_peek_ascii_char () == '%')
+  {
+    gfc_next_ascii_char ();
+    m = gfc_match ("fill");
+  }
   if (m != MATCH_YES)
-    goto cleanup;
+  {
+    m = gfc_match_name (name);
+    if (m != MATCH_YES)
+      goto cleanup;
+  }
+  else 
+  {
+    m = MATCH_ERROR;
+    if (!gfc_option.flag_dec_structure)
+    {
+      gfc_error ("%%FILL at %C is an extension, enable with -fdec-structure");
+      goto cleanup;
+    }
+    if (gfc_current_state () != COMP_STRUCTURE)
+    {
+      gfc_error ("Unnamed field at %C only allowed in a STRUCTURE block");
+      goto cleanup;
+    }
+    if (attr_seen)
+    {
+      gfc_error ("Unnamed field at %C may not have attributes");
+      goto cleanup;
+    }
+    /* The unique anonymous name is an invalid fortran identifier. */
+    sprintf (name, "%%FILL%d", fill_id++);
+    m = MATCH_YES;
+  }
 
   var_locus = gfc_current_locus;
 
@@ -1902,9 +2062,19 @@ variable_decl (int elem)
 	}
     }
 
+  /* Fill components may not have initializers. */
+  if (name[0] == '%' && gfc_match_eos () != MATCH_YES) 
+  {
+    gfc_error ("Unnamed field at %C may not have initializers");
+    m = MATCH_ERROR;
+    goto cleanup;
+  }
+
   /*  If this symbol has already shown up in a Cray Pointer declaration,
+      and this is not a component declaration,
       then we want to set the type & bail out.  */
-  if (gfc_option.flag_cray_pointer)
+  if (gfc_option.flag_cray_pointer
+      && !gfc_comp_is_derived (gfc_current_state ()))
     {
       gfc_find_symbol (name, gfc_current_ns, 1, &sym);
       if (sym != NULL && sym->attr.cray_pointee)
@@ -1969,7 +2139,7 @@ variable_decl (int elem)
      For components of derived types, it is not true, so we don't
      create a symbol for those yet.  If we fail to create the symbol,
      bail out.  */
-  if (gfc_current_state () != COMP_DERIVED
+  if (!gfc_comp_is_derived (gfc_current_state ())
       && build_sym (name, cl, cl_deferred, &as, &var_locus) == FAILURE)
     {
       m = MATCH_ERROR;
@@ -1996,8 +2166,33 @@ variable_decl (int elem)
       if (gfc_notify_std (GFC_STD_GNU, "Old-style "
 			  "initialization at %C") == FAILURE)
 	return MATCH_ERROR;
+      /* Allow old style initializations for STRUCTURE/MAP declarations but
+         not derived TYPE declarations (matches DEC/Intel behavior). */
+      else if (gfc_current_state () == COMP_DERIVED)
+        {
+          gfc_error ("Invalid old style initialization for derived type "
+                     "component at %C");
+          m = MATCH_ERROR;
+          goto cleanup;
+        }
+
+      /* For derived type components, read the initializer as a special
+         expression and let the rest of this function apply the initializer
+         as usual. */
+      else if (gfc_comp_is_derived (gfc_current_state ()))
+      {
+        m = gfc_match_clist_expr (&initializer, &current_ts, as);
+        if (m == MATCH_NO)
+          gfc_error ("Syntax error in old style initialization of "
+                     "structure component %s at %C", name);
+        if (m != MATCH_YES)
+          goto cleanup;
+      }
 
-      return match_old_style_init (name);
+      /* Otherwise we treat the old style initialization just like a
+         DATA declaration for the current variable. */
+      else
+        return match_old_style_init (name);
     }
 
   /* The double colon must be present in order to have initializers.
@@ -2035,7 +2230,7 @@ variable_decl (int elem)
 	    }
 
 	  if (current_attr.flavor != FL_PARAMETER && gfc_pure (NULL)
-	      && gfc_state_stack->state != COMP_DERIVED)
+	      && !gfc_comp_is_derived (gfc_state_stack->state))
 	    {
 	      gfc_error ("Initialization of variable at %C is not allowed in "
 			 "a PURE procedure");
@@ -2043,7 +2238,7 @@ variable_decl (int elem)
 	    }
 
 	  if (current_attr.flavor != FL_PARAMETER
-	      && gfc_state_stack->state != COMP_DERIVED)
+	      && !gfc_comp_is_derived(gfc_state_stack->state))
 	    gfc_unset_implicit_pure (gfc_current_ns->proc_name);
 
 	  if (m != MATCH_YES)
@@ -2052,7 +2247,7 @@ variable_decl (int elem)
     }
 
   if (initializer != NULL && current_attr.allocatable
-	&& gfc_current_state () == COMP_DERIVED)
+	&& gfc_comp_is_derived (gfc_current_state ()))
     {
       gfc_error ("Initialization of allocatable component at %C is not "
 		 "allowed");
@@ -2063,13 +2258,13 @@ variable_decl (int elem)
   /* Add the initializer.  Note that it is fine if initializer is
      NULL here, because we sometimes also need to check if a
      declaration *must* have an initialization expression.  */
-  if (gfc_current_state () != COMP_DERIVED)
+  if (!gfc_comp_is_derived (gfc_current_state ()))
     t = add_init_expr_to_sym (name, &initializer, &var_locus);
   else
     {
       if (current_ts.type == BT_DERIVED
 	  && !current_attr.pointer && !initializer)
-	initializer = gfc_default_initializer (&current_ts);
+	initializer = gfc_default_initializer (&current_ts, false);
       t = build_struct (name, cl, &initializer, &as);
     }
 
@@ -2557,6 +2752,35 @@ done:
   return MATCH_YES;
 }
 
+/* Matches a RECORD declaration. */
+
+static match
+match_record_decl(const char *name)
+{
+    locus old_loc;
+    old_loc = gfc_current_locus;
+
+    if (gfc_match (" record") == MATCH_YES)
+    {
+        if (!gfc_option.flag_dec_structure)
+        {
+            gfc_current_locus = old_loc;
+            gfc_error ("RECORD at %C is a DEC extension, enable with "
+                       "-fdec-structure");
+            return MATCH_ERROR;
+        }
+        if (gfc_match (" /%n/", name) != MATCH_YES)
+        {
+            gfc_error ("Expected \"/field-name/\" after RECORD at %C");
+            gfc_current_locus = old_loc;
+            return MATCH_ERROR;
+        }
+        return MATCH_YES;
+    }
+
+    gfc_current_locus = old_loc;
+    return MATCH_NO;
+}
 
 /* Matches a declaration-type-spec (F03:R502).  If successful, sets the ts
    structure to the matched specification.  This is necessary for FUNCTION and
@@ -2616,7 +2840,7 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)
 	{
 	  if ((m = gfc_match ("*)")) != MATCH_YES)
 	    return m;
-	  if (gfc_current_state () == COMP_DERIVED)
+	  if (gfc_comp_is_derived (gfc_current_state ()))
 	    {
 	      gfc_error ("Assumed type at %C is not allowed for components");
 	      return MATCH_ERROR;
@@ -2729,9 +2953,57 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)
     m = gfc_match_char (')');
 
   if (m == MATCH_YES)
+  {
     ts->type = BT_DERIVED;
+    /* Don't need all the extra derived-type stuff for structures. */
+    if (gfc_find_symbol (gfc_dt_upper_string (name), NULL, 1, &sym))
+    {
+      gfc_error ("Type name '%s' at %C is ambiguous", name);
+      return MATCH_ERROR;
+    }
+    if (sym && sym->attr.flavor == FL_STRUCT)
+    {
+      ts->u.derived = sym;
+      return MATCH_YES;
+    }
+  }
   else
     {
+      /* Match RECORD declarations. */
+      m = match_record_decl (name);
+      if (m == MATCH_YES)
+      {
+        ts->type = BT_DERIVED;
+        /* Don't need all the extra derived-type stuff for structures. */
+        if (gfc_find_symbol (gfc_dt_upper_string (name), NULL, 1, &sym))
+        {
+          gfc_error ("Type name '%s' at %C is ambiguous", name);
+          return MATCH_ERROR;
+        }
+        if (sym && sym->attr.flavor == FL_STRUCT)
+        {
+          ts->u.derived = sym;
+          return MATCH_YES;
+        }
+        goto derived;
+      }
+
+      /* Match ad-hoc STRUCTURE declarations; only valid within another
+         derived/structure declaration. */
+      m = gfc_match (" structure");
+      if (m == MATCH_YES && gfc_comp_is_derived (gfc_current_state ()))
+      {
+        m = gfc_match_structure_decl ();
+        if (m == MATCH_YES)
+        {
+          /* gfc_new_block updated by match_structure_decl() */
+          ts->type = BT_DERIVED;
+          ts->u.derived = gfc_new_block;
+          return MATCH_YES;
+        }
+        return MATCH_ERROR;
+      }
+
       /* Match CLASS declarations.  */
       m = gfc_match (" class ( * )");
       if (m == MATCH_ERROR)
@@ -2780,6 +3052,7 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)
 	return MATCH_ERROR;
     }
 
+derived:
   /* Defer association of the derived type until the end of the
      specification block.  However, if the derived type can be
      found, add it to the typespec.  */
@@ -2801,9 +3074,7 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)
      stored in a symtree with the first letter of the name capitalized; the
      symtree with the all lower-case name contains the associated
      generic function.  */
-  dt_name = gfc_get_string ("%c%s",
-			    (char) TOUPPER ((unsigned char) name[0]),
-			    (const char*)&name[1]);
+  dt_name = gfc_dt_upper_string (name);
   sym = NULL;
   dt_sym = NULL;
   if (ts->kind != -1)
@@ -2835,7 +3106,7 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)
 	return MATCH_NO;
     }
 
-  if ((sym->attr.flavor != FL_UNKNOWN
+  if ((sym->attr.flavor != FL_UNKNOWN && sym->attr.flavor != FL_STRUCT
        && !(sym->attr.flavor == FL_PROCEDURE && sym->attr.generic))
       || sym->attr.subroutine)
     {
@@ -2872,9 +3143,8 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)
 
   gfc_set_sym_referenced (dt_sym);
 
-  if (dt_sym->attr.flavor != FL_DERIVED
-      && gfc_add_flavor (&dt_sym->attr, FL_DERIVED, sym->name, NULL)
-			 == FAILURE)
+  if (dt_sym->attr.flavor != FL_DERIVED && dt_sym->attr.flavor != FL_STRUCT
+      && gfc_add_flavor (&dt_sym->attr, FL_DERIVED, sym->name, NULL) == FAILURE)
     return MATCH_ERROR;
 
   ts->u.derived = dt_sym;
@@ -3235,9 +3505,7 @@ gfc_match_import (void)
 		 letter of the name capitalized; the symtree with the all
 		 lower-case name contains the associated generic function. */
 	      st = gfc_new_symtree (&gfc_current_ns->sym_root,
-			gfc_get_string ("%c%s",
-				(char) TOUPPER ((unsigned char) name[0]),
-				&name[1]));
+                                    gfc_dt_upper_string (name));
 	      st->n.sym = sym;
 	      sym->refs++;
 	      sym->attr.imported = 1;
@@ -3301,6 +3569,7 @@ match_attr_spec (void)
     DECL_ALLOCATABLE = GFC_DECL_BEGIN, DECL_DIMENSION, DECL_EXTERNAL,
     DECL_IN, DECL_OUT, DECL_INOUT, DECL_INTRINSIC, DECL_OPTIONAL,
     DECL_PARAMETER, DECL_POINTER, DECL_PROTECTED, DECL_PRIVATE,
+    DECL_STATIC, DECL_AUTOMATIC,
     DECL_PUBLIC, DECL_SAVE, DECL_TARGET, DECL_VALUE, DECL_VOLATILE,
     DECL_IS_BIND_C, DECL_CODIMENSION, DECL_ASYNCHRONOUS, DECL_CONTIGUOUS,
     DECL_NONE, GFC_DECL_END /* Sentinel */
@@ -3321,6 +3590,7 @@ match_attr_spec (void)
 
   current_as = NULL;
   colon_seen = 0;
+  attr_seen = 0;
 
   /* See if we get all of the keywords up to the final double colon.  */
   for (d = GFC_DECL_BEGIN; d != GFC_DECL_END; d++)
@@ -3364,6 +3634,14 @@ match_attr_spec (void)
 		      d = DECL_ASYNCHRONOUS;
 		    }
 		  break;
+
+                case 'u':
+                  if (match_string_p ("tomatic"))
+                    {
+                      /* Matched "automatic". */
+                      d = DECL_AUTOMATIC;
+                    }
+                  break;
 		}
 	      break;
 
@@ -3492,8 +3770,25 @@ match_attr_spec (void)
 	      break;
 
 	    case 's':
-	      if (match_string_p ("save"))
-		d = DECL_SAVE;
+	      gfc_next_ascii_char ();
+	      switch (gfc_next_ascii_char ())
+                {
+                  case 'a':
+                  if (match_string_p ("ve"))
+                    {
+                      /* Matched "save". */
+                      d = DECL_SAVE;
+                    }
+                  break;
+
+                  case 't':
+                  if (match_string_p ("atic"))
+                    {
+                      /* Matched "static". */
+                      d = DECL_STATIC;
+                    }
+                  break;
+                }
 	      break;
 
 	    case 't':
@@ -3630,6 +3925,12 @@ match_attr_spec (void)
 	  case DECL_SAVE:
 	    attr = "SAVE";
 	    break;
+          case DECL_STATIC:
+            attr = "STATIC";
+            break;
+          case DECL_AUTOMATIC:
+            attr = "AUTOMATIC";
+            break;
 	  case DECL_TARGET:
 	    attr = "TARGET";
 	    break;
@@ -3657,8 +3958,22 @@ match_attr_spec (void)
     {
       if (seen[d] == 0)
 	continue;
+      else
+        attr_seen = 1;
 
-      if (gfc_current_state () == COMP_DERIVED
+      if ((d == DECL_STATIC || d == DECL_AUTOMATIC)
+          && !gfc_option.flag_dec_static)
+      {
+        gfc_error ("%s at %L is a DEC extension, enable with -fdec-static",
+                   d == DECL_STATIC ? "STATIC" : "AUTOMATIC", &seen_at[d]);
+        m = MATCH_ERROR;
+        goto cleanup;
+      }
+      /* Allow SAVE with STATIC, but don't complain. */
+      if (d == DECL_STATIC && seen[DECL_SAVE])
+        continue;
+
+      if (gfc_comp_is_derived (gfc_current_state ())
 	  && d != DECL_DIMENSION && d != DECL_CODIMENSION
 	  && d != DECL_POINTER   && d != DECL_PRIVATE
 	  && d != DECL_PUBLIC && d != DECL_CONTIGUOUS && d != DECL_NONE)
@@ -3666,7 +3981,8 @@ match_attr_spec (void)
 	  if (d == DECL_ALLOCATABLE)
 	    {
 	      if (gfc_notify_std (GFC_STD_F2003, "ALLOCATABLE "
-				  "attribute at %C in a TYPE definition")
+				  "attribute at %C in a %s definition",
+                                  gfc_ascii_comp_state(gfc_current_state()))
 		  == FAILURE)
 		{
 		  m = MATCH_ERROR;
@@ -3675,8 +3991,8 @@ match_attr_spec (void)
 	    }
 	  else
 	    {
-	      gfc_error ("Attribute at %L is not allowed in a TYPE definition",
-			 &seen_at[d]);
+	      gfc_error ("Attribute at %L is not allowed in a %s definition",
+			&seen_at[d], gfc_ascii_comp_state(gfc_current_state()));
 	      m = MATCH_ERROR;
 	      goto cleanup;
 	    }
@@ -3689,13 +4005,14 @@ match_attr_spec (void)
 	    attr = "PRIVATE";
 	  else
 	    attr = "PUBLIC";
-	  if (gfc_current_state () == COMP_DERIVED
+	  if (gfc_comp_is_derived (gfc_current_state ())
 	      && gfc_state_stack->previous
 	      && gfc_state_stack->previous->state == COMP_MODULE)
 	    {
 	      if (gfc_notify_std (GFC_STD_F2003, "Attribute %s "
-				  "at %L in a TYPE definition", attr,
-				  &seen_at[d])
+				  "at %L in a %s definition", attr,
+				  &seen_at[d],
+                                  gfc_ascii_comp_state(gfc_current_state()))
 		  == FAILURE)
 		{
 		  m = MATCH_ERROR;
@@ -3802,10 +4119,15 @@ match_attr_spec (void)
 			      &seen_at[d]);
 	  break;
 
+        case DECL_STATIC:
 	case DECL_SAVE:
 	  t = gfc_add_save (&current_attr, SAVE_EXPLICIT, NULL, &seen_at[d]);
 	  break;
 
+        case DECL_AUTOMATIC:
+          t = gfc_add_automatic (&current_attr, NULL, &seen_at[d]);
+          break;
+
 	case DECL_TARGET:
 	  t = gfc_add_target (&current_attr, &seen_at[d]);
 	  break;
@@ -3855,6 +4177,7 @@ cleanup:
   gfc_current_locus = start;
   gfc_free_array_spec (current_as);
   current_as = NULL;
+  attr_seen = 0;
   return m;
 }
 
@@ -3907,7 +4230,7 @@ set_com_block_bind_c (gfc_common_head *com_block, int is_bind_c)
 gfc_try
 gfc_verify_c_interop (gfc_typespec *ts)
 {
-  if (ts->type == BT_DERIVED && ts->u.derived != NULL)
+  if (gfc_bt_struct (ts->type) && ts->u.derived != NULL)
     return (ts->u.derived->ts.is_c_interop || ts->u.derived->attr.is_bind_c)
 	   ? SUCCESS : FAILURE;
   else if (ts->type == BT_CLASS)
@@ -3997,7 +4320,8 @@ verify_bind_c_sym (gfc_symbol *tmp_sym, gfc_typespec *ts,
 	    }
 	  else
 	    {
-              if (tmp_sym->ts.type == BT_DERIVED || ts->type == BT_DERIVED)
+              if (gfc_bt_struct (tmp_sym->ts.type) 
+                  || gfc_bt_struct (ts->type))
                 gfc_error ("Type declaration '%s' at %L is not C "
                            "interoperable but it is BIND(C)",
                            tmp_sym->name, &(tmp_sym->declared_at));
@@ -4259,7 +4583,7 @@ gfc_match_data_decl (void)
     return m;
 
   if ((current_ts.type == BT_DERIVED || current_ts.type == BT_CLASS)
-	&& gfc_current_state () != COMP_DERIVED)
+	&& !gfc_comp_is_derived(gfc_current_state ()))
     {
       sym = gfc_use_derived (current_ts.u.derived);
 
@@ -4288,7 +4612,7 @@ gfc_match_data_decl (void)
       && !current_ts.u.derived->attr.zero_comp)
     {
 
-      if (current_attr.pointer && gfc_current_state () == COMP_DERIVED)
+      if (current_attr.pointer && gfc_comp_is_derived (gfc_current_state ()))
 	goto ok;
 
       gfc_find_symbol (current_ts.u.derived->name,
@@ -4296,7 +4620,7 @@ gfc_match_data_decl (void)
 
       /* Any symbol that we find had better be a type definition
 	 which has its components defined.  */
-      if (sym != NULL && sym->attr.flavor == FL_DERIVED
+      if (sym != NULL && gfc_fl_struct (sym->attr.flavor)
 	  && (current_ts.u.derived->components != NULL
 	      || current_ts.u.derived->attr.zero_comp))
 	goto ok;
@@ -5200,6 +5524,7 @@ gfc_match_procedure (void)
     case COMP_INTERFACE:
       m = match_procedure_in_interface ();
       break;
+    case COMP_STRUCTURE:
     case COMP_DERIVED:
       m = match_ppc_decl ();
       break;
@@ -5447,6 +5772,10 @@ gfc_match_entry (void)
 	    gfc_error ("ENTRY statement at %C cannot appear within "
 		       "an INTERFACE");
 	    break;
+          case COMP_STRUCTURE:
+            gfc_error ("ENTRY statement at %C cannot appear within "
+                       "a STRUCTURE block");
+            break;
 	  case COMP_DERIVED:
 	    gfc_error ("ENTRY statement at %C cannot appear within "
 		       "a DERIVED TYPE block");
@@ -6032,6 +6361,24 @@ gfc_match_end (gfc_statement *st)
       eos_ok = 0;
       break;
 
+    case COMP_MAP:
+      *st = ST_END_MAP;
+      target = " map";
+      eos_ok = 0;
+      break;
+
+    case COMP_UNION:
+      *st = ST_END_UNION;
+      target = " union";
+      eos_ok = 0;
+      break;
+
+    case COMP_STRUCTURE:
+      *st = ST_END_STRUCTURE;
+      target = " structure";
+      eos_ok = 0;
+      break;
+
     case COMP_DERIVED:
     case COMP_DERIVED_CONTAINS:
       *st = ST_END_TYPE;
@@ -7022,6 +7369,110 @@ gfc_match_parameter (void)
 }
 
 
+match
+gfc_match_automatic (void)
+{
+  gfc_symbol *sym;
+  match m;
+  bool seen_symbol = false;
+
+  if (!gfc_option.flag_dec_static)
+  {
+    gfc_error ("AUTOMATIC at %C is a DEC extension, enable with -fdec-static");
+    return MATCH_ERROR;
+  }
+
+  gfc_match (" ::");
+
+  for (;;)
+    {
+      m = gfc_match_symbol (&sym, 0);
+      switch (m)
+	{
+        case MATCH_NO:
+	case MATCH_ERROR:
+	  return MATCH_ERROR;
+
+	case MATCH_YES:
+	  if (gfc_add_automatic (&sym->attr, sym->name, &gfc_current_locus)
+              == FAILURE)
+	    return MATCH_ERROR;
+          seen_symbol = true;
+	  break;
+	}
+
+      if (gfc_match_eos () == MATCH_YES)
+	break;
+      if (gfc_match_char (',') != MATCH_YES)
+	goto syntax;
+    }
+
+  if (!seen_symbol)
+  {
+    gfc_error ("Expected var-list in AUTOMATIC statement at %C");
+    return MATCH_ERROR;
+  }
+
+  return MATCH_YES;
+
+syntax:
+  gfc_error ("Syntax error in AUTOMATIC statement at %C");
+  return MATCH_ERROR;
+}
+
+
+match
+gfc_match_static (void)
+{
+  gfc_symbol *sym;
+  match m;
+  bool seen_symbol = false;
+
+  if (!gfc_option.flag_dec_static)
+  {
+    gfc_error ("STATIC at %C is a DEC extension, enable with -fdec-static");
+    return MATCH_ERROR;
+  }
+
+  gfc_match (" ::");
+
+  for (;;)
+    {
+      m = gfc_match_symbol (&sym, 0);
+      switch (m)
+	{
+        case MATCH_NO:
+	case MATCH_ERROR:
+	  return MATCH_ERROR;
+
+	case MATCH_YES:
+	  if (gfc_add_save (&sym->attr, SAVE_EXPLICIT, sym->name,
+			    &gfc_current_locus) == FAILURE)
+	    return MATCH_ERROR;
+          seen_symbol = true;
+	  break;
+	}
+
+      if (gfc_match_eos () == MATCH_YES)
+	break;
+      if (gfc_match_char (',') != MATCH_YES)
+	goto syntax;
+    }
+
+  if (!seen_symbol)
+  {
+    gfc_error ("Expected var-list in STATIC statement at %C");
+    return MATCH_ERROR;
+  }
+
+  return MATCH_YES;
+
+syntax:
+  gfc_error ("Syntax error in STATIC statement at %C");
+  return MATCH_ERROR;
+}
+
+
 /* Save statements have a special syntax.  */
 
 match
@@ -7504,6 +7955,222 @@ gfc_get_type_attr_spec (symbol_attribute *attr, char *name)
   return MATCH_YES;
 }
 
+/* Common function for type declaration blocks similar to derived types, such
+   as STRUCTURES and MAPs. Unlike derived types, a structure type
+   does NOT have a generic symbol matching the name given by the user.
+   STRUCTUREs can share names with variables and PARAMETERs so we must allow
+   for the creation of an independent symbol.
+   Other parameters are a message to prefix errors with, the name of the new 
+   type to be created, and the flavor to add to the resulting symbol. */
+
+static gfc_try
+get_struct_decl (const char *name, sym_flavor fl, locus *decl,
+                 gfc_symbol **result)
+{
+  gfc_symbol *sym;
+  locus where;
+
+  if (decl)
+    where = *decl;
+  else
+    where = gfc_current_locus;
+
+  if (gfc_get_symbol (name, NULL, &sym))
+    return FAILURE;
+
+  sym->declared_at = where;
+
+  gcc_assert (name[0] == (char) TOUPPER (name[0]));
+
+  if (sym && (sym->components != NULL || sym->attr.zero_comp))
+  {
+    gfc_error ("Type definition of '%s' at %C was already defined at %L", 
+               sym->name, &sym->declared_at);
+    return FAILURE;
+  }
+
+  if (!sym)
+  {
+    gfc_internal_error ("Failed to create structure type '%s' at %C", name);
+    return FAILURE;
+  }
+
+  if (sym->attr.flavor != fl
+      && gfc_add_flavor (&sym->attr, fl, sym->name, NULL) == FAILURE)
+    return FAILURE;
+
+  if (!sym->hash_value)
+      /* Set the hash for the compound name for this type.  */
+    sym->hash_value = gfc_hash_value (sym);
+
+  /* Normally the type is expected to have been completely parsed by the time
+     a field declaration with this type is seen. For unions, maps, and nested
+     structure declarations, we need to indicate that it is okay that we
+     haven't seen any components yet. This will be updated after the structure
+     is fully parsed. */
+  sym->attr.zero_comp = 1;
+
+  /* Structures always act like derived-types with the SEQUENCE attribute */
+  gfc_add_sequence (&sym->attr, sym->name, NULL);
+
+  if (result) *result = sym;
+
+  return SUCCESS;
+}
+
+match
+gfc_match_map (void)
+{
+    /* Counter used to give unique internal names to map declarations. */
+    static unsigned int gfc_map_id = 0;
+    char name[GFC_MAX_SYMBOL_LEN + 1];
+    gfc_symbol *sym;
+    locus old_loc;
+
+    old_loc = gfc_current_locus;
+
+    if (gfc_current_state () != COMP_UNION)
+    {
+        gfc_current_locus = old_loc;
+        gfc_error ("MAP statement at %C illegal outside of union declaration");
+        return MATCH_ERROR;
+    }
+    if (gfc_match_eos () != MATCH_YES)
+    {
+        gfc_error ("Expected end of statement at %C after MAP statement");
+        gfc_current_locus = old_loc;
+        return MATCH_ERROR;
+    }
+
+    /* Make up a unique name for the map to store it in the symbol table. */
+    snprintf (name, GFC_MAX_SYMBOL_LEN + 1, "MM$%u", gfc_map_id++);
+
+    if (get_struct_decl (name, FL_STRUCT, &old_loc, &sym) == FAILURE)
+      return MATCH_ERROR;
+
+    gfc_new_block = sym;
+
+    return MATCH_YES;
+}
+
+match
+gfc_match_union (void)
+{
+    /* Counter used to give unique internal names to union declarations. */
+    static unsigned int gfc_union_id = 0;
+    char name[GFC_MAX_SYMBOL_LEN + 1];
+    gfc_symbol *sym;
+    locus old_loc;
+
+    old_loc = gfc_current_locus;
+
+    if (!gfc_comp_is_derived (gfc_current_state ()))
+    {
+        gfc_current_locus = old_loc;
+        gfc_error ("UNION statement at %C illegal outside of structure "
+                   "declaration");
+        return MATCH_ERROR;
+    }
+    if (gfc_match_eos () != MATCH_YES)
+    {
+        gfc_error ("Expected end of statement at %C after UNION statement");
+        gfc_current_locus = old_loc;
+        return MATCH_ERROR;
+    }
+
+    snprintf (name, GFC_MAX_SYMBOL_LEN + 1, "UU$%u", gfc_union_id++);
+    if (get_struct_decl (name, FL_UNION, &old_loc, &sym) == FAILURE)
+      return MATCH_ERROR;
+
+    gfc_new_block = sym;
+
+    return MATCH_YES;
+}
+
+/* Match the beginning of a structure declaration. This is similar to
+   matching the beginning of a derived type declaration, but the resulting
+   symbol has no access control or other interesting attributes. 
+   
+   If we are inside another structure declaration, we expect a field list
+   after the name of the structure. For example, in the following structure,
+   appointments have members START and END which are of ad-hoc structure type.
+   STRUCTURE /APPOINTMENT/ 
+     STRUCTURE /TIME/ START, END
+       INTEGER*1 HOUR, MINUTE, SECOND
+     END STRUCTURE
+     ...
+   END STRUCTURE
+   */
+
+match
+gfc_match_structure_decl (void)
+{
+    /* Counter used to give anonymous structures unique internal names. */
+    int gfc_structure_id = 0;
+    char name[GFC_MAX_SYMBOL_LEN + 1];
+    gfc_interface *intr;
+    gfc_symbol *sym;
+    match m;
+    locus where;
+
+    if(!gfc_option.flag_dec_structure)
+    {
+        gfc_error ("STRUCTURE at %C is a DEC extension, enable with "
+                   "-fdec-structure");
+        return MATCH_ERROR;
+    }
+
+    name[0] = '\0';
+
+    m = gfc_match (" /%n/", name);
+    if (m != MATCH_YES)
+    {
+        /* Non-nested structure declarations require a structure name. */
+        if (!gfc_comp_is_derived (gfc_current_state ()))
+        {
+            gfc_error ("Structure name expected in non-nested structure "
+                       "declaration at %C");
+            return MATCH_ERROR;
+        }
+        /* This is an anonymous structure; make up a unique name for it
+           (upper-case letters never make it to symbol names from the source).
+           The important thing is initializing the type declaration variable
+           and setting gfc_new_symbol, which is immediately used by
+           parse_structure () and variable_decl () to add fields of this type
+           and add components. */
+        snprintf (name, GFC_MAX_SYMBOL_LEN + 1, "SS$%u", gfc_structure_id++);
+    }
+    where = gfc_current_locus;
+    /* No field list allowed after non-nested structure declaration. */
+    if (!gfc_comp_is_derived (gfc_current_state ()) && gfc_match_eos () != MATCH_YES)
+    {
+        gfc_error ("Field list at %C illegal in non-nested structure "
+                   "declaration");
+        return MATCH_ERROR;
+    }
+
+    /* Make sure the name is not the name of an intrinsic type.  */
+    if (gfc_is_intrinsic_typename (name))
+    {
+      gfc_error ("Structure name '%s' at %C cannot be the same as an intrinsic "
+                 "type", name);
+      return MATCH_ERROR;
+    }
+
+    sprintf (name, gfc_dt_upper_string (name));
+    if (get_struct_decl (name, FL_STRUCT, &where, &sym) == FAILURE)
+      return MATCH_ERROR;
+
+    intr = gfc_get_interface ();
+    intr->sym = sym;
+    intr->where = where;
+    sym->generic = intr;
+    sym->attr.if_source = IFSRC_DECL;
+    sym->attr.generic = 1;
+
+    gfc_new_block = sym;
+    return MATCH_YES;
+}
 
 /* Match the beginning of a derived type declaration.  If a type name
    was the result of a function, then it is possible to have a symbol
@@ -7520,9 +8187,10 @@ gfc_match_derived_decl (void)
   match m;
   match is_type_attr_spec = MATCH_NO;
   bool seen_attr = false;
+  locus where;
   gfc_interface *intr = NULL, *head;
 
-  if (gfc_current_state () == COMP_DERIVED)
+  if (gfc_comp_is_derived (gfc_current_state ()))
     return MATCH_NO;
 
   name[0] = '\0';
@@ -7554,7 +8222,11 @@ gfc_match_derived_decl (void)
       return MATCH_ERROR;
     }
 
-  m = gfc_match (" %n%t", name);
+  m = gfc_match (" %n", name);
+  if (m != MATCH_YES)
+    return m;
+  where = gfc_current_locus;
+  m = gfc_match_eos ();
   if (m != MATCH_YES)
     return m;
 
@@ -7608,6 +8280,7 @@ gfc_match_derived_decl (void)
       intr->next = head;
       gensym->generic = intr;
       gensym->attr.if_source = IFSRC_DECL;
+      gensym->declared_at = where;
     }
 
   /* The symbol may already have the derived attribute without the
@@ -7652,7 +8325,7 @@ gfc_match_derived_decl (void)
 
       p->ts.type = BT_DERIVED;
       p->ts.u.derived = extended;
-      p->initializer = gfc_default_initializer (&p->ts);
+      p->initializer = gfc_default_initializer (&p->ts, false);
 
       /* Set extension level.  */
       if (extended->attr.extension == 255)
@@ -7679,6 +8352,13 @@ gfc_match_derived_decl (void)
   /* Take over the ABSTRACT attribute.  */
   sym->attr.abstract = attr.abstract;
 
+  /* Normally the type is expected to have been completely parsed by the time
+     a field declaration with this type is seen. For unions, maps, and nested
+     structure declarations, we need to indicate that it is okay that we
+     haven't seen any components yet. This will be updated after the structure
+     is fully parsed. */
+  sym->attr.zero_comp = sym->components == NULL;
+
   gfc_new_block = sym;
 
   return MATCH_YES;
diff --git a/gcc/fortran/dependency.c b/gcc/fortran/dependency.c
index e58bd22..3924905 100644
--- a/gcc/fortran/dependency.c
+++ b/gcc/fortran/dependency.c
@@ -1779,6 +1779,7 @@ int
 gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref, gfc_reverse *reverse)
 {
   int n;
+  int m;
   gfc_dependency fin_dep;
   gfc_dependency this_dep;
 
@@ -1828,6 +1829,8 @@ gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref, gfc_reverse *reverse)
 	      break;
 	    }
 
+	  /* Index for the reverse array.  */
+	  m = -1;
 	  for (n=0; n < lref->u.ar.dimen; n++)
 	    {
 	      /* Assume dependency when either of array reference is vector
@@ -1862,38 +1865,44 @@ gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref, gfc_reverse *reverse)
 		 The ability to reverse or not is set by previous conditions
 		 in this dimension.  If reversal is not activated, the
 		 value GFC_DEP_BACKWARD is reset to GFC_DEP_OVERLAP.  */
+
+	      /* Get the indexing right for the scalarizing loop. If this
+		 is an element, there is no corresponding loop.  */
+	      if (lref->u.ar.dimen_type[n] != DIMEN_ELEMENT)
+		m++;
+
 	      if (rref->u.ar.dimen_type[n] == DIMEN_RANGE
 		    && lref->u.ar.dimen_type[n] == DIMEN_RANGE)
 		{
 		  /* Set reverse if backward dependence and not inhibited.  */
-		  if (reverse && reverse[n] == GFC_ENABLE_REVERSE)
-		    reverse[n] = (this_dep == GFC_DEP_BACKWARD) ?
-			         GFC_REVERSE_SET : reverse[n];
+		  if (reverse && reverse[m] == GFC_ENABLE_REVERSE)
+		    reverse[m] = (this_dep == GFC_DEP_BACKWARD) ?
+			         GFC_REVERSE_SET : reverse[m];
 
 		  /* Set forward if forward dependence and not inhibited.  */
-		  if (reverse && reverse[n] == GFC_ENABLE_REVERSE)
-		    reverse[n] = (this_dep == GFC_DEP_FORWARD) ?
-			         GFC_FORWARD_SET : reverse[n];
+		  if (reverse && reverse[m] == GFC_ENABLE_REVERSE)
+		    reverse[m] = (this_dep == GFC_DEP_FORWARD) ?
+			         GFC_FORWARD_SET : reverse[m];
 
 		  /* Flag up overlap if dependence not compatible with
 		     the overall state of the expression.  */
-		  if (reverse && reverse[n] == GFC_REVERSE_SET
+		  if (reverse && reverse[m] == GFC_REVERSE_SET
 		        && this_dep == GFC_DEP_FORWARD)
 		    {
-	              reverse[n] = GFC_INHIBIT_REVERSE;
+	              reverse[m] = GFC_INHIBIT_REVERSE;
 		      this_dep = GFC_DEP_OVERLAP;
 		    }
-		  else if (reverse && reverse[n] == GFC_FORWARD_SET
+		  else if (reverse && reverse[m] == GFC_FORWARD_SET
 		        && this_dep == GFC_DEP_BACKWARD)
 		    {
-	              reverse[n] = GFC_INHIBIT_REVERSE;
+	              reverse[m] = GFC_INHIBIT_REVERSE;
 		      this_dep = GFC_DEP_OVERLAP;
 		    }
 
 		  /* If no intention of reversing or reversing is explicitly
 		     inhibited, convert backward dependence to overlap.  */
 		  if ((reverse == NULL && this_dep == GFC_DEP_BACKWARD)
-		      || (reverse != NULL && reverse[n] == GFC_INHIBIT_REVERSE))
+		      || (reverse != NULL && reverse[m] == GFC_INHIBIT_REVERSE))
 		    this_dep = GFC_DEP_OVERLAP;
 		}
 
diff --git a/gcc/fortran/dump-parse-tree.c b/gcc/fortran/dump-parse-tree.c
index 501a4eb..06d9e6c 100644
--- a/gcc/fortran/dump-parse-tree.c
+++ b/gcc/fortran/dump-parse-tree.c
@@ -47,6 +47,7 @@ static FILE *dumpfile;
 static void show_expr (gfc_expr *p);
 static void show_code_node (int, gfc_code *);
 static void show_namespace (gfc_namespace *ns);
+static void show_symbol (gfc_symbol *sym);
 
 
 /* Allow dumping of an expression in the debugger.  */
@@ -109,6 +110,10 @@ show_typespec (gfc_typespec *ts)
       fprintf (dumpfile, "%s", ts->u.derived->name);
       break;
 
+    case BT_UNION:
+      fprintf (dumpfile, "%s", ts->u.derived->name);
+      break;
+
     case BT_CHARACTER:
       if (ts->u.cl)
 	show_expr (ts->u.cl->length);
@@ -700,9 +705,11 @@ show_components (gfc_symbol *sym)
 {
   gfc_component *c;
 
+  ++show_level;
   for (c = sym->components; c; c = c->next)
     {
-      fprintf (dumpfile, "(%s ", c->name);
+      show_indent ();
+      fprintf (dumpfile, "%s ", c->name);
       show_typespec (&c->ts);
       if (c->attr.allocatable)
 	fputs (" ALLOCATABLE", dumpfile);
@@ -716,10 +723,14 @@ show_components (gfc_symbol *sym)
       show_array_spec (c->as);
       if (c->attr.access)
 	fprintf (dumpfile, " %s", gfc_code2string (access_types, c->attr.access));
-      fputc (')', dumpfile);
-      if (c->next != NULL)
-	fputc (' ', dumpfile);
+      if (c->initializer)
+      {
+        fprintf (dumpfile, " (init ");
+        show_expr (c->initializer);
+        fprintf (dumpfile, ")");
+      }
     }
+  --show_level;
 }
 
 
@@ -845,13 +856,6 @@ show_symbol (gfc_symbol *sym)
   fputs ("attributes: ", dumpfile);
   show_attr (&sym->attr, sym->module);
 
-  if (sym->value)
-    {
-      show_indent ();
-      fputs ("value: ", dumpfile);
-      show_expr (sym->value);
-    }
-
   if (sym->as)
     {
       show_indent ();
@@ -873,13 +877,6 @@ show_symbol (gfc_symbol *sym)
       fprintf (dumpfile, "result: %s", sym->result->name);
     }
 
-  if (sym->components)
-    {
-      show_indent ();
-      fputs ("components: ", dumpfile);
-      show_components (sym);
-    }
-
   if (sym->f2k_derived)
     {
       show_indent ();
@@ -910,6 +907,20 @@ show_symbol (gfc_symbol *sym)
       fputs ("Formal namespace", dumpfile);
       show_namespace (sym->formal_ns);
     }
+
+  if (sym->value)
+    {
+      show_indent ();
+      fputs ("value: ", dumpfile);
+      show_expr (sym->value);
+    }
+
+  if (sym->components)
+    {
+      show_indent ();
+      fputs ("components: ", dumpfile);
+      show_components (sym);
+    }
   --show_level;
 }
 
diff --git a/gcc/fortran/expr.c b/gcc/fortran/expr.c
index 0e89a4c..5b874af 100644
--- a/gcc/fortran/expr.c
+++ b/gcc/fortran/expr.c
@@ -333,9 +333,9 @@ gfc_copy_expr (gfc_expr *p)
 
 	case BT_HOLLERITH:
 	case BT_LOGICAL:
-	case BT_DERIVED:
 	case BT_CLASS:
 	case BT_ASSUMED:
+        case_struct_bt:
 	  break;		/* Already done.  */
 
 	case BT_PROCEDURE:
@@ -1640,7 +1640,8 @@ simplify_const_ref (gfc_expr *p)
 
 	    case AR_FULL:
 	      if (p->ref->next != NULL
-		  && (p->ts.type == BT_CHARACTER || p->ts.type == BT_DERIVED))
+		  && (p->ts.type == BT_CHARACTER 
+                      || gfc_bt_struct (p->ts.type)))
 		{
 		  for (c = gfc_constructor_first (p->value.constructor);
 		       c; c = gfc_constructor_next (c))
@@ -1650,7 +1651,7 @@ simplify_const_ref (gfc_expr *p)
 			return FAILURE;
 		    }
 
-		  if (p->ts.type == BT_DERIVED
+		  if (gfc_bt_struct (p->ts.type)
 			&& p->ref->next
 			&& (c = gfc_constructor_first (p->value.constructor)))
 		    {
@@ -2674,6 +2675,208 @@ gfc_match_init_expr (gfc_expr **result)
   return MATCH_YES;
 }
 
+/* Build an initializer for a local integer, real, complex, logical, or
+   character variable, based on the command line flags finit-local-zero,
+   finit-integer=, finit-real=, and finit-logical=. */
+gfc_expr *
+gfc_build_default_init_expr (gfc_typespec *ts, locus *where)
+{
+  int char_len;
+  int i;
+  gfc_expr *init_expr;
+
+  init_expr = gfc_get_constant_expr (ts->type, ts->kind, where);
+
+  /* We will only initialize integers, reals, complex, logicals, and
+     characters, and only if the corresponding command-line flags
+     were set.  Otherwise, we free init_expr and return null.  */
+  switch (ts->type)
+    {
+    case BT_INTEGER:
+      if (gfc_option.flag_init_integer != GFC_INIT_INTEGER_OFF)
+	mpz_set_si (init_expr->value.integer,
+			 gfc_option.flag_init_integer_value);
+      else
+	{
+	  gfc_free_expr (init_expr);
+	  init_expr = NULL;
+	}
+      break;
+
+    case BT_REAL:
+      switch (gfc_option.flag_init_real)
+	{
+	case GFC_INIT_REAL_SNAN:
+	  init_expr->is_snan = 1;
+	  /* Fall through.  */
+	case GFC_INIT_REAL_NAN:
+	  mpfr_set_nan (init_expr->value.real);
+	  break;
+
+	case GFC_INIT_REAL_INF:
+	  mpfr_set_inf (init_expr->value.real, 1);
+	  break;
+
+	case GFC_INIT_REAL_NEG_INF:
+	  mpfr_set_inf (init_expr->value.real, -1);
+	  break;
+
+	case GFC_INIT_REAL_ZERO:
+	  mpfr_set_ui (init_expr->value.real, 0.0, GFC_RND_MODE);
+	  break;
+
+	default:
+	  gfc_free_expr (init_expr);
+	  init_expr = NULL;
+	  break;
+	}
+      break;
+
+    case BT_COMPLEX:
+      switch (gfc_option.flag_init_real)
+	{
+	case GFC_INIT_REAL_SNAN:
+	  init_expr->is_snan = 1;
+	  /* Fall through.  */
+	case GFC_INIT_REAL_NAN:
+	  mpfr_set_nan (mpc_realref (init_expr->value.complex));
+	  mpfr_set_nan (mpc_imagref (init_expr->value.complex));
+	  break;
+
+	case GFC_INIT_REAL_INF:
+	  mpfr_set_inf (mpc_realref (init_expr->value.complex), 1);
+	  mpfr_set_inf (mpc_imagref (init_expr->value.complex), 1);
+	  break;
+
+	case GFC_INIT_REAL_NEG_INF:
+	  mpfr_set_inf (mpc_realref (init_expr->value.complex), -1);
+	  mpfr_set_inf (mpc_imagref (init_expr->value.complex), -1);
+	  break;
+
+	case GFC_INIT_REAL_ZERO:
+	  mpc_set_ui (init_expr->value.complex, 0, GFC_MPC_RND_MODE);
+	  break;
+
+	default:
+	  gfc_free_expr (init_expr);
+	  init_expr = NULL;
+	  break;
+	}
+      break;
+
+    case BT_LOGICAL:
+      if (gfc_option.flag_init_logical == GFC_INIT_LOGICAL_FALSE)
+	init_expr->value.logical = 0;
+      else if (gfc_option.flag_init_logical == GFC_INIT_LOGICAL_TRUE)
+	init_expr->value.logical = 1;
+      else
+	{
+	  gfc_free_expr (init_expr);
+	  init_expr = NULL;
+	}
+      break;
+
+    case BT_CHARACTER:
+      /* For characters, the length must be constant in order to
+	 create a default initializer.  */
+      if (gfc_option.flag_init_character == GFC_INIT_CHARACTER_ON
+	  && ts->u.cl->length
+	  && ts->u.cl->length->expr_type == EXPR_CONSTANT)
+	{
+	  char_len = mpz_get_si (ts->u.cl->length->value.integer);
+	  init_expr->value.character.length = char_len;
+	  init_expr->value.character.string = gfc_get_wide_string (char_len+1);
+	  for (i = 0; i < char_len; i++)
+	    init_expr->value.character.string[i]
+	      = (unsigned char) gfc_option.flag_init_character_value;
+	}
+      else
+	{
+	  gfc_free_expr (init_expr);
+	  init_expr = NULL;
+	}
+      if (!init_expr && gfc_option.flag_init_character == GFC_INIT_CHARACTER_ON
+	  && ts->u.cl->length && gfc_option.flag_max_stack_var_size != 0)
+	{
+	  gfc_actual_arglist *arg;
+	  init_expr = gfc_get_expr ();
+	  init_expr->where = *where;
+	  init_expr->ts = *ts;
+	  init_expr->expr_type = EXPR_FUNCTION;
+	  init_expr->value.function.isym =
+		gfc_intrinsic_function_by_id (GFC_ISYM_REPEAT);
+	  init_expr->value.function.name = "repeat";
+	  arg = gfc_get_actual_arglist ();
+	  arg->expr = gfc_get_character_expr (ts->kind, where, NULL, 1);
+	  arg->expr->value.character.string[0]
+		= gfc_option.flag_init_character_value;
+	  arg->next = gfc_get_actual_arglist ();
+	  arg->next->expr = gfc_copy_expr (ts->u.cl->length);
+	  init_expr->value.function.actual = arg;
+	}
+      break;
+
+    default:
+     gfc_free_expr (init_expr);
+     init_expr = NULL;
+    }
+
+  return init_expr;
+}
+
+
+/* Apply an initialization expression to a typespec.
+   Can be used for both symbols and components.
+   Similar to add_init_expr_to_sym in decl.c; could probably be combined with
+   some effort. */
+void
+gfc_apply_init (gfc_typespec *ts, symbol_attribute *attr, gfc_expr *init)
+{
+  if (ts->type == BT_CHARACTER && !attr->pointer && init
+      && ts->u.cl
+      && ts->u.cl->length && ts->u.cl->length->expr_type == EXPR_CONSTANT)
+    {
+      int len;
+
+      gcc_assert (ts->u.cl && ts->u.cl->length);
+      gcc_assert (ts->u.cl->length->expr_type == EXPR_CONSTANT);
+      gcc_assert (ts->u.cl->length->ts.type == BT_INTEGER);
+
+      len = mpz_get_si (ts->u.cl->length->value.integer);
+
+      if (init->expr_type == EXPR_CONSTANT)
+	gfc_set_constant_character_len (len, init, -1);
+      else if (mpz_cmp (ts->u.cl->length->value.integer,
+			init->ts.u.cl->length->value.integer))
+	{
+	  gfc_constructor *ctor;
+	  ctor = gfc_constructor_first (init->value.constructor);
+
+	  if (ctor)
+	    {
+	      int first_len;
+	      bool has_ts = (init->ts.u.cl
+			     && init->ts.u.cl->length_from_typespec);
+
+	      /* Remember the length of the first element for checking
+		 that all elements *in the constructor* have the same
+		 length.  This need not be the length of the LHS!  */
+	      gcc_assert (ctor->expr->expr_type == EXPR_CONSTANT);
+	      gcc_assert (ctor->expr->ts.type == BT_CHARACTER);
+	      first_len = ctor->expr->value.character.length;
+
+	      for ( ; ctor; ctor = gfc_constructor_next (ctor))
+		if (ctor->expr->expr_type == EXPR_CONSTANT)
+		{
+		  gfc_set_constant_character_len (len, ctor->expr,
+						  has_ts ? -1 : first_len);
+		  ctor->expr->ts.u.cl->length = gfc_copy_expr (ts->u.cl->length);
+		}
+	    }
+	}
+    }
+}
+
 
 /* Given an actual argument list, test to see that each argument is a
    restricted expression and optionally if the expression type is
@@ -3859,9 +4062,10 @@ gfc_has_default_initializer (gfc_symbol *der)
 {
   gfc_component *c;
 
-  gcc_assert (der->attr.flavor == FL_DERIVED);
+  gcc_assert (gfc_fl_struct (der->attr.flavor));
   for (c = der->components; c; c = c->next)
-    if (c->ts.type == BT_DERIVED)
+  {
+    if (gfc_bt_struct (c->ts.type))
       {
         if (!c->attr.pointer
 	     && gfc_has_default_initializer (c->ts.u.derived))
@@ -3874,26 +4078,124 @@ gfc_has_default_initializer (gfc_symbol *der)
         if (c->initializer)
 	  return true;
       }
+  }
 
   return false;
 }
 
 
-/* Get an expression for a default initializer.  */
+/* Only the last initializer in a union matters. */
+static gfc_expr *
+get_last_init (gfc_symbol *uniont, gfc_component **mapp)
+{
+  gfc_component *map;
+  gfc_expr *init=NULL, *init2;
+  for (map = uniont->components; map; map = map->next)
+  {
+    if (!gfc_has_default_initializer (map->ts.u.derived))
+      continue;
+
+    init2 = gfc_default_initializer (&map->ts, false);
+    if (!init2)
+      continue;
+
+    if (init)
+    {
+      gfc_warning_now ("Initializer in map at %L overwritten by initializer in "
+                       "map at %L in union", &init->where, &init2->where);
+      gfc_free_expr (init);
+    }
+
+    init = init2;
+    if (mapp) *mapp = map;
+  }
+  if (!init) *mapp = NULL;
+  return init;
+}
+
+
+/* Fetch or generate an initializer for the given component.
+   Only generate an initializer if generate is true. */
+
+static gfc_expr *
+component_init (gfc_component *c, bool generate)
+{
+  gfc_component *map = NULL;
+  gfc_expr *init = NULL;
+
+  if (c->initializer) return c->initializer;
+
+  /* Recursively handle derived type components */
+  if (generate && (c->ts.type == BT_DERIVED || c->ts.type == BT_CLASS))
+    init = gfc_default_initializer (&c->ts, true);
+
+  else if (c->ts.type == BT_UNION && c->ts.u.derived->components)
+  {
+    /* TODO: keep _all_ map initializers here, and squash them together
+       during the translation phase (in trans-expr.c:gfc_conv_structure?)
+       to allow non-overlapping initializers across maps. */
+
+    /* Try to take an existing initializer from a map. */
+    gfc_constructor *ctor;
+    init = get_last_init (c->ts.u.derived, &map);
+
+    if (!map)
+    {
+      gcc_assert (init == NULL);
+      /* If no maps had an explicit initializer, and generate is not set, then
+         this union has no initializer. Otherwise generate an initializer from
+         the first map. */
+      /* TODO: Use the largest map / initialize the entire union.
+         This can only be determined in translation (?) */
+      if (!generate)
+        return NULL;
+      map = c->ts.u.derived->components;
+      init = gfc_default_initializer (&map->ts, true);
+    }
+
+    ctor = gfc_constructor_get ();
+    ctor->expr = init;
+    ctor->n.component = map;
+
+    init = gfc_get_structure_constructor_expr (c->ts.type, c->ts.kind, &c->loc);
+    init->ts = c->ts;
+    gfc_constructor_append (&init->value.constructor, ctor);
+  }
+
+  /* Simple components */
+  else if (generate)
+  {
+    init = gfc_build_default_init_expr (&c->ts, &c->loc);
+    gfc_apply_init (&c->ts, &c->attr, init);
+  }
+
+  return init;
+}
+
+
+/* Get an expression for a default initializer of a derived type. 
+   If -finit-derived is specified, generate default initialization expressions
+   for components that lack them as with gfc_build_default_init_expr. */
 
 gfc_expr *
-gfc_default_initializer (gfc_typespec *ts)
+gfc_default_initializer (gfc_typespec *ts, bool generate)
 {
-  gfc_expr *init;
+  gfc_expr *init, *tmp;
   gfc_component *comp;
+  generate = gfc_option.flag_init_derived && generate;
 
   /* See if we have a default initializer in this, but not in nested
-     types (otherwise we could use gfc_has_default_initializer()).  */
-  for (comp = ts->u.derived->components; comp; comp = comp->next)
-    if (comp->initializer || comp->attr.allocatable
-	|| (comp->ts.type == BT_CLASS && CLASS_DATA (comp)
-	    && CLASS_DATA (comp)->attr.allocatable))
-      break;
+     types (otherwise we could use gfc_has_default_initializer()).
+     We don't need to check if we are going to generate them. */
+  comp = ts->u.derived->components;
+  if (!generate)
+  {
+    for (; comp; comp = comp->next)
+      if (comp->initializer || comp->attr.allocatable
+          || (comp->ts.type == BT_CLASS && CLASS_DATA (comp)
+              && CLASS_DATA (comp)->attr.allocatable))
+        break;
+  }
 
   if (!comp)
     return NULL;
@@ -3906,11 +4208,14 @@ gfc_default_initializer (gfc_typespec *ts)
     {
       gfc_constructor *ctor = gfc_constructor_get();
 
-      if (comp->initializer)
+      /* Fetch or generate an initializer for the component.  */
+      tmp = component_init (comp, generate);
+      if (tmp)
 	{
-	  ctor->expr = gfc_copy_expr (comp->initializer);
-	  if ((comp->ts.type != comp->initializer->ts.type
-	       || comp->ts.kind != comp->initializer->ts.kind)
+          /* If the initializer was not generated, we need a copy.  */
+          ctor->expr = comp->initializer ? gfc_copy_expr (tmp) : tmp;
+	  if ((comp->ts.type != tmp->ts.type
+	       || comp->ts.kind != tmp->ts.kind)
 	      && !comp->attr.pointer && !comp->attr.proc_pointer)
 	    gfc_convert_type_warn (ctor->expr, &comp->ts, 2, false);
 	}
diff --git a/gcc/fortran/f95-lang.c b/gcc/fortran/f95-lang.c
index 60d790b..0803b65 100644
--- a/gcc/fortran/f95-lang.c
+++ b/gcc/fortran/f95-lang.c
@@ -570,6 +570,7 @@ gfc_define_builtin (const char *name, tree type, enum built_in_function code,
     DO_DEFINE_MATH_BUILTIN (code, name, argtype, mfunc_) \
     DO_DEFINE_MATH_BUILTIN (C##code, "c" name, argtype, mfunc_c)
 
+#define MATH_ALIAS_BUILTIN(newid, id, name, type)
 
 /* Create function types for builtin functions.  */
 
@@ -1046,6 +1047,7 @@ gfc_init_builtin_functions (void)
   targetm.init_builtins ();
 }
 
+#undef MATH_ALIAS_BUILTIN
 #undef DEFINE_MATH_BUILTIN_C
 #undef DEFINE_MATH_BUILTIN
 
diff --git a/gcc/fortran/frontend-passes.c b/gcc/fortran/frontend-passes.c
index 2772932..369d245 100644
--- a/gcc/fortran/frontend-passes.c
+++ b/gcc/fortran/frontend-passes.c
@@ -1848,6 +1848,8 @@ gfc_code_walker (gfc_code **c, walk_code_fn_t codefn, walk_expr_fn_t exprfn,
 	      WALK_SUBEXPR (co->ext.open->asynchronous);
 	      WALK_SUBEXPR (co->ext.open->id);
 	      WALK_SUBEXPR (co->ext.open->newunit);
+	      WALK_SUBEXPR (co->ext.open->share);
+	      WALK_SUBEXPR (co->ext.open->cc);
 	      break;
 
 	    case EXEC_CLOSE:
diff --git a/gcc/fortran/gfortran.h b/gcc/fortran/gfortran.h
index bd1aeb9..698598c 100644
--- a/gcc/fortran/gfortran.h
+++ b/gcc/fortran/gfortran.h
@@ -49,7 +49,18 @@ along with GCC; see the file COPYING3.  If not see
 #define MAX_SUBRECORD_LENGTH 2147483639   /* 2**31-9 */
 
 
-#define gfc_is_whitespace(c) ((c==' ') || (c=='\t'))
+#define gfc_is_whitespace(c) ((c==' ') || (c=='\t') \
+                              || (gfc_option.flag_feed && c=='\f'))
+
+/* Common macros to check structure-like types and flavors, since things like
+   STRUCTURES, MAPs and UNIONs are often treated similarly. */
+
+#define gfc_bt_struct(t) \
+  ((t) == BT_DERIVED || (t) == BT_UNION)
+#define gfc_fl_struct(f) \
+  ((f) == FL_DERIVED || (f) == FL_UNION || (f) == FL_STRUCT)
+#define case_struct_bt case BT_DERIVED: case BT_UNION
+#define case_struct_fl case FL_DERIVED: case FL_UNION: case FL_STRUCT
 
 /* Stringization.  */
 #define stringize(x) expand_macro(x)
@@ -202,6 +213,7 @@ typedef enum
   ST_END_FILE, ST_FINAL, ST_FLUSH, ST_END_FORALL, ST_END_FUNCTION, ST_ENDIF,
   ST_END_INTERFACE, ST_END_MODULE, ST_END_PROGRAM, ST_END_SELECT,
   ST_END_SUBROUTINE, ST_END_WHERE, ST_END_TYPE, ST_ENTRY, ST_EQUIVALENCE,
+  ST_END_STRUCTURE,
   ST_ERROR_STOP, ST_EXIT, ST_FORALL, ST_FORALL_BLOCK, ST_FORMAT, ST_FUNCTION,
   ST_GOTO, ST_IF_BLOCK, ST_IMPLICIT, ST_IMPLICIT_NONE, ST_IMPORT,
   ST_INQUIRE, ST_INTERFACE, ST_SYNC_ALL, ST_SYNC_MEMORY, ST_SYNC_IMAGES,
@@ -210,6 +222,7 @@ typedef enum
   ST_STOP, ST_SUBROUTINE, ST_TYPE, ST_USE, ST_WHERE_BLOCK, ST_WHERE, ST_WAIT,
   ST_WRITE, ST_ASSIGNMENT, ST_POINTER_ASSIGNMENT, ST_SELECT_CASE, ST_SEQUENCE,
   ST_SIMPLE_IF, ST_STATEMENT_FUNCTION, ST_DERIVED_DECL, ST_LABEL_ASSIGNMENT,
+  ST_STRUCTURE_DECL, ST_UNION, ST_END_UNION, ST_MAP, ST_END_MAP,
   ST_ENUM, ST_ENUMERATOR, ST_END_ENUM, ST_SELECT_TYPE, ST_TYPE_IS, ST_CLASS_IS,
   ST_OMP_ATOMIC, ST_OMP_BARRIER, ST_OMP_CRITICAL, ST_OMP_END_ATOMIC,
   ST_OMP_END_CRITICAL, ST_OMP_END_DO, ST_OMP_END_MASTER, ST_OMP_END_ORDERED,
@@ -234,12 +247,12 @@ typedef enum
 interface_type;
 
 /* Symbol flavors: these are all mutually exclusive.
-   10 elements = 4 bits.  */
+   12 elements = 4 bits.  */
 typedef enum sym_flavor
 {
   FL_UNKNOWN = 0, FL_PROGRAM, FL_BLOCK_DATA, FL_MODULE, FL_VARIABLE,
   FL_PARAMETER, FL_LABEL, FL_PROCEDURE, FL_DERIVED, FL_NAMELIST,
-  FL_VOID
+  FL_UNION, FL_STRUCT, FL_VOID
 }
 sym_flavor;
 
@@ -339,6 +352,7 @@ enum gfc_isym_id
   GFC_ISYM_CONVERSION,
   GFC_ISYM_COS,
   GFC_ISYM_COSH,
+  GFC_ISYM_COTAN,
   GFC_ISYM_COUNT,
   GFC_ISYM_CPU_TIME,
   GFC_ISYM_CSHIFT,
@@ -587,6 +601,13 @@ init_local_integer;
 
 typedef enum
 {
+    GFC_INIT_DERIVED_OFF = 0,
+    GFC_INIT_DERIVED_ON
+}
+init_derived;
+
+typedef enum
+{
   GFC_FCOARRAY_NONE = 0,
   GFC_FCOARRAY_SINGLE,
   GFC_FCOARRAY_LIB
@@ -702,7 +723,7 @@ typedef struct
     optional:1, pointer:1, target:1, value:1, volatile_:1, temporary:1,
     dummy:1, result:1, assign:1, threadprivate:1, not_always_present:1,
     implied_index:1, subref_array_pointer:1, proc_pointer:1, asynchronous:1,
-    contiguous:1;
+    contiguous:1, automatic:1;
 
   /* For CLASS containers, the pointer attribute is sometimes set internally
      even though it was not directly specified.  In this case, keep the
@@ -922,7 +943,7 @@ typedef struct
 
   union
   {
-    struct gfc_symbol *derived;	/* For derived types only.  */
+    struct gfc_symbol *derived;	/* For derived types or unions.  */
     gfc_charlen *cl;		/* For character types only.  */
     int pad;			/* For hollerith types only.  */
   }
@@ -976,6 +997,9 @@ typedef struct gfc_component
 
   /* Needed for procedure pointer components.  */
   struct gfc_typebound_proc *tb;
+
+  /* Pointer to MAP list for union types. */
+  struct gfc_symbol *maps;
 }
 gfc_component;
 
@@ -1991,7 +2015,9 @@ typedef struct
 {
   gfc_expr *unit, *file, *status, *access, *form, *recl,
     *blank, *position, *action, *delim, *pad, *iostat, *iomsg, *convert,
-    *decimal, *encoding, *round, *sign, *asynchronous, *id, *newunit;
+    *decimal, *encoding, *round, *sign, *asynchronous, *id, *newunit, *share,
+    *cc;
+  int readonly : 1;
   gfc_st_label *err;
 }
 gfc_open;
@@ -2290,6 +2316,7 @@ typedef struct
   int flag_module_private;
   int flag_recursive;
   int flag_init_local_zero;
+  int flag_init_derived;
   int flag_init_integer;
   int flag_init_integer_value;
   int flag_init_real;
@@ -2302,6 +2329,17 @@ typedef struct
   int flag_realloc_lhs;
   int flag_aggressive_function_elimination;
   int flag_frontend_optimize;
+  int flag_dec_extended_int;
+  int flag_dec_structure;
+  int flag_dec_member_dot;
+  int flag_dec_math;
+  int flag_dec_logical_xor;
+  int flag_dec_bitwise_ops;
+  int flag_dec_io;
+  int flag_dec_intrinsic_ints;
+  int flag_dec_static;
+  int flag_loc_rval;
+  int flag_feed;
 
   int fpe;
   int rtcheck;
@@ -2523,6 +2561,7 @@ gfc_try gfc_check_any_c_kind (gfc_typespec *);
 int gfc_validate_kind (bt, int, bool);
 int gfc_get_int_kind_from_width_isofortranenv (int size);
 int gfc_get_real_kind_from_width_isofortranenv (int size);
+tree gfc_get_union_type (gfc_symbol *);
 tree gfc_get_derived_type (gfc_symbol * derived);
 extern int gfc_index_integer_kind;
 extern int gfc_default_integer_kind;
@@ -2568,6 +2607,7 @@ gfc_try gfc_add_cray_pointee (symbol_attribute *, locus *);
 match gfc_mod_pointee_as (gfc_array_spec *);
 gfc_try gfc_add_protected (symbol_attribute *, const char *, locus *);
 gfc_try gfc_add_result (symbol_attribute *, const char *, locus *);
+gfc_try gfc_add_automatic (symbol_attribute *, const char *, locus *);
 gfc_try gfc_add_save (symbol_attribute *, save_state, const char *, locus *);
 gfc_try gfc_add_threadprivate (symbol_attribute *, const char *, locus *);
 gfc_try gfc_add_saved_common (symbol_attribute *, locus *);
@@ -2610,7 +2650,8 @@ gfc_try gfc_copy_attr (symbol_attribute *, symbol_attribute *, locus *);
 gfc_try gfc_add_component (gfc_symbol *, const char *, gfc_component **);
 gfc_symbol *gfc_use_derived (gfc_symbol *);
 gfc_symtree *gfc_use_derived_tree (gfc_symtree *);
-gfc_component *gfc_find_component (gfc_symbol *, const char *, bool, bool);
+gfc_component *gfc_find_component (gfc_symbol *, const char *, bool, bool,
+                                   gfc_ref **);
 
 gfc_st_label *gfc_get_st_label (int);
 void gfc_free_st_label (gfc_st_label *);
@@ -2785,7 +2826,9 @@ gfc_try gfc_check_pointer_assign (gfc_expr *, gfc_expr *);
 gfc_try gfc_check_assign_symbol (gfc_symbol *, gfc_component *, gfc_expr *);
 
 bool gfc_has_default_initializer (gfc_symbol *);
-gfc_expr *gfc_default_initializer (gfc_typespec *);
+gfc_expr *gfc_default_initializer (gfc_typespec *, bool);
+gfc_expr *gfc_build_default_init_expr (gfc_typespec *, locus *);
+void gfc_apply_init (gfc_typespec *, symbol_attribute *, gfc_expr *);
 gfc_expr *gfc_get_variable_expr (gfc_symtree *);
 void gfc_add_full_array_ref (gfc_expr *, gfc_array_spec *);
 gfc_expr * gfc_lval_expr_from_sym (gfc_symbol *);
@@ -2879,6 +2922,7 @@ gfc_try gfc_ref_dimen_size (gfc_array_ref *, int dimen, mpz_t *, mpz_t *);
 
 /* interface.c -- FIXME: some of these should be in symbol.c */
 void gfc_free_interface (gfc_interface *);
+int gfc_compare_union_types (gfc_symbol *, gfc_symbol *);
 int gfc_compare_derived_types (gfc_symbol *, gfc_symbol *);
 int gfc_compare_types (gfc_typespec *, gfc_typespec *);
 int gfc_compare_interfaces (gfc_symbol*, gfc_symbol*, const char *, int, int,
@@ -2924,6 +2968,8 @@ void gfc_module_done_2 (void);
 void gfc_dump_module (const char *, int);
 bool gfc_check_symbol_access (gfc_symbol *);
 void gfc_free_use_stmts (gfc_use_list *);
+const char *gfc_dt_lower_string (const char *);
+const char *gfc_dt_upper_string (const char *);
 
 /* primary.c */
 symbol_attribute gfc_variable_attr (gfc_expr *, gfc_typespec *);
diff --git a/gcc/fortran/gfortran.texi b/gcc/fortran/gfortran.texi
index 4f9008d..613b5af 100644
--- a/gcc/fortran/gfortran.texi
+++ b/gcc/fortran/gfortran.texi
@@ -473,9 +473,9 @@ The GNU Fortran compiler is able to compile nearly all
 standard-compliant Fortran 95, Fortran 90, and Fortran 77 programs,
 including a number of standard and non-standard extensions, and can be
 used on real-world programs.  In particular, the supported extensions
-include OpenMP, Cray-style pointers, and several Fortran 2003 and Fortran
-2008 features, including TR 15581.  However, it is still under
-development and has a few remaining rough edges.
+include OpenMP, Cray-style pointers, several Fortran 2003 and Fortran
+2008 features, including TR 15581, and some of the Intel/DEC extensions.
+However, it is still under development and has a few remaining rough edges.
 
 At present, the GNU Fortran compiler passes the
 @uref{http://www.fortran-2000.com/ArnaudRecipes/fcvs21_f95.html, 
@@ -1338,7 +1338,8 @@ purely for backward compatibility with legacy compilers.  By default,
 extensions, but to warn about the use of the latter.  Specifying
 either @option{-std=f95}, @option{-std=f2003} or @option{-std=f2008}
 disables both types of extensions, and @option{-std=legacy} allows both
-without warning.
+without warning. Those extensions which are enabled by specific compile
+flags do not produce warnings.
 
 @menu
 * Old-style kind specifications::
@@ -1358,6 +1359,7 @@ without warning.
 * CONVERT specifier::
 * OpenMP::
 * Argument list functions::
+* Optional DEC extension support::
 @end menu
 
 @node Old-style kind specifications
@@ -1554,7 +1556,7 @@ type, then the real-literal-constant will be interpreted as a
 
 @node BOZ literal constants
 @subsection BOZ literal constants
-@cindex BOZ literal constants
+@cindex literal constants, BOZ
 
 Besides decimal constants, Fortran also supports binary (@code{b}),
 octal (@code{o}) and hexadecimal (@code{z}) integer constants.  The
@@ -1646,6 +1648,37 @@ However, there is no implicit conversion of @code{INTEGER} values in
 @code{if}-statements, nor of @code{LOGICAL} or @code{INTEGER} values
 in I/O operations.
 
+As a further extension, when the flag @option{-fdec-bitwise-ops} is asserted
+any logical operators with at least one @code{INTEGER} operand implicitly
+use the corresponding bitwise intrinsic function instead of the logical
+operation. The result is an integer type with the same kind of the largest
+integer operand. A complete list of the conversions that take place is given
+here:
+
+@smallexample
+  .NOT.  X -> NOT(X)
+X .AND.  Y -> IAND(X,Y)
+X .OR.   Y -> IOR(X,Y)
+X .XOR.  Y -> IEOR(X,Y)*
+X .NEQV. Y -> IEOR(X,Y)
+X .EQV.  Y -> NOT(IEOR(X,Y))
+@end smallexample
+@emph{See @ref{.XOR. operator}}
+
+For example, with @option{-fdec-bitwise-ops}, the following two examples are
+equivalent:
+
+@smallexample
+      INTEGER :: i, j
+      LOGICAL :: l
+      j = i .AND. l
+@end smallexample
+@smallexample
+      INTEGER :: i, j
+      LOGICAL :: l
+      j = IAND(i, l)
+@end smallexample
+
 @node Hollerith constants support
 @subsection Hollerith constants support
 @cindex Hollerith constants
@@ -1959,55 +1992,55 @@ C
       end
 @end smallexample
 
+Use of @code{%LOC()} as an rvalue is supported with the flag
+@option{-floc-rval} (its behavior is identical to the @code{LOC()} intrinsic).
+
 For details refer to the g77 manual
 @uref{http://gcc.gnu.org/@/onlinedocs/@/gcc-3.4.6/@/g77/@/index.html#Top}.
 
 Also, @code{c_by_val.f} and its partner @code{c_by_val.c} of the
 GNU Fortran testsuite are worth a look.
 
+@node Optional DEC extension support
+@subsection Optional DEC extension support
+@cindex extensions, dec
 
-@node Extensions not implemented in GNU Fortran
-@section Extensions not implemented in GNU Fortran
-@cindex extensions, not implemented
+Long long ago in a land far far away, in the time before Fortran standards
+existed, compiler writers loved to add extensions to Fortran for anyone who
+asked them nicely. The most popular of these extensions were implemented by
+Digital Equipment Corporation (DEC). Since they were so popular they were
+maintained in the Digital (and since Intel) compiler long after standards were
+introduced. Unfortunately these extensions remain in use by a number of users.
 
-The long history of the Fortran language, its wide use and broad
-userbase, the large number of different compiler vendors and the lack of
-some features crucial to users in the first standards have lead to the
-existence of a number of important extensions to the language.  While
-some of the most useful or popular extensions are supported by the GNU
-Fortran compiler, not all existing extensions are supported.  This section
-aims at listing these extensions and offering advice on how best make
-code that uses them running with the GNU Fortran compiler.
-
-@c More can be found here:
-@c   -- http://gcc.gnu.org/onlinedocs/gcc-3.4.6/g77/Missing-Features.html
-@c   -- the list of Fortran and libgfortran bugs closed as WONTFIX:
-@c      http://tinyurl.com/2u4h5y
+GNU Fortran provides selective automatic support for some of these
+extensions, described in the previous section @ref{Extensions implemented in
+GNU Fortran}. Other DEC extensions are so heinous that GNU Fortran requires the
+user to explicitly enable them; these are the "optional" DEC extensions,
+described here. Most of the time they are enabled with a compile flag prefaced
+by @option{-fdec-}.
 
 @menu
 * STRUCTURE and RECORD::
-@c * UNION and MAP::
-* ENCODE and DECODE statements::
-* Variable FORMAT expressions::
-@c * Q edit descriptor::
-@c * AUTOMATIC statement::
-@c * TYPE and ACCEPT I/O Statements::
-@c * .XOR. operator::
-@c * CARRIAGECONTROL, DEFAULTFILE, DISPOSE and RECORDTYPE I/O specifiers::
-@c * Omitted arguments in procedure call::
-* Alternate complex function syntax::
+* UNION and MAP::
+* .XOR. operator::
+* Base#value literal constants::
+* I/O specifiers::
+* Type prefixes to integer intrinsic functions::
+* Extended math intrinsics::
+* AUTOMATIC and STATIC attributes::
+* Form feed as whitespace::
 @end menu
 
-
 @node STRUCTURE and RECORD
-@subsection @code{STRUCTURE} and @code{RECORD}
+@subsubsection @code{STRUCTURE} and @code{RECORD}
 @cindex @code{STRUCTURE}
 @cindex @code{RECORD}
 
-Record structures are a pre-Fortran-90 vendor extension to create
-user-defined aggregate data types.  GNU Fortran does not support
-record structures, only Fortran 90's ``derived types'', which have
-a different syntax.
+Record structures are a pre-Fortran-90 DEC extension to create
+user-defined aggregate data types. Support for record structures in GNU
+Fortran can be enabled with the @option{-fdec-structure} compile option.
+If you have a choice, you should instead use Fortran 90's ``derived types'',
+which have a different syntax. 
 
 In many cases, record structures can easily be converted to derived types.
 To convert, replace @code{STRUCTURE /}@var{structure-name}@code{/}
@@ -2016,6 +2049,10 @@ by @code{TYPE} @var{type-name}.  Additionally, replace
 @code{TYPE(}@var{type-name}@code{)}. Finally, in the component access,
 replace the period (@code{.}) by the percent sign (@code{%}).
 
+Note that component access by period can be enabled for derived types
+separately from structure/record support with @option{-fdec-member-dot};
+however, it is enabled automatically with @option{-fdec-structure}.
+
 Here is an example of code using the non portable record structure syntax:
 
 @example
@@ -2073,15 +2110,484 @@ store_catalog(12) = pear
 print *, store_catalog(12)
 @end example
 
+@noindent
+Structures and derived types differ in a few ways:
+
+@itemize @bullet
+@item Structures act like derived types with the @code{SEQUENCE} attribute.
+Otherwise they may contain no specifiers.
+
+@item Structures may contain a variable with the name @code{%FILL}; this will
+create an anonymous component which cannot be referenced but fills space just
+like a component for alignment purposes. For example, the following structure
+will take up sixteen bytes:
+
+@smallexample 
+structure /useless/
+  integer(4) i
+  integer(8) %FILL
+end structure
+@end smallexample
+
+@item Structures may share names with other symbols. For example, the following
+is invalid for derived types, but valid for structures:
+
+@smallexample
+structure /Header/
+  ! ...
+end structure
+record /Header/ header
+@end smallexample
+
+@item Structures may be defined 'ad-hoc' within another parent structure. The
+type names for these structures may be ommitted, in which case the structure
+type itself is anonymous, and other structures of the same type cannot be
+instantiated. The following shows some examples:
+
+@example
+type appointment
+  ! 'ad-hoc' structure definition; app_time is an array of two 'time'
+  structure /time/ app_time (2) 
+    integer(1) hour, minute
+  end structure
+  character(10) memo
+end type appointment
+
+! The 'time' structure is still usable
+record /time/ now
+now = time(5, 30)
+
+...
+
+type appointment
+  ! anonymous ad-hoc structure definition
+  structure start, end
+    integer(1) hour, minute
+  end structure
+  character(10) memo
+end type appointment
+@end example
+
+@item Structures may contain @code{UNION} declarations. For more detail see the
+section on @ref{UNION and MAP}.
+
+@item Structures support old-style initialization of components, identical to
+those described in @ref{Old-style variable initialization}.
+@end itemize
+
+@node UNION and MAP
+@subsubsection @code{UNION} and @code{MAP}
+@cindex @code{UNION}
+@cindex @code{MAP}
+
+Unions are a DEC extension which were commonly used with the non-standard
+@ref{STRUCTURE and RECORD} extensions. Use of @code{UNION} and @code{MAP} is
+automatically enabled with @option{-fdec-structure}.
+
+A @code{UNION} declaration occurs within a structure; within the definition of
+each union is a number of @code{MAP} definitions. Each @code{MAP} shares
+storage with its sibling maps (in the same union), and the size of the union
+is the size of the largest map within it, just as with unions in C. The major
+difference is that component references do not indicate which union or map the
+component is in (the compiler gets to figure that out).
+
+Here is a small example:
+@smallexample
+structure /words_long/
+union
+  map
+    integer(2) w0, w1, w2
+  end map
+  map
+    integer(4) long
+  end map
+end union
+end structure
+@end smallexample
+
+The two maps share memory, and the size of the union is ultimately six bytes:
+
+@example
+0    1    2    3    4   5   6     Byte offset
+-------------------------------
+|    |    |    |    |    |    |
+-------------------------------
+
+^    W0   ^    W1   ^    W2   ^
+ \-------/ \-------/ \-------/
+
+^       LONG        ^  unused ^
+ \-----------------/ \-------/
+@end example
+
+Following is an example mirroring the layout of an Intel x86_64 register:
+
+@example
+structure /reg/
+  union    ! rax
+    map
+      integer*8 rx         ! rax
+    end map
+    map
+      integer*4 rh         ! rah
+      union   ! eax
+        map
+          integer*4 rl     ! ral
+        end map
+        map
+          integer*4 ex     ! eax
+        end map
+        map
+          integer*2 eh     ! eah
+          union     ! ax
+            map
+              integer*2 el ! eal
+            end map
+            map
+              integer*2 x  ! ax
+            end map
+            map
+              integer*1 h  ! ah
+              integer*1 l  ! al
+            end map
+          end union ! ax
+        end map
+      end union ! eax
+    end map
+  end union ! rax
+end structure
+
+record /reg/ a
+
+! After this assignment...
+a.rx = z'AABBCCCCFFFFFFFF'
+
+! The following is true:
+!
+! a.rx == z'AABBCCCCFFFFFFFF'
+! a.rh ==         z'FFFFFFFF'
+! a.rl == z'AABBCCCC'
+!
+! a.ex == z'AABBCCCC'
+! a.eh ==     z'CCCC'
+! a.el == z'AABB'
+!
+!  a.x == z'AABB'
+!  a.h ==   z'BB'
+!  a.l == z'AA'
+@end example
+
+@node .XOR. operator
+@subsubsection @code{.XOR.} operator
+@cindex operator, @code{XOR}
+
+With @option{-fdec-logical-xor}, @code{.XOR.} is supported as a logical
+operator. It is entirely equivalent to the standard operator @code{.NEQV.}:
+
+@smallexample
+logical :: a = .true., b = .false., c
+c = a .xor. b ! same as a .neqv. b
+@end smallexample
+
+@node Base#value literal constants
+@subsubsection Base#value literal constants
+
+With the flag @option{-fdec-extended-int} GNU Fortran supports the use of the
+DEC @code{base#value} integer constants. The base may lie anywhere between 2
+and 36. If no base is present (as in @code{#value}) the default base is 16
+(hexadecimal). The letters of the alphabet A-Z represent digits starting at ten
+for bases higher than base ten. In the following example, each assignment
+results in the value 63:
+
+@smallexample
+I = #3D + 2
+J = 16#3f
+K = 2#1000000 - 6#1
+L = -4#3 + 5#231
+M = '3f'x
+N = 36#1R
+@end smallexample
+
+Extended integer literals of this form are also supported in standard variable
+kind specifications (not old-style):
+
+@smallexample
+integer(kind=2#100) I ! valid: 100 base 2 => 4
+integer(5#13)       J ! valid: 13  base 5 => 8
+integer*3#11        K ! UNSUPPORTED
+@end smallexample
+
+@node I/O specifiers
+@subsubsection I/O specifiers
+@cindex I/O
+@cindex @code{CARRIAGECONTROL}
+@cindex @code{READONLY}
+@cindex @code{SHARED}
+
+With @option{-fdec-io} GNU Fortran supports additional DEC extended I/O
+features. Currently implemented are three additional categories of specifiers
+for the @code{OPEN} statement:
+
+@itemize @bullet
+
+@item @code{READONLY}
+
+Specifying @code{READONLY} in an @code{OPEN} statement is equivalent to
+specifying @code{ACTION='READ'}, except that the file is protected from
+deletion on close. A runtime error will be thrown if a unit opened
+@code{READONLY} is closed with @code{STATUS='DELETE'}. @code{READONLY} may not
+be present with the @code{ACTION=} specifier. Example:
+
+@example
+open (unit=fd, file=fname, readonly)
+ ...
+close (unit=fd, status='delete') ! will cause runtime error
+@end example
+
+@item @code{SHARED}, @code{NOSHARED}, @code{SHARE=DENYNONE|DENYRW}
+
+When this specifier is given, runtime file locking occurs based on the option
+given. The locking is performed by @code{fcntl}; see your system's
+documentation for details on the locking performed.
+
+@itemize
+@item @code{DENYNONE} Lock the file with a shared (read) lock (i.e. F_RDLCK) on
+open.
+@item @code{DENYRW} Lock the file with an exclusive (write) lock (i.e. F_WRLCK)
+on open.
+@end itemize
+
+@code{SHARED} is equivalent to @code{SHARE=DENYNONE}, and
+@code{NOSHARED} is equivalent to @code{SHARE=DENYRW}. Examples:
+
+@example
+open (..., action='*')                       ! open with no locking
+
+open (..., action='read',  share='denynone') ! open with shared/read lock
+open (..., action='read',  shared)           ! equivalent to the above
+
+open (..., action='write', share='denyrw')   ! open with exclusive/write lock
+open (..., action='write', noshared)         ! equivalent to the above
+@end example
+
+@item @code{CARRIAGECONTROL=NONE|LIST|FORTRAN}
+
+The @code{CARRIAGECONTROL} specifier dictates how reading and writing between
+records is performed for the given unit at runtime.
+
+@itemize
+@item @code{NONE} - default for unformatted or binary I/O.
+
+When writing, no line feed is written following each record. When reading
+there are no records; the entire read buffer is filled with each read.
+
+@item @code{LIST} - default for regular formatted I/O.
+
+When writing, a space is written before each record and a line feed (or CR-LF)
+is written following each record. This is because of the historical special
+interpretation of the character in the first column of a line.
+
+@item @code{FORTRAN}
+
+When writing, no space is inserted before each record, but a line feed (or
+CR-LF) is still written following each record. This is to allow output into
+the first column of a line for special interpretation. Reading is identical to
+@code{CARRIAGECONTROL=LIST}.
+
+@end itemize
+
+Examples:
+
+@example
+open (unit=3, ..., carriagecontrol='list')
+write (3, *) "hi"
+write (3, *) "there"
+...
+! Output is " hi\n there\n":
+ hi
+ there
+@end example
+@example
+open (unit=3, ..., carriagecontrol='fortran')
+write (3, *) "hi"
+write (3, *) "there"
+...
+! Output is "hi\nthere\n":
+hi
+there
+@end example
+@example
+open (unit=3, ..., carriagecontrol='none')
+write (3, *) "hi"
+write (3, *) "there"
+...
+! Output is " hi there":
+ hi there
+@end example
+@end itemize
+
+@node Type prefixes to integer intrinsic functions
+@subsubsection Type prefixes to integer intrinsic functions
+@cindex intrinsics, integer
+
+Similar to the D/C prefixes to real functions to specify the input/output
+types, DEC offered B/I/J/K prefixes to integer functions to control their
+types. The types implied by each are:
+
+@example
+@code{B} - @code{INTEGER(kind=1)}
+@code{I} - @code{INTEGER(kind=2)}
+@code{J} - @code{INTEGER(kind=4)}
+@code{K} - @code{INTEGER(kind=8)}
+@end example
+
+GNU Fortran supports these with the flag @option{-fdec-intrinsic-ints}.
+Intrinsics for which prefixed versions are available and in what form are noted
+in @ref{Intrinsic Procedures}. The complete list of currently supported
+intrinsics is here:
+
+@multitable .2 .2 .2 .2 .2
+
+@headitem Intrinsic @tab B @tab I @tab J @tab K
+
+@item @code{ABS}
+  @tab @code{BABS} @tab @code{IIABS} @tab @code{JIABS} @tab @code{KIABS}
+@item @code{BTEST}
+  @tab @code{BBTEST} @tab @code{BITEST} @tab @code{BJTEST} @tab @code{BKTEST}
+@item @code{IAND}
+  @tab @code{BIAND} @tab @code{IIAND} @tab @code{JIAND} @tab @code{KIAND}
+@item @code{IBCLR}
+  @tab @code{BBCLR} @tab @code{IIBCLR} @tab @code{JIBCLR} @tab @code{KIBCLR}
+@item @code{IBITS}
+  @tab @code{BBITS} @tab @code{IIBITS} @tab @code{JIBITS} @tab @code{KIBITS}
+@item @code{IBSET}
+  @tab @code{BBSET} @tab @code{IIBSET} @tab @code{JIBSET} @tab @code{KIBSET}
+@item @code{IEOR}
+  @tab @code{BIEOR} @tab @code{IIEOR} @tab @code{JIEOR} @tab @code{KIEOR}
+@item @code{IOR}
+  @tab @code{BIOR} @tab @code{IIOR} @tab @code{JIOR} @tab @code{KIOR}
+@item @code{ISHFT}
+  @tab @code{BSHFT} @tab @code{IISHFT} @tab @code{JISHFT} @tab @code{KISHFT}
+@item @code{ISHFTC}
+  @tab @code{BSHFTC} @tab @code{IISHFTC} @tab @code{JISHFTC} @tab @code{KISHFTC}
+@item @code{MOD}
+  @tab @code{BMOD} @tab @code{IMOD} @tab @code{JMOD} @tab @code{KMOD}
+@item @code{NOT}
+  @tab @code{BNOT} @tab @code{INOT} @tab @code{JNOT} @tab @code{KNOT}
+@item @code{FLOAT}
+  @tab @code{--} @tab @code{FLOATI} @tab @code{FLOATJ} @tab @code{FLOATK}
+@end multitable
+
+@node Extended math intrinsics
+@subsubsection Extended math intrinsics
+@cindex intrinsics, math
+@cindex intrinsics, trigonometric function
+@cindex trigonometric function, degrees
+
+GNU Fortran supports an extended list of mathematical intrinsics with
+@option{-fdec-math}. These intrinsics are listed completely in @ref{Intrinsic
+Procedures} and it is noted that they are optional DEC extensions. 
+
+This flag enables the @ref{COTAN} intrinsic.
+
+This flag also adds trigonometric intrinsics which accept or produce degrees
+instead of radians. The new intrinsics enabled by this option are listed here
+with the corresponding standard radian versions:
+
+@multitable .5 .5
+@headitem Radians @tab Degrees
+@item @ref{ACOS}  @tab @ref{ACOSD}
+@item @ref{ASIN}  @tab @ref{ASIND}
+@item @ref{ATAN}  @tab @ref{ATAND}
+@item @ref{ATAN2} @tab @ref{ATAN2D}
+@item @ref{COS}   @tab @ref{COSD}
+@item @ref{COTAN} @tab @ref{COTAND}
+@item @ref{SIN}   @tab @ref{SIND}
+@item @ref{TAN}   @tab @ref{TAND}
+@end multitable
+
+@node AUTOMATIC and STATIC attributes
+
+@subsubsection @code{AUTOMATIC} and @code{STATIC} attributes
+@cindex variable attributes
+@cindex @code{AUTOMATIC}
+@cindex @code{STATIC}
+
+With @option{-fdec-static} GNU Fortran supports the explicit specification of
+two additional variable attributes: @code{STATIC} and @code{AUTOMATIC}. These
+follow the syntax of the @code{SAVE} attribute.
+
+@code{STATIC} is exactly equivalent to @code{SAVE}.
+
+@code{AUTOMATIC} is the default for local variables smaller than
+@option{-fmax-stack-var-size}, unless @option{-fno-automatic} is given.
+Variables marked @code{AUTOMATIC} will be stack automatic variables whenever
+possible. This attribute overrides @option{-fno-automatic},
+@option{-fmax-stack-var-size}, and blanket @code{SAVE} statements.
+
+Examples:
+
+@example
+subroutine f
+  integer, automatic :: i  ! automatic variable
+  integer x, y             ! static variables
+  save
+  ...
+endsubroutine
+@end example
+@example
+subroutine f
+  integer a, b, c, x, y, z
+  static :: x
+  save y
+  automatic z, c
+  ! a, b, c, and z are automatic
+  ! x and y are static
+endsubroutine
+@end example
+@example
+! Compiled with -fno-automatic
+subroutine f
+  integer a, b, c, d
+  automatic :: a
+  ! a is automatic; b, c, and d are static
+ensubroutine
+@end example
+
+@node Form feed as whitespace
+@subsubsection Form feed as whitespace
+@cindex form feed
+
+Stuff.
+
 
-@c @node UNION and MAP
-@c @subsection @code{UNION} and @code{MAP}
-@c @cindex @code{UNION}
-@c @cindex @code{MAP}
-@c
-@c For help writing this one, see
-@c http://www.eng.umd.edu/~nsw/ench250/fortran1.htm#UNION and
-@c http://www.tacc.utexas.edu/services/userguides/pgi/pgiws_ug/pgi32u06.htm
+@node Extensions not implemented in GNU Fortran
+@section Extensions not implemented in GNU Fortran
+@cindex extensions, not implemented
+
+The long history of the Fortran language, its wide use and broad
+userbase, the large number of different compiler vendors and the lack of
+some features crucial to users in the first standards have lead to the
+existence of a number of important extensions to the language.  While
+some of the most useful or popular extensions are supported by the GNU
+Fortran compiler, not all existing extensions are supported.  This section
+aims at listing these extensions and offering advice on how best make
+code that uses them running with the GNU Fortran compiler.
+
+@c More can be found here:
+@c   -- http://gcc.gnu.org/onlinedocs/gcc-3.4.6/g77/Missing-Features.html
+@c   -- the list of Fortran and libgfortran bugs closed as WONTFIX:
+@c      http://tinyurl.com/2u4h5y
+
+@menu
+* ENCODE and DECODE statements::
+* Variable FORMAT expressions::
+@c * Q edit descriptor::
+@c * TYPE and ACCEPT I/O Statements::
+@c * DEFAULTFILE, DISPOSE and RECORDTYPE I/O specifiers::
+@c * Omitted arguments in procedure call::
+* Alternate complex function syntax::
+@end menu
 
 
 @node ENCODE and DECODE statements
diff --git a/gcc/fortran/interface.c b/gcc/fortran/interface.c
index 725cd8a..7a1193e 100644
--- a/gcc/fortran/interface.c
+++ b/gcc/fortran/interface.c
@@ -383,19 +383,125 @@ gfc_match_end_interface (void)
 }
 
 
+static int
+compare_components (gfc_component *cmp1, gfc_component *cmp2)
+{
+  if (cmp1 == cmp2)
+    return 1;
+
+  if (gfc_compare_types (&cmp1->ts, &cmp2->ts) == 0)
+    return 0;
+
+  /* UNIONs, MAPs, and anonymous STRUCTURE components all have internal
+     names of the form uU*, mM*, sS*, etc... Ignore differences here;
+     we must do a deeper comparison. */
+  if (strcmp (cmp1->name, cmp2->name) != 0
+      && !(   cmp1->name[1] == (char) TOUPPER (cmp1->name[0])
+           && cmp2->name[1] == (char) TOUPPER (cmp2->name[0])
+           && cmp1->name[0] == cmp2->name[0]))
+    return 0;
+
+  if (cmp1->attr.access != cmp2->attr.access)
+    return 0;
+
+  if (cmp1->attr.pointer != cmp2->attr.pointer)
+    return 0;
+
+  if (cmp1->attr.dimension != cmp2->attr.dimension)
+    return 0;
+
+  if (cmp1->attr.allocatable != cmp2->attr.allocatable)
+    return 0;
+
+  if (cmp1->attr.dimension && gfc_compare_array_spec (cmp1->as, cmp2->as) == 0)
+    return 0;
+
+  return 1;
+}
+
+
+/* Compare two union types by comparing the components of their maps.
+   Because unions and maps are anonymous their types get special internal
+   names; therefore the usual derived type comparison will fail on them.
+
+   Returns nonzero if equal, as with gfc_compare_derived_types. Also as with
+   gfc_compare_derived_types, 'equal' is closer to meaning 'duplicate
+   definitions' than 'equivalent structure'. */
+
+int
+gfc_compare_union_types (gfc_symbol *un1, gfc_symbol *un2)
+{
+  gfc_component *map1, *map2, *cmp1, *cmp2;
+
+  if (un1->attr.flavor != FL_UNION || un2->attr.flavor != FL_UNION)
+    return 0;
+
+  map1 = un1->components;
+  map2 = un2->components;
+
+  /* In terms of 'equality' here we are worried about types which are
+     declared the same in two places, not types that represent equivalent
+     structures. (This is common because of FORTRAN's weird scoping rules.)
+     Though two unions with their maps in different orders could be equivalent,
+     we will say they are not equal for the purposes of this test; therefore
+     we compare the maps sequentially. */
+  for (;;)
+  {
+    cmp1 = map1->ts.u.derived->components;
+    cmp2 = map2->ts.u.derived->components;
+    for (;;)
+    {
+      /* No two fields will ever point to the same map type unless they are
+         the same component, because one map field is created with its type
+         declaration. Therefore don't worry about recursion here. */
+      /* TODO: worry about recursion into parent types of the unions? */
+      if (compare_components (cmp1, cmp2) == 0)
+        return 0;
+
+      cmp1 = cmp1->next;
+      cmp2 = cmp2->next;
+
+      if (cmp1 == NULL && cmp2 == NULL)
+        break;
+      if (cmp1 == NULL || cmp2 == NULL)
+        return 0;
+    }
+
+    map1 = map1->next;
+    map2 = map2->next;
+
+    if (map1 == NULL && map2 == NULL)
+      break;
+    if (map1 == NULL || map2 == NULL)
+      return 0;
+  }
+
+  return 1;
+}
+
+
 /* Compare two derived types using the criteria in 4.4.2 of the standard,
    recursing through gfc_compare_types for the components.  */
 
 int
 gfc_compare_derived_types (gfc_symbol *derived1, gfc_symbol *derived2)
 {
-  gfc_component *dt1, *dt2;
+  gfc_component *cmp1, *cmp2;
+  bool anonymous = false;
 
   if (derived1 == derived2)
     return 1;
 
   gcc_assert (derived1 && derived2);
 
+  /* MAP and anonymous STRUCTURE types have internal names of the form
+     mM* and sS* (we can get away with this because source names are converted
+     to lowercase). Compare anonymous type names specially because each
+     gets a unique name when it is declared. */
+  anonymous = (derived1->name[0] == derived2->name[0]
+   && derived1->name[1] == (char) TOUPPER (derived1->name[0])
+   && derived2->name[1] == (char) TOUPPER (derived2->name[0]));
+
   /* Special case for comparing derived types across namespaces.  If the
      true names and module names are the same and the module name is
      nonnull, then they are equal.  */
@@ -404,12 +510,12 @@ gfc_compare_derived_types (gfc_symbol *derived1, gfc_symbol *derived2)
       && strcmp (derived1->module, derived2->module) == 0)
     return 1;
 
+  if (strcmp (derived1->name, derived2->name) != 0 && !anonymous)
+    return 0;
+
   /* Compare type via the rules of the standard.  Both types must have
      the SEQUENCE or BIND(C) attribute to be equal.  */
 
-  if (strcmp (derived1->name, derived2->name))
-    return 0;
-
   if (derived1->component_access == ACCESS_PRIVATE
       || derived2->component_access == ACCESS_PRIVATE)
     return 0;
@@ -418,53 +524,42 @@ gfc_compare_derived_types (gfc_symbol *derived1, gfc_symbol *derived2)
       && !(derived1->attr.is_bind_c && derived2->attr.is_bind_c))
     return 0;
 
-  dt1 = derived1->components;
-  dt2 = derived2->components;
+  if ((derived1->attr.zero_comp && !derived2->attr.zero_comp)
+      || (!derived1->attr.zero_comp && derived2->attr.zero_comp))
+    return 0;
+
+  if (derived1->attr.zero_comp || derived2->attr.zero_comp)
+    return 1;
+
+  cmp1 = derived1->components;
+  cmp2 = derived2->components;
 
   /* Since subtypes of SEQUENCE types must be SEQUENCE types as well, a
      simple test can speed things up.  Otherwise, lots of things have to
      match.  */
   for (;;)
     {
-      if (strcmp (dt1->name, dt2->name) != 0)
-	return 0;
-
-      if (dt1->attr.access != dt2->attr.access)
-	return 0;
-
-      if (dt1->attr.pointer != dt2->attr.pointer)
-	return 0;
-
-      if (dt1->attr.dimension != dt2->attr.dimension)
-	return 0;
-
-     if (dt1->attr.allocatable != dt2->attr.allocatable)
-	return 0;
-
-      if (dt1->attr.dimension && gfc_compare_array_spec (dt1->as, dt2->as) == 0)
-	return 0;
-
       /* Make sure that link lists do not put this function into an
 	 endless recursive loop!  */
-      if (!(dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.u.derived)
-	    && !(dt2->ts.type == BT_DERIVED && derived2 == dt2->ts.u.derived)
-	    && gfc_compare_types (&dt1->ts, &dt2->ts) == 0)
+      if (     !(cmp1->ts.type == BT_DERIVED && derived1 == cmp1->ts.u.derived)
+            && !(cmp2->ts.type == BT_DERIVED && derived2 == cmp2->ts.u.derived)
+            && compare_components (cmp1, cmp2) == 0)
 	return 0;
 
-      else if ((dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.u.derived)
-		&& !(dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.u.derived))
+      else if ( (cmp1->ts.type == BT_DERIVED && derived1 == cmp1->ts.u.derived)
+            && !(cmp2->ts.type == BT_DERIVED && derived2 == cmp2->ts.u.derived))
 	return 0;
 
-      else if (!(dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.u.derived)
-		&& (dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.u.derived))
+      else if (!(cmp1->ts.type == BT_DERIVED && derived1 == cmp1->ts.u.derived)
+            &&  (cmp2->ts.type == BT_DERIVED && derived2 == cmp2->ts.u.derived))
 	return 0;
 
-      dt1 = dt1->next;
-      dt2 = dt2->next;
+      cmp1 = cmp1->next;
+      cmp2 = cmp2->next;
 
-      if (dt1 == NULL && dt2 == NULL)
+      if (cmp1 == NULL && cmp2 == NULL)
 	break;
-      if (dt1 == NULL || dt2 == NULL)
+      if (cmp1 == NULL || cmp2 == NULL)
 	return 0;
     }
 
@@ -494,10 +589,14 @@ gfc_compare_types (gfc_typespec *ts1, gfc_typespec *ts2)
       && (ts1->u.derived->attr.sequence || ts1->u.derived->attr.is_bind_c))
     return 1;
 
+  if (ts1->type == BT_UNION && ts2->type == BT_UNION)
+    return gfc_compare_union_types (ts1->u.derived, ts2->u.derived);
+
   if (ts1->type != ts2->type
-      && ((ts1->type != BT_DERIVED && ts1->type != BT_CLASS)
-	  || (ts2->type != BT_DERIVED && ts2->type != BT_CLASS)))
+      && (   (ts1->type != BT_DERIVED && ts1->type != BT_CLASS)
+          || (ts2->type != BT_DERIVED && ts2->type != BT_CLASS)))
     return 0;
+
   if (ts1->type != BT_DERIVED && ts1->type != BT_CLASS)
     return (ts1->kind == ts2->kind);
 
@@ -505,7 +604,7 @@ gfc_compare_types (gfc_typespec *ts1, gfc_typespec *ts2)
   if (gfc_type_compatible (ts1, ts2))
     return 1;
 
-  return gfc_compare_derived_types (ts1->u.derived ,ts2->u.derived);
+  return 0;
 }
 
 
@@ -1467,7 +1566,7 @@ check_interface0 (gfc_interface *p, const char *interface_name)
 	 functions or subroutines.  */
       if (((!p->sym->attr.function && !p->sym->attr.subroutine)
 	   || !p->sym->attr.if_source)
-	  && p->sym->attr.flavor != FL_DERIVED)
+	  && !gfc_fl_struct (p->sym->attr.flavor))
 	{
 	  if (p->sym->attr.external)
 	    gfc_error ("Procedure '%s' in %s at %L has no explicit interface",
@@ -1481,17 +1580,21 @@ check_interface0 (gfc_interface *p, const char *interface_name)
 
       /* Verify that procedures are either all SUBROUTINEs or all FUNCTIONs.  */
       if ((psave->sym->attr.function && !p->sym->attr.function
-	   && p->sym->attr.flavor != FL_DERIVED)
+	   && !gfc_fl_struct (p->sym->attr.flavor))
 	  || (psave->sym->attr.subroutine && !p->sym->attr.subroutine))
 	{
-	  if (p->sym->attr.flavor != FL_DERIVED)
+	  if (!gfc_fl_struct (p->sym->attr.flavor))
 	    gfc_error ("In %s at %L procedures must be either all SUBROUTINEs"
 		       " or all FUNCTIONs", interface_name,
 		       &p->sym->declared_at);
-	  else
+	  else if (p->sym->attr.flavor == FL_DERIVED)
 	    gfc_error ("In %s at %L procedures must be all FUNCTIONs as the "
 		       "generic name is also the name of a derived type",
 		       interface_name, &p->sym->declared_at);
+          else
+            gfc_error ("In %s at %L procedures must be all FUNCTIONs as the "
+                       "generic name is also the name of a structure type",
+                       interface_name, &p->sym->declared_at);
 	  return 1;
 	}
 
@@ -1548,8 +1651,8 @@ check_interface1 (gfc_interface *p, gfc_interface *q0,
 	if (p->sym->name == q->sym->name && p->sym->module == q->sym->module)
 	  continue;
 
-	if (p->sym->attr.flavor != FL_DERIVED
-	    && q->sym->attr.flavor != FL_DERIVED
+	if (!gfc_fl_struct (p->sym->attr.flavor)
+	    && !gfc_fl_struct (q->sym->attr.flavor)
 	    && gfc_compare_interfaces (p->sym, q->sym, q->sym->name,
 				       generic_flag, 0, NULL, 0, NULL, NULL))
 	  {
@@ -3328,7 +3431,7 @@ gfc_search_interface (gfc_interface *intr, int sub_flag,
 
   for (; intr; intr = intr->next)
     {
-      if (intr->sym->attr.flavor == FL_DERIVED)
+      if (gfc_fl_struct (intr->sym->attr.flavor))
 	continue;
       if (sub_flag && intr->sym->attr.function)
 	continue;
diff --git a/gcc/fortran/intrinsic.c b/gcc/fortran/intrinsic.c
index 7d78419..888af6c 100644
--- a/gcc/fortran/intrinsic.c
+++ b/gcc/fortran/intrinsic.c
@@ -1108,6 +1108,25 @@ add_functions (void)
 	     NULL, gfc_simplify_abs, gfc_resolve_abs,
 	     a, BT_INTEGER, di, REQUIRED);
 
+  if (gfc_option.flag_dec_intrinsic_ints)
+  {
+  add_sym_1 ("babs", GFC_ISYM_ABS, CLASS_ELEMENTAL, ACTUAL_YES, BT_INTEGER, 1,
+      GFC_STD_GNU, NULL, gfc_simplify_abs, gfc_resolve_abs,
+      a, BT_INTEGER, 1, REQUIRED);
+
+  add_sym_1 ("iiabs", GFC_ISYM_ABS, CLASS_ELEMENTAL, ACTUAL_YES, BT_INTEGER, 2,
+      GFC_STD_GNU, NULL, gfc_simplify_abs, gfc_resolve_abs,
+      a, BT_INTEGER, 2, REQUIRED);
+
+  add_sym_1 ("jiabs", GFC_ISYM_ABS, CLASS_ELEMENTAL, ACTUAL_YES, BT_INTEGER, 4,
+      GFC_STD_GNU, NULL, gfc_simplify_abs, gfc_resolve_abs,
+      a, BT_INTEGER, 4, REQUIRED);
+
+  add_sym_1 ("kiabs", GFC_ISYM_ABS, CLASS_ELEMENTAL, ACTUAL_YES, BT_INTEGER, 8,
+      GFC_STD_GNU, NULL, gfc_simplify_abs, gfc_resolve_abs,
+      a, BT_INTEGER, 8, REQUIRED);
+  }
+
   add_sym_1 ("dabs", GFC_ISYM_ABS, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dd, GFC_STD_F77,
 	     gfc_check_fn_d, gfc_simplify_abs, gfc_resolve_abs,
 	     a, BT_REAL, dd, REQUIRED);
@@ -1231,7 +1250,7 @@ add_functions (void)
 	     x, BT_REAL, dd, REQUIRED);
 
   make_generic ("asin", GFC_ISYM_ASIN, GFC_STD_F77);
-  
+
   add_sym_1 ("asinh", GFC_ISYM_ASINH, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dr,
 	     GFC_STD_F2008, gfc_check_fn_rc2008, gfc_simplify_asinh,
 	     gfc_resolve_asinh, x, BT_REAL, dr, REQUIRED);
@@ -1262,7 +1281,7 @@ add_functions (void)
 	     y, BT_REAL, dr, REQUIRED, x, BT_REAL, dr, REQUIRED);
 
   make_generic ("atan", GFC_ISYM_ATAN, GFC_STD_F77);
-  
+
   add_sym_1 ("atanh", GFC_ISYM_ATANH, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dr,
 	     GFC_STD_F2008, gfc_check_fn_rc2008, gfc_simplify_atanh,
 	     gfc_resolve_atanh, x, BT_REAL, dr, REQUIRED);
@@ -1282,7 +1301,7 @@ add_functions (void)
 	     y, BT_REAL, dd, REQUIRED, x, BT_REAL, dd, REQUIRED);
 
   make_generic ("atan2", GFC_ISYM_ATAN2, GFC_STD_F77);
-  
+
   /* Bessel and Neumann functions for G77 compatibility.  */
   add_sym_1 ("besj0", GFC_ISYM_J0, CLASS_ELEMENTAL, ACTUAL_NO, BT_REAL, dr, GFC_STD_GNU,
 	     gfc_check_fn_r, gfc_simplify_bessel_j0, gfc_resolve_g77_math1,
@@ -1406,6 +1425,25 @@ add_functions (void)
 	     gfc_check_bitfcn, gfc_simplify_btest, gfc_resolve_btest,
 	     i, BT_INTEGER, di, REQUIRED, pos, BT_INTEGER, di, REQUIRED);
 
+  if (gfc_option.flag_dec_intrinsic_ints)
+  {
+  add_sym_2 ("bbtest", GFC_ISYM_BTEST, CLASS_ELEMENTAL, ACTUAL_NO, BT_LOGICAL,
+      1, GFC_STD_GNU, gfc_check_bitfcn, gfc_simplify_btest, gfc_resolve_btest,
+      i, BT_INTEGER, 1, REQUIRED, pos, BT_INTEGER, 1, REQUIRED);
+
+  add_sym_2 ("bitest", GFC_ISYM_BTEST, CLASS_ELEMENTAL, ACTUAL_NO, BT_LOGICAL,
+      2, GFC_STD_GNU, gfc_check_bitfcn, gfc_simplify_btest, gfc_resolve_btest,
+      i, BT_INTEGER, 2, REQUIRED, pos, BT_INTEGER, 2, REQUIRED);
+
+  add_sym_2 ("bjtest", GFC_ISYM_BTEST, CLASS_ELEMENTAL, ACTUAL_NO, BT_LOGICAL,
+      4, GFC_STD_GNU, gfc_check_bitfcn, gfc_simplify_btest, gfc_resolve_btest,
+      i, BT_INTEGER, 4, REQUIRED, pos, BT_INTEGER, 4, REQUIRED);
+
+  add_sym_2 ("bktest", GFC_ISYM_BTEST, CLASS_ELEMENTAL, ACTUAL_NO, BT_LOGICAL,
+      8, GFC_STD_GNU, gfc_check_bitfcn, gfc_simplify_btest, gfc_resolve_btest,
+      i, BT_INTEGER, 8, REQUIRED, pos, BT_INTEGER, 8, REQUIRED);
+  }
+
   make_generic ("btest", GFC_ISYM_BTEST, GFC_STD_F95);
 
   add_sym_2 ("ceiling", GFC_ISYM_CEILING, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, di, GFC_STD_F95,
@@ -1797,6 +1835,25 @@ add_functions (void)
 	     gfc_check_iand, gfc_simplify_iand, gfc_resolve_iand,
 	     i, BT_INTEGER, di, REQUIRED, j, BT_INTEGER, di, REQUIRED);
 
+  if (gfc_option.flag_dec_intrinsic_ints)
+  {
+  add_sym_2 ("biand", GFC_ISYM_IAND, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, 1,
+      GFC_STD_GNU, gfc_check_iand, gfc_simplify_iand, gfc_resolve_iand,
+      i, BT_INTEGER, 1, REQUIRED, j, BT_INTEGER, 1, REQUIRED);
+
+  add_sym_2 ("iiand", GFC_ISYM_IAND, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, 2,
+      GFC_STD_GNU, gfc_check_iand, gfc_simplify_iand, gfc_resolve_iand,
+      i, BT_INTEGER, 2, REQUIRED, j, BT_INTEGER, 2, REQUIRED);
+
+  add_sym_2 ("jiand", GFC_ISYM_IAND, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, 4,
+      GFC_STD_GNU, gfc_check_iand, gfc_simplify_iand, gfc_resolve_iand,
+      i, BT_INTEGER, 4, REQUIRED, j, BT_INTEGER, 4, REQUIRED);
+
+  add_sym_2 ("kiand", GFC_ISYM_IAND, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, 8,
+      GFC_STD_GNU, gfc_check_iand, gfc_simplify_iand, gfc_resolve_iand,
+      i, BT_INTEGER, 8, REQUIRED, j, BT_INTEGER, 8, REQUIRED);
+  }
+
   make_generic ("iand", GFC_ISYM_IAND, GFC_STD_F95);
 
   add_sym_2 ("and", GFC_ISYM_AND, CLASS_IMPURE, ACTUAL_NO, BT_LOGICAL,
@@ -1828,6 +1885,25 @@ add_functions (void)
 	     gfc_check_bitfcn, gfc_simplify_ibclr, gfc_resolve_ibclr,
 	     i, BT_INTEGER, di, REQUIRED, pos, BT_INTEGER, di, REQUIRED);
 
+  if (gfc_option.flag_dec_intrinsic_ints)
+  {
+  add_sym_2 ("bbclr", GFC_ISYM_IBCLR, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      1, GFC_STD_GNU, gfc_check_bitfcn, gfc_simplify_ibclr, gfc_resolve_ibclr,
+      i, BT_INTEGER, 1, REQUIRED, pos, BT_INTEGER, 1, REQUIRED);
+
+  add_sym_2 ("iibclr", GFC_ISYM_IBCLR, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      2, GFC_STD_GNU, gfc_check_bitfcn, gfc_simplify_ibclr, gfc_resolve_ibclr,
+      i, BT_INTEGER, 2, REQUIRED, pos, BT_INTEGER, 2, REQUIRED);
+
+  add_sym_2 ("jibclr", GFC_ISYM_IBCLR, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      4, GFC_STD_GNU, gfc_check_bitfcn, gfc_simplify_ibclr, gfc_resolve_ibclr,
+      i, BT_INTEGER, 4, REQUIRED, pos, BT_INTEGER, 4, REQUIRED);
+
+  add_sym_2 ("kibclr", GFC_ISYM_IBCLR, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      8, GFC_STD_GNU, gfc_check_bitfcn, gfc_simplify_ibclr, gfc_resolve_ibclr,
+      i, BT_INTEGER, 8, REQUIRED, pos, BT_INTEGER, 8, REQUIRED);
+  }
+
   make_generic ("ibclr", GFC_ISYM_IBCLR, GFC_STD_F95);
 
   add_sym_3 ("ibits", GFC_ISYM_IBITS, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, di, GFC_STD_F95,
@@ -1835,12 +1911,54 @@ add_functions (void)
 	     i, BT_INTEGER, di, REQUIRED, pos, BT_INTEGER, di, REQUIRED,
 	     ln, BT_INTEGER, di, REQUIRED);
 
+  if (gfc_option.flag_dec_intrinsic_ints)
+  {
+  add_sym_3 ("bbits", GFC_ISYM_IBITS, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      1, GFC_STD_GNU, gfc_check_ibits, gfc_simplify_ibits, gfc_resolve_ibits,
+      i, BT_INTEGER, 1, REQUIRED, pos, BT_INTEGER, 1, REQUIRED,
+      ln, BT_INTEGER, 1, REQUIRED);
+
+  add_sym_3 ("iibits", GFC_ISYM_IBITS, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      2, GFC_STD_GNU, gfc_check_ibits, gfc_simplify_ibits, gfc_resolve_ibits,
+      i, BT_INTEGER, 2, REQUIRED, pos, BT_INTEGER, 2, REQUIRED,
+      ln, BT_INTEGER, 2, REQUIRED);
+
+  add_sym_3 ("jibits", GFC_ISYM_IBITS, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      4, GFC_STD_GNU, gfc_check_ibits, gfc_simplify_ibits, gfc_resolve_ibits,
+      i, BT_INTEGER, 4, REQUIRED, pos, BT_INTEGER, 4, REQUIRED,
+      ln, BT_INTEGER, 4, REQUIRED);
+
+  add_sym_3 ("kibits", GFC_ISYM_IBITS, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      8, GFC_STD_GNU, gfc_check_ibits, gfc_simplify_ibits, gfc_resolve_ibits,
+      i, BT_INTEGER, 8, REQUIRED, pos, BT_INTEGER, 8, REQUIRED,
+      ln, BT_INTEGER, 8, REQUIRED);
+  }
+
   make_generic ("ibits", GFC_ISYM_IBITS, GFC_STD_F95);
 
   add_sym_2 ("ibset", GFC_ISYM_IBSET, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, di, GFC_STD_F95,
 	     gfc_check_bitfcn, gfc_simplify_ibset, gfc_resolve_ibset,
 	     i, BT_INTEGER, di, REQUIRED, pos, BT_INTEGER, di, REQUIRED);
 
+  if (gfc_option.flag_dec_intrinsic_ints)
+  {
+  add_sym_2 ("bbset", GFC_ISYM_IBSET, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      1, GFC_STD_GNU, gfc_check_bitfcn, gfc_simplify_ibset, gfc_resolve_ibset,
+      i, BT_INTEGER, 1, REQUIRED, pos, BT_INTEGER, 1, REQUIRED);
+
+  add_sym_2 ("iibset", GFC_ISYM_IBSET, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      2, GFC_STD_GNU, gfc_check_bitfcn, gfc_simplify_ibset, gfc_resolve_ibset,
+      i, BT_INTEGER, 2, REQUIRED, pos, BT_INTEGER, 2, REQUIRED);
+
+  add_sym_2 ("jibset", GFC_ISYM_IBSET, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      4, GFC_STD_GNU, gfc_check_bitfcn, gfc_simplify_ibset, gfc_resolve_ibset,
+      i, BT_INTEGER, 4, REQUIRED, pos, BT_INTEGER, 4, REQUIRED);
+
+  add_sym_2 ("kibset", GFC_ISYM_IBSET, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      8, GFC_STD_GNU, gfc_check_bitfcn, gfc_simplify_ibset, gfc_resolve_ibset,
+      i, BT_INTEGER, 8, REQUIRED, pos, BT_INTEGER, 8, REQUIRED);
+  }
+
   make_generic ("ibset", GFC_ISYM_IBSET, GFC_STD_F95);
 
   add_sym_2 ("ichar", GFC_ISYM_ICHAR, CLASS_ELEMENTAL, ACTUAL_NO,
@@ -1854,6 +1972,25 @@ add_functions (void)
 	     gfc_check_ieor, gfc_simplify_ieor, gfc_resolve_ieor,
 	     i, BT_INTEGER, di, REQUIRED, j, BT_INTEGER, di, REQUIRED);
 
+  if (gfc_option.flag_dec_intrinsic_ints)
+  {
+  add_sym_2 ("bieor", GFC_ISYM_IEOR, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, 1,
+      GFC_STD_GNU, gfc_check_ieor, gfc_simplify_ieor, gfc_resolve_ieor,
+      i, BT_INTEGER, 1, REQUIRED, j, BT_INTEGER, 1, REQUIRED);
+
+  add_sym_2 ("iieor", GFC_ISYM_IEOR, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, 2,
+      GFC_STD_GNU, gfc_check_ieor, gfc_simplify_ieor, gfc_resolve_ieor,
+      i, BT_INTEGER, 2, REQUIRED, j, BT_INTEGER, 2, REQUIRED);
+
+  add_sym_2 ("jieor", GFC_ISYM_IEOR, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, 4,
+      GFC_STD_GNU, gfc_check_ieor, gfc_simplify_ieor, gfc_resolve_ieor,
+      i, BT_INTEGER, 4, REQUIRED, j, BT_INTEGER, 4, REQUIRED);
+
+  add_sym_2 ("kieor", GFC_ISYM_IEOR, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, 8,
+      GFC_STD_GNU, gfc_check_ieor, gfc_simplify_ieor, gfc_resolve_ieor,
+      i, BT_INTEGER, 8, REQUIRED, j, BT_INTEGER, 8, REQUIRED);
+  }
+
   make_generic ("ieor", GFC_ISYM_IEOR, GFC_STD_F95);
 
   add_sym_2 ("xor", GFC_ISYM_XOR, CLASS_IMPURE, ACTUAL_NO, BT_LOGICAL,
@@ -1919,6 +2056,25 @@ add_functions (void)
 	     gfc_check_ior, gfc_simplify_ior, gfc_resolve_ior,
 	     i, BT_INTEGER, di, REQUIRED, j, BT_INTEGER, di, REQUIRED);
 
+  if (gfc_option.flag_dec_intrinsic_ints)
+  {
+  add_sym_2 ("bior", GFC_ISYM_IOR, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, 1,
+      GFC_STD_GNU, gfc_check_ior, gfc_simplify_ior, gfc_resolve_ior,
+      i, BT_INTEGER, 1, REQUIRED, j, BT_INTEGER, 1, REQUIRED);
+
+  add_sym_2 ("iior", GFC_ISYM_IOR, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, 2,
+      GFC_STD_GNU, gfc_check_ior, gfc_simplify_ior, gfc_resolve_ior,
+      i, BT_INTEGER, 2, REQUIRED, j, BT_INTEGER, 2, REQUIRED);
+
+  add_sym_2 ("jior", GFC_ISYM_IOR, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, 4,
+      GFC_STD_GNU, gfc_check_ior, gfc_simplify_ior, gfc_resolve_ior,
+      i, BT_INTEGER, 4, REQUIRED, j, BT_INTEGER, 4, REQUIRED);
+
+  add_sym_2 ("kior", GFC_ISYM_IOR, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, 8,
+      GFC_STD_GNU, gfc_check_ior, gfc_simplify_ior, gfc_resolve_ior,
+      i, BT_INTEGER, 8, REQUIRED, j, BT_INTEGER, 8, REQUIRED);
+  }
+
   make_generic ("ior", GFC_ISYM_IOR, GFC_STD_F95);
 
   add_sym_2 ("or", GFC_ISYM_OR, CLASS_IMPURE, ACTUAL_NO, BT_LOGICAL,
@@ -1986,6 +2142,25 @@ add_functions (void)
 	     gfc_check_ishft, gfc_simplify_ishft, gfc_resolve_ishft,
 	     i, BT_INTEGER, di, REQUIRED, sh, BT_INTEGER, di, REQUIRED);
 
+  if (gfc_option.flag_dec_intrinsic_ints)
+  {
+  add_sym_2 ("bshft", GFC_ISYM_ISHFT, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      1, GFC_STD_GNU, gfc_check_ishft, gfc_simplify_ishft, gfc_resolve_ishft,
+      i, BT_INTEGER, 1, REQUIRED, sh, BT_INTEGER, 1, REQUIRED);
+
+  add_sym_2 ("iishft", GFC_ISYM_ISHFT, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      2, GFC_STD_GNU, gfc_check_ishft, gfc_simplify_ishft, gfc_resolve_ishft,
+      i, BT_INTEGER, 2, REQUIRED, sh, BT_INTEGER, 2, REQUIRED);
+
+  add_sym_2 ("jishft", GFC_ISYM_ISHFT, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      4, GFC_STD_GNU, gfc_check_ishft, gfc_simplify_ishft, gfc_resolve_ishft,
+      i, BT_INTEGER, 4, REQUIRED, sh, BT_INTEGER, 4, REQUIRED);
+
+  add_sym_2 ("kishft", GFC_ISYM_ISHFT, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      8, GFC_STD_GNU, gfc_check_ishft, gfc_simplify_ishft, gfc_resolve_ishft,
+      i, BT_INTEGER, 8, REQUIRED, sh, BT_INTEGER, 8, REQUIRED);
+  }
+
   make_generic ("ishft", GFC_ISYM_ISHFT, GFC_STD_F95);
 
   add_sym_3 ("ishftc", GFC_ISYM_ISHFTC, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, di, GFC_STD_F95,
@@ -1993,6 +2168,29 @@ add_functions (void)
 	     i, BT_INTEGER, di, REQUIRED, sh, BT_INTEGER, di, REQUIRED,
 	     sz, BT_INTEGER, di, OPTIONAL);
 
+  if (gfc_option.flag_dec_intrinsic_ints)
+  {
+  add_sym_3 ("bshftc", GFC_ISYM_ISHFTC, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      1, GFC_STD_GNU, gfc_check_ishftc, gfc_simplify_ishftc, gfc_resolve_ishftc,
+      i, BT_INTEGER, 1, REQUIRED, sh, BT_INTEGER, 1, REQUIRED,
+      sz, BT_INTEGER, 1, OPTIONAL);
+
+  add_sym_3 ("iishftc", GFC_ISYM_ISHFTC, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      2, GFC_STD_GNU, gfc_check_ishftc, gfc_simplify_ishftc, gfc_resolve_ishftc,
+      i, BT_INTEGER, 2, REQUIRED, sh, BT_INTEGER, 2, REQUIRED,
+      sz, BT_INTEGER, 2, OPTIONAL);
+
+  add_sym_3 ("jishftc", GFC_ISYM_ISHFTC, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      4, GFC_STD_GNU, gfc_check_ishftc, gfc_simplify_ishftc, gfc_resolve_ishftc,
+      i, BT_INTEGER, 4, REQUIRED, sh, BT_INTEGER, 4, REQUIRED,
+      sz, BT_INTEGER, 4, OPTIONAL);
+
+  add_sym_3 ("kishftc", GFC_ISYM_ISHFTC, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER,
+      8, GFC_STD_GNU, gfc_check_ishftc, gfc_simplify_ishftc, gfc_resolve_ishftc,
+      i, BT_INTEGER, 8, REQUIRED, sh, BT_INTEGER, 8, REQUIRED,
+      sz, BT_INTEGER, 8, OPTIONAL);
+  }
+
   make_generic ("ishftc", GFC_ISYM_ISHFTC, GFC_STD_F95);
 
   add_sym_2 ("kill", GFC_ISYM_KILL, CLASS_IMPURE, ACTUAL_NO, BT_INTEGER,
@@ -2311,6 +2509,25 @@ add_functions (void)
 	     gfc_check_x_yd, gfc_simplify_mod, gfc_resolve_mod,
 	     a, BT_REAL, dd, REQUIRED, p, BT_REAL, dd, REQUIRED);
 
+  if (gfc_option.flag_dec_intrinsic_ints)
+  {
+  add_sym_2 ("bmod", GFC_ISYM_MOD, CLASS_ELEMENTAL, ACTUAL_YES, BT_INTEGER, 1,
+      GFC_STD_GNU, gfc_check_a_p, gfc_simplify_mod, gfc_resolve_mod,
+      a, BT_INTEGER, 1, REQUIRED, p, BT_INTEGER, 1, REQUIRED);
+
+  add_sym_2 ("imod", GFC_ISYM_MOD, CLASS_ELEMENTAL, ACTUAL_YES, BT_INTEGER, 2,
+      GFC_STD_GNU, gfc_check_a_p, gfc_simplify_mod, gfc_resolve_mod,
+      a, BT_INTEGER, 2, REQUIRED, p, BT_INTEGER, 2, REQUIRED);
+
+  add_sym_2 ("jmod", GFC_ISYM_MOD, CLASS_ELEMENTAL, ACTUAL_YES, BT_INTEGER, 4,
+      GFC_STD_GNU, gfc_check_a_p, gfc_simplify_mod, gfc_resolve_mod,
+      a, BT_INTEGER, 4, REQUIRED, p, BT_INTEGER, 4, REQUIRED);
+
+  add_sym_2 ("kmod", GFC_ISYM_MOD, CLASS_ELEMENTAL, ACTUAL_YES, BT_INTEGER, 8,
+      GFC_STD_GNU, gfc_check_a_p, gfc_simplify_mod, gfc_resolve_mod,
+      a, BT_INTEGER, 8, REQUIRED, p, BT_INTEGER, 8, REQUIRED);
+  }
+
   make_generic ("mod", GFC_ISYM_MOD, GFC_STD_F77);
 
   add_sym_2 ("modulo", GFC_ISYM_MODULO, CLASS_ELEMENTAL, ACTUAL_NO, BT_REAL, di, GFC_STD_F95,
@@ -2345,6 +2562,25 @@ add_functions (void)
 	     gfc_check_i, gfc_simplify_not, gfc_resolve_not,
 	     i, BT_INTEGER, di, REQUIRED);
 
+  if (gfc_option.flag_dec_intrinsic_ints)
+  {
+  add_sym_1 ("bnot", GFC_ISYM_NOT, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, 1,
+      GFC_STD_GNU, gfc_check_i, gfc_simplify_not, gfc_resolve_not,
+      i, BT_INTEGER, 1, REQUIRED);
+
+  add_sym_1 ("inot", GFC_ISYM_NOT, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, 2,
+      GFC_STD_GNU, gfc_check_i, gfc_simplify_not, gfc_resolve_not,
+      i, BT_INTEGER, 2, REQUIRED);
+
+  add_sym_1 ("jnot", GFC_ISYM_NOT, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, 4,
+      GFC_STD_GNU, gfc_check_i, gfc_simplify_not, gfc_resolve_not,
+      i, BT_INTEGER, 4, REQUIRED);
+
+  add_sym_1 ("knot", GFC_ISYM_NOT, CLASS_ELEMENTAL, ACTUAL_NO, BT_INTEGER, 8,
+      GFC_STD_GNU, gfc_check_i, gfc_simplify_not, gfc_resolve_not,
+      i, BT_INTEGER, 8, REQUIRED);
+  }
+
   make_generic ("not", GFC_ISYM_NOT, GFC_STD_F95);
 
   add_sym_2 ("norm2", GFC_ISYM_NORM2, CLASS_TRANSFORMATIONAL, ACTUAL_NO, BT_REAL, dr,
@@ -2453,6 +2689,21 @@ add_functions (void)
 	     gfc_check_float, gfc_simplify_float, NULL,
 	     a, BT_INTEGER, di, REQUIRED);
 
+  if (gfc_option.flag_dec_intrinsic_ints)
+  {
+  add_sym_1 ("floati", GFC_ISYM_REAL, CLASS_ELEMENTAL, ACTUAL_NO, BT_REAL, dr,
+      GFC_STD_GNU, gfc_check_float, gfc_simplify_float, NULL,
+      a, BT_INTEGER, 2, REQUIRED);
+
+  add_sym_1 ("floatj", GFC_ISYM_REAL, CLASS_ELEMENTAL, ACTUAL_NO, BT_REAL, dr,
+      GFC_STD_GNU, gfc_check_float, gfc_simplify_float, NULL,
+      a, BT_INTEGER, 4, REQUIRED);
+
+  add_sym_1 ("floatk", GFC_ISYM_REAL, CLASS_ELEMENTAL, ACTUAL_NO, BT_REAL, dr,
+      GFC_STD_GNU, gfc_check_float, gfc_simplify_float, NULL,
+      a, BT_INTEGER, 8, REQUIRED);
+  }
+
   add_sym_1 ("dfloat", GFC_ISYM_REAL, CLASS_ELEMENTAL, ACTUAL_NO, BT_REAL, dd, GFC_STD_GNU,
 	     gfc_check_float, gfc_simplify_dble, gfc_resolve_dble,
 	     a, BT_REAL, dr, REQUIRED);
@@ -2857,6 +3108,109 @@ add_functions (void)
 	     x, BT_UNKNOWN, 0, REQUIRED);
 		
   make_generic ("loc", GFC_ISYM_LOC, GFC_STD_GNU);
+
+  /* Extended math functions provided as DEC extensions. */
+
+  if (gfc_option.flag_dec_math)
+  {
+  add_sym_1 ("acosd", GFC_ISYM_ACOS, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dr, 
+             GFC_STD_GNU, gfc_check_fn_r, gfc_simplify_atrigd, gfc_resolve_acos,
+	     x, BT_REAL, dr, REQUIRED);
+
+  add_sym_1 ("dacosd", GFC_ISYM_ACOS, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dd, 
+             GFC_STD_GNU, gfc_check_fn_d, gfc_simplify_atrigd, gfc_resolve_acos,
+	     x, BT_REAL, dd, REQUIRED);
+
+  make_generic ("acosd", GFC_ISYM_ACOS, GFC_STD_GNU);
+
+
+  add_sym_1 ("asind", GFC_ISYM_ASIN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dr, 
+             GFC_STD_GNU, gfc_check_fn_r, gfc_simplify_atrigd, gfc_resolve_asin,
+             x, BT_REAL, dr, REQUIRED);
+
+  add_sym_1 ("dasind", GFC_ISYM_ASIN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dd, 
+             GFC_STD_GNU, gfc_check_fn_d, gfc_simplify_atrigd, gfc_resolve_asin,
+             x, BT_REAL, dd, REQUIRED);
+
+  make_generic ("asind", GFC_ISYM_ASIN, GFC_STD_GNU);
+
+
+  add_sym_1 ("atand", GFC_ISYM_ATAN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dr, 
+             GFC_STD_GNU, gfc_check_fn_r, gfc_simplify_atrigd, gfc_resolve_atan,
+             x, BT_REAL, dr, REQUIRED);
+
+  add_sym_1 ("datand", GFC_ISYM_ATAN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dd, 
+             GFC_STD_GNU, gfc_check_fn_d, gfc_simplify_atrigd, gfc_resolve_atan,
+             x, BT_REAL, dd, REQUIRED);
+
+  make_generic ("atand", GFC_ISYM_ATAN, GFC_STD_GNU);
+
+
+  add_sym_2 ("atan2d",GFC_ISYM_ATAN2,CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dr, 
+          GFC_STD_GNU, gfc_check_atan2, gfc_simplify_atan2d, gfc_resolve_atan2,
+          y, BT_REAL, dr, REQUIRED, x, BT_REAL, dr, REQUIRED);
+
+  add_sym_2 ("datan2d",GFC_ISYM_ATAN2,CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dd, 
+          GFC_STD_GNU, gfc_check_datan2, gfc_simplify_atan2d, gfc_resolve_atan2,
+          y, BT_REAL, dd, REQUIRED, x, BT_REAL, dd, REQUIRED);
+
+  make_generic ("atan2d", GFC_ISYM_ATAN2, GFC_STD_GNU);
+
+
+  add_sym_1 ("cosd", GFC_ISYM_COS, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dr, 
+             GFC_STD_GNU, gfc_check_fn_r, gfc_simplify_trigd, gfc_resolve_cos,
+             x, BT_REAL, dr, REQUIRED);
+
+  add_sym_1 ("dcosd", GFC_ISYM_COS, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dd, 
+             GFC_STD_GNU, gfc_check_fn_d, gfc_simplify_trigd, gfc_resolve_cos,
+             x, BT_REAL, dd, REQUIRED);
+
+  make_generic ("cosd", GFC_ISYM_COS, GFC_STD_GNU);
+
+
+  add_sym_1 ("cotan", GFC_ISYM_COTAN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dr, 
+             GFC_STD_GNU, gfc_check_fn_r, gfc_simplify_cotan, gfc_resolve_tan,
+                     x, BT_REAL, dr, REQUIRED);
+
+  add_sym_1 ("dcotan", GFC_ISYM_COTAN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dd,
+             GFC_STD_GNU, gfc_check_fn_d, gfc_simplify_cotan, gfc_resolve_tan,
+             x, BT_REAL, dd, REQUIRED);
+
+  make_generic ("cotan", GFC_ISYM_COTAN, GFC_STD_GNU);
+
+
+  add_sym_1 ("cotand", GFC_ISYM_COTAN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dr,
+             GFC_STD_GNU, gfc_check_fn_r, gfc_simplify_trigd, gfc_resolve_tan,
+             x, BT_REAL, dr, REQUIRED);
+
+  add_sym_1 ("dcotand",GFC_ISYM_COTAN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dd,
+             GFC_STD_GNU, gfc_check_fn_d, gfc_simplify_trigd, gfc_resolve_tan,
+             x, BT_REAL, dd, REQUIRED);
+
+  make_generic ("cotand", GFC_ISYM_COTAN, GFC_STD_GNU);
+
+
+  add_sym_1 ("sind", GFC_ISYM_SIN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dr, 
+             GFC_STD_GNU, gfc_check_fn_r, gfc_simplify_trigd, gfc_resolve_sin,
+             x, BT_REAL, dr, REQUIRED);
+
+  add_sym_1 ("dsind", GFC_ISYM_SIN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dd, 
+             GFC_STD_GNU, gfc_check_fn_d, gfc_simplify_trigd, gfc_resolve_sin,
+             x, BT_REAL, dd, REQUIRED);
+
+  make_generic ("sind", GFC_ISYM_SIN, GFC_STD_GNU);
+
+
+  add_sym_1 ("tand", GFC_ISYM_TAN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dr,
+             GFC_STD_GNU, gfc_check_fn_r, gfc_simplify_trigd, gfc_resolve_tan,
+             x, BT_REAL, dr, REQUIRED);
+  
+  add_sym_1 ("dtand", GFC_ISYM_TAN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dd,
+             GFC_STD_GNU, gfc_check_fn_d, gfc_simplify_trigd, gfc_resolve_tan,
+             x, BT_REAL, dd, REQUIRED);
+
+  make_generic ("tand", GFC_ISYM_TAN, GFC_STD_GNU);
+  }
 }
 
 
@@ -3044,6 +3398,42 @@ add_subroutines (void)
 	      t, BT_INTEGER, di, REQUIRED, INTENT_INOUT,
 	      tp, BT_INTEGER, di, REQUIRED, INTENT_IN);
 
+  add_sym_5s ("bmvbits", GFC_ISYM_MVBITS, CLASS_ELEMENTAL, BT_UNKNOWN, 0,
+	      GFC_STD_F95, gfc_check_mvbits, gfc_simplify_mvbits,
+	      gfc_resolve_mvbits,
+	      f, BT_INTEGER, 1, REQUIRED, INTENT_IN,
+	      fp, BT_INTEGER, di, REQUIRED, INTENT_IN,
+	      ln, BT_INTEGER, di, REQUIRED, INTENT_IN,
+	      t, BT_INTEGER, 1, REQUIRED, INTENT_INOUT,
+	      tp, BT_INTEGER, di, REQUIRED, INTENT_IN);
+
+  add_sym_5s ("imvbits", GFC_ISYM_MVBITS, CLASS_ELEMENTAL, BT_UNKNOWN, 0,
+	      GFC_STD_F95, gfc_check_mvbits, gfc_simplify_mvbits,
+	      gfc_resolve_mvbits,
+	      f, BT_INTEGER, 2, REQUIRED, INTENT_IN,
+	      fp, BT_INTEGER, di, REQUIRED, INTENT_IN,
+	      ln, BT_INTEGER, di, REQUIRED, INTENT_IN,
+	      t, BT_INTEGER, 2, REQUIRED, INTENT_INOUT,
+	      tp, BT_INTEGER, di, REQUIRED, INTENT_IN);
+
+  add_sym_5s ("jmvbits", GFC_ISYM_MVBITS, CLASS_ELEMENTAL, BT_UNKNOWN, 0,
+	      GFC_STD_F95, gfc_check_mvbits, gfc_simplify_mvbits,
+	      gfc_resolve_mvbits,
+	      f, BT_INTEGER, 4, REQUIRED, INTENT_IN,
+	      fp, BT_INTEGER, di, REQUIRED, INTENT_IN,
+	      ln, BT_INTEGER, di, REQUIRED, INTENT_IN,
+	      t, BT_INTEGER, 4, REQUIRED, INTENT_INOUT,
+	      tp, BT_INTEGER, di, REQUIRED, INTENT_IN);
+
+  add_sym_5s ("kmvbits", GFC_ISYM_MVBITS, CLASS_ELEMENTAL, BT_UNKNOWN, 0,
+	      GFC_STD_F95, gfc_check_mvbits, gfc_simplify_mvbits,
+	      gfc_resolve_mvbits,
+	      f, BT_INTEGER, 8, REQUIRED, INTENT_IN,
+	      fp, BT_INTEGER, di, REQUIRED, INTENT_IN,
+	      ln, BT_INTEGER, di, REQUIRED, INTENT_IN,
+	      t, BT_INTEGER, 8, REQUIRED, INTENT_INOUT,
+	      tp, BT_INTEGER, di, REQUIRED, INTENT_IN);
+
   add_sym_1s ("random_number", GFC_ISYM_RANDOM_NUMBER, CLASS_IMPURE,
 	      BT_UNKNOWN, 0, GFC_STD_F95,
 	      gfc_check_random_number, NULL, gfc_resolve_random_number,
@@ -3775,6 +4165,32 @@ do_simplify (gfc_intrinsic_sym *specific, gfc_expr *e)
       goto finish;
     }
 
+  /* Degree trig functions just wrap trig builtins with deg/rad conversions. */
+  if (specific->simplify.f1 == gfc_simplify_trigd)
+    {
+      result = gfc_simplify_trigd (e);
+      goto finish;
+    }
+
+  if (specific->simplify.f1 == gfc_simplify_atrigd)
+    {
+      result = gfc_simplify_atrigd (e);
+      goto finish;
+    }
+
+  /* Some other functions needs to know e to wrap the original call */
+  if (specific->simplify.f1 == gfc_simplify_cotan)
+    {
+      result = gfc_simplify_cotan (e);
+      goto finish;
+    }
+
+  if (specific->simplify.f2 == gfc_simplify_atan2d)
+    {
+      result = gfc_simplify_atan2d (e, NULL);
+      goto finish;
+    }
+
   if (specific->simplify.f1 == NULL)
     {
       result = NULL;
diff --git a/gcc/fortran/intrinsic.h b/gcc/fortran/intrinsic.h
index 5d50285..3a77d98 100644
--- a/gcc/fortran/intrinsic.h
+++ b/gcc/fortran/intrinsic.h
@@ -67,6 +67,7 @@ gfc_try gfc_check_float (gfc_expr *);
 gfc_try gfc_check_fstat (gfc_expr *, gfc_expr *);
 gfc_try gfc_check_ftell (gfc_expr *);
 gfc_try gfc_check_fn_c (gfc_expr *);
+gfc_try gfc_check_fn_q (gfc_expr *);
 gfc_try gfc_check_fn_d (gfc_expr *);
 gfc_try gfc_check_fn_r (gfc_expr *);
 gfc_try gfc_check_fn_rc (gfc_expr *);
@@ -221,6 +222,7 @@ gfc_expr *gfc_simplify_adjustr (gfc_expr *);
 gfc_expr *gfc_simplify_aimag (gfc_expr *);
 gfc_expr *gfc_simplify_aint (gfc_expr *, gfc_expr *);
 gfc_expr *gfc_simplify_all (gfc_expr *, gfc_expr *);
+gfc_expr *gfc_simplify_atrigd (gfc_expr *);
 gfc_expr *gfc_simplify_dint (gfc_expr *);
 gfc_expr *gfc_simplify_anint (gfc_expr *, gfc_expr *);
 gfc_expr *gfc_simplify_dnint (gfc_expr *);
@@ -231,6 +233,7 @@ gfc_expr *gfc_simplify_asinh (gfc_expr *);
 gfc_expr *gfc_simplify_atan (gfc_expr *);
 gfc_expr *gfc_simplify_atanh (gfc_expr *);
 gfc_expr *gfc_simplify_atan2 (gfc_expr *, gfc_expr *);
+gfc_expr *gfc_simplify_atan2d (gfc_expr *, gfc_expr *);
 gfc_expr *gfc_simplify_bessel_j0 (gfc_expr *);
 gfc_expr *gfc_simplify_bessel_j1 (gfc_expr *);
 gfc_expr *gfc_simplify_bessel_jn (gfc_expr *, gfc_expr *);
@@ -254,6 +257,7 @@ gfc_expr *gfc_simplify_complex (gfc_expr *, gfc_expr *);
 gfc_expr *gfc_simplify_conjg (gfc_expr *);
 gfc_expr *gfc_simplify_cos (gfc_expr *);
 gfc_expr *gfc_simplify_cosh (gfc_expr *);
+gfc_expr *gfc_simplify_cotan (gfc_expr *);
 gfc_expr *gfc_simplify_count (gfc_expr *, gfc_expr *, gfc_expr *);
 gfc_expr *gfc_simplify_dcmplx (gfc_expr *, gfc_expr *);
 gfc_expr *gfc_simplify_dble (gfc_expr *);
@@ -383,6 +387,7 @@ gfc_expr *gfc_simplify_tiny (gfc_expr *);
 gfc_expr *gfc_simplify_trailz (gfc_expr *);
 gfc_expr *gfc_simplify_transfer (gfc_expr *, gfc_expr *, gfc_expr *);
 gfc_expr *gfc_simplify_transpose (gfc_expr *);
+gfc_expr *gfc_simplify_trigd (gfc_expr *);
 gfc_expr *gfc_simplify_trim (gfc_expr *);
 gfc_expr *gfc_simplify_ubound (gfc_expr *, gfc_expr *, gfc_expr *);
 gfc_expr *gfc_simplify_ucobound (gfc_expr *, gfc_expr *, gfc_expr *);
diff --git a/gcc/fortran/intrinsic.texi b/gcc/fortran/intrinsic.texi
index 1e31e4f..b34dcea 100644
--- a/gcc/fortran/intrinsic.texi
+++ b/gcc/fortran/intrinsic.texi
@@ -23,6 +23,9 @@ Some basic guidelines for editing this document:
 @end ignore
 
 @tex
+\gdef\acosd{\mathop{\rm acosd}\nolimits}
+\gdef\asind{\mathop{\rm asind}\nolimits}
+\gdef\atand{\mathop{\rm atand}\nolimits}
 \gdef\acos{\mathop{\rm acos}\nolimits}
 \gdef\asin{\mathop{\rm asin}\nolimits}
 \gdef\atan{\mathop{\rm atan}\nolimits}
@@ -43,6 +46,7 @@ Some basic guidelines for editing this document:
 * @code{ACCESS}:        ACCESS,    Checks file access modes
 * @code{ACHAR}:         ACHAR,     Character in @acronym{ASCII} collating sequence
 * @code{ACOS}:          ACOS,      Arccosine function
+* @code{ACOSD}:         ACOSD,     Arccosine function in degrees
 * @code{ACOSH}:         ACOSH,     Inverse hyperbolic cosine function
 * @code{ADJUSTL}:       ADJUSTL,   Left adjust a string
 * @code{ADJUSTR}:       ADJUSTR,   Right adjust a string
@@ -55,10 +59,13 @@ Some basic guidelines for editing this document:
 * @code{ANINT}:         ANINT,     Nearest whole number
 * @code{ANY}:           ANY,       Determine if any values are true
 * @code{ASIN}:          ASIN,      Arcsine function
+* @code{ASIND}:         ASIND,     Arcsine function in degrees
 * @code{ASINH}:         ASINH,     Inverse hyperbolic sine function
 * @code{ASSOCIATED}:    ASSOCIATED, Status of a pointer or pointer/target pair
 * @code{ATAN}:          ATAN,      Arctangent function
+* @code{ATAND}:         ATAND,     Arctangent function in degrees
 * @code{ATAN2}:         ATAN2,     Arctangent function
+* @code{ATAN2D}:        ATAN2D,    Arctangent function in degrees
 * @code{ATANH}:         ATANH,     Inverse hyperbolic tangent function
 * @code{ATOMIC_DEFINE}: ATOMIC_DEFINE, Setting a variable atomically
 * @code{ATOMIC_REF}:    ATOMIC_REF, Obtaining the value of a variable atomically
@@ -92,7 +99,10 @@ Some basic guidelines for editing this document:
 * @code{COMPLEX}:       COMPLEX,   Complex conversion function
 * @code{CONJG}:         CONJG,     Complex conjugate function
 * @code{COS}:           COS,       Cosine function
+* @code{COSD}:          COSD,      Cosine function, degree-valued paratemer
 * @code{COSH}:          COSH,      Hyperbolic cosine function
+* @code{COTAN}:         COTAN,     Cotangent function
+* @code{COTAND}:        COTAND,    Cotangent function, degree-valued parameter
 * @code{COUNT}:         COUNT,     Count occurrences of TRUE in an array
 * @code{CPU_TIME}:      CPU_TIME,  CPU time subroutine
 * @code{CSHIFT}:        CSHIFT,    Circular shift elements of an array
@@ -262,6 +272,7 @@ Some basic guidelines for editing this document:
 * @code{SIGN}:          SIGN,      Sign copying function
 * @code{SIGNAL}:        SIGNAL,    Signal handling subroutine (or function)
 * @code{SIN}:           SIN,       Sine function
+* @code{SIND}:          SIND,      Sine function, degree-valued parameter
 * @code{SINH}:          SINH,      Hyperbolic sine function
 * @code{SIZE}:          SIZE,      Function to determine the size of an array
 * @code{SIZEOF}:        SIZEOF,    Determine the size in bytes of an expression
@@ -277,6 +288,7 @@ Some basic guidelines for editing this document:
 * @code{SYSTEM}:        SYSTEM,    Execute a shell command
 * @code{SYSTEM_CLOCK}:  SYSTEM_CLOCK, Time function
 * @code{TAN}:           TAN,       Tangent function
+* @code{TAND}:          TAND,      Tangent function, degree-valued parameter
 * @code{TANH}:          TANH,      Hyperbolic tangent function
 * @code{THIS_IMAGE}:    THIS_IMAGE, Cosubscript index of this image
 * @code{TIME}:          TIME,      Time function
@@ -596,6 +608,62 @@ end program test_acos
 
 @item @emph{See also}:
 Inverse function: @ref{COS}
+Degree version: @ref{ACOSD}
+
+@end table
+
+
+
+@node ACOSD
+@section @code{ACOSD} --- Arccosine function in degrees
+@fnindex ACOSD
+@fnindex DACOSD
+@cindex trigonometric function, cosine, inverse, degrees
+@cindex cosine, inverse, degrees
+
+@table @asis
+@item @emph{Description}:
+@code{ACOSD(X)} computes the arccosine of @var{X} in degrees (inverse of
+@code{COSD(X)}).
+
+@item @emph{Standard}:
+None. Enabled with @option{-fdec-math}
+
+@item @emph{Class}:
+Elemental function
+
+@item @emph{Syntax}:
+@code{RESULT = ACOSD(X)}
+
+@item @emph{Arguments}:
+@multitable @columnfractions .15 .70
+@item @var{X} @tab The type shall be @code{REAL} with a magnitude that is
+less than or equal to one.
+@end multitable
+
+@item @emph{Return value}:
+The return value is of the same type and kind as @var{X}.
+The result is in degrees and lies in the range
+-90 @leq{} @math{\acosd(x)} @leq{} 90.
+
+@item @emph{Example}:
+@smallexample
+program test_acosd
+  real(8) :: x = 0.866_8
+  x = acosd(x) ! => 30.0
+end program test_acosd
+@end smallexample
+
+@item @emph{Specific names}:
+@multitable @columnfractions .20 .20 .20 .25
+@item Name            @tab Argument         @tab Return type     @tab Standard
+@item @code{ACOSD(X)}  @tab @code{REAL(4) X} @tab @code{REAL(4)}  @tab None
+@item @code{DACOSD(X)} @tab @code{REAL(8) X} @tab @code{REAL(8)}  @tab None
+@end multitable
+
+@item @emph{See also}:
+Inverse function: @ref{COSD}
+Radian version: @ref{ACOS}
 
 @end table
 
@@ -1246,6 +1314,62 @@ end program test_asin
 
 @item @emph{See also}:
 Inverse function: @ref{SIN}
+Degree version: @ref{ASIND}
+
+@end table
+
+
+
+@node ASIND
+@section @code{ASIND} --- Arcsine function in degrees
+@fnindex ASIND
+@fnindex DASIND
+@cindex trigonometric function, sine, inverse, degrees
+@cindex sine, inverse, degrees
+
+@table @asis
+@item @emph{Description}:
+@code{ASIND(X)} computes the arcsine of its @var{X} in degrees (inverse of
+@code{SIND(X)}).
+
+@item @emph{Standard}:
+None. Enabled with @option{-fdec-math}
+
+@item @emph{Class}:
+Elemental function
+
+@item @emph{Syntax}:
+@code{RESULT = ASIND(X)}
+
+@item @emph{Arguments}:
+@multitable @columnfractions .15 .70
+@item @var{X} @tab The type shall be @code{REAL} and a magnitude that is
+less than or equal to one.
+@end multitable
+
+@item @emph{Return value}:
+The return value is of the same type and kind as @var{X}.
+The result is in degrees and lies in the range
+-90 @leq{} @math{\asind(x)} @leq{} 90.
+
+@item @emph{Example}:
+@smallexample
+program test_asind
+  real(8) :: x = 0.866_8
+  x = asind(x) ! => 60.0
+end program test_asind
+@end smallexample
+
+@item @emph{Specific names}:
+@multitable @columnfractions .20 .20 .20 .25
+@item Name            @tab Argument          @tab Return type       @tab Standard
+@item @code{ASIND(X)}  @tab @code{REAL(4) X}  @tab @code{REAL(4)}    @tab None
+@item @code{DASIND(X)} @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab None
+@end multitable
+
+@item @emph{See also}:
+Inverse function: @ref{SIND}
+Radian version: @ref{ASIN}
 
 @end table
 
@@ -1435,6 +1559,63 @@ end program test_atan
 
 @item @emph{See also}:
 Inverse function: @ref{TAN}
+Degree version: @ref{ATAND}
+
+@end table
+
+
+
+@node ATAND
+@section @code{ATAND} --- Arctangent function in degrees
+@fnindex ATAND
+@fnindex DATAND
+@cindex trigonometric function, tangent, inverse, degrees
+@cindex tangent, inverse, degrees
+
+@table @asis
+@item @emph{Description}:
+@code{ATAND(X)} computes the arctangent of @var{X} in degrees.
+
+@item @emph{Standard}:
+None. Enabled with @option{-fdec-math}
+
+@item @emph{Class}:
+Elemental function
+
+@item @emph{Syntax}:
+@multitable @columnfractions .80
+@item @code{RESULT = ATAND(X)}
+@end multitable
+
+@item @emph{Arguments}:
+@multitable @columnfractions .15 .70
+@item @var{X} @tab The type shall be @code{REAL}. The value must be greater
+than or equal to zero.
+@end multitable
+
+@item @emph{Return value}:
+The return value is of the same type and kind as @var{X}.
+The result is in degrees and lies in the range
+-90 @leq{} @math{\asind(x)} @leq{} 90.
+
+@item @emph{Example}:
+@smallexample
+program test_atand
+  real(8) :: x = 1.0_8
+  x = atand(x) ! => 45.0
+end program test_atand
+@end smallexample
+
+@item @emph{Specific names}:
+@multitable @columnfractions .20 .20 .20 .25
+@item Name            @tab Argument          @tab Return type       @tab Standard
+@item @code{ATAND(X)}  @tab @code{REAL(4) X}  @tab @code{REAL(4)}    @tab None.
+@item @code{DATAND(X)} @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab None.
+@end multitable
+
+@item @emph{See also}:
+Inverse function: @ref{TAND}
+Radian version: @ref{ATAN}
 
 @end table
 
@@ -1495,6 +1676,75 @@ end program test_atan2
 @item @code{ATAN2(X, Y)}  @tab @code{REAL(4) X, Y} @tab @code{REAL(4)} @tab Fortran 77 and later
 @item @code{DATAN2(X, Y)} @tab @code{REAL(8) X, Y} @tab @code{REAL(8)} @tab Fortran 77 and later
 @end multitable
+
+@item @emph{See also}:
+Degree version: @ref{ATAN2D}
+
+@end table
+
+
+
+@node ATAN2D
+@section @code{ATAN2D} --- Arctangent function in degrees
+@fnindex ATAN2D
+@fnindex DATAN2D
+@cindex trigonometric function, tangent, inverse, degrees
+@cindex tangent, inverse, degrees
+
+@table @asis
+@item @emph{Description}:
+@code{ATAN2D(Y, X)} computes the principal value of the argument
+function of the complex number @math{X + i Y} in degrees. This function can
+be used to transform from Cartesian into polar coordinates and
+allows to determine the angle in the correct quadrant.
+
+@item @emph{Standard}:
+None. Enabled with @option{-fdec-math}
+
+@item @emph{Class}:
+Elemental function
+
+@item @emph{Syntax}:
+@code{RESULT = ATAN2D(Y, X)}
+
+@item @emph{Arguments}:
+@multitable @columnfractions .15 .70
+@item @var{Y} @tab The type shall be @code{REAL}.
+@item @var{X} @tab The type and kind type parameter shall be the same as @var{Y}.
+If @var{Y} is zero, then @var{X} must be nonzero.
+@end multitable
+
+@item @emph{Return value}:
+The return value has the same type and kind type parameter as @var{Y} and is
+expressed in degrees. It
+is the principal value of the complex number @math{X + i Y}.  If @var{X}
+is nonzero, then it lies in the range
+@math{-180.0} @leq{} @math{\atan (x)} @leq{} @math{180.0}.
+The sign is positive if @var{Y} is positive.  If @var{Y} is zero, then
+the return value is zero if @var{X} is strictly positive, @math{180.0} if
+@var{X} is negative and @var{Y} is positive zero (or the processor does
+not handle signed zeros), and @math{-180.0} if @var{X} is negative and
+@var{Y} is negative zero.  Finally, if @var{X} is zero, then the
+magnitude of the result is @math{90.0}.
+
+@item @emph{Example}:
+@smallexample
+program test_atan2d
+  real(4) :: x = 1.e0_4, y = 2.679676_4
+  x = atan2d(y,x) ! => 69.53546
+end program test_atan2d
+@end smallexample
+
+@item @emph{Specific names}:
+@multitable @columnfractions .20 .20 .20 .25
+@item Name                @tab Argument            @tab Return type    @tab Standard
+@item @code{ATAN2D(X, Y)}  @tab @code{REAL(4) X, Y} @tab @code{REAL(4)} @tab None
+@item @code{DATAN2D(X, Y)} @tab @code{REAL(8) X, Y} @tab @code{REAL(8)} @tab None
+@end multitable
+
+@item @emph{See also}:
+Radian version: @ref{ATAN2}
+
 @end table
 
 
@@ -3096,6 +3346,61 @@ end program test_cos
 
 @item @emph{See also}:
 Inverse function: @ref{ACOS}
+Degree version: @ref{COSD}
+
+@end table
+
+
+
+@node COSD
+@section @code{COSD} --- Cosine function, degree-valued parameter
+@fnindex COSD
+@fnindex DCOSD
+@cindex trigonometric function, cosine, degrees
+@cindex cosine, degrees
+
+@table @asis
+@item @emph{Description}:
+@code{COSD(X)} computes the cosine of @var{X}, which is in degrees.
+
+@item @emph{Standard}:
+None. Enabled with @option{-fdec-math}
+
+@item @emph{Class}:
+Elemental function
+
+@item @emph{Syntax}:
+@code{RESULT = COSD(X)}
+
+@item @emph{Arguments}:
+@multitable @columnfractions .15 .70
+@item @var{X} @tab The type shall be @code{REAL}. The value is in degrees and
+is treated as modulo 360.
+@end multitable
+
+@item @emph{Return value}:
+The return value is of the same type and kind as @var{X}. The result is in
+radians. The return value lies in the range
+@math{-1} @leq{} @math{\cos (x)} @leq{} @math{1}.
+
+@item @emph{Example}:
+@smallexample
+program test_cosd
+  real :: x = 45.0
+  x = cos(x) ! => 0.707
+end program test_cosd
+@end smallexample
+
+@item @emph{Specific names}:
+@multitable @columnfractions .20 .20 .20 .25
+@item Name            @tab Argument            @tab Return type       @tab Standard
+@item @code{COSD(X)}   @tab @code{REAL(4) X}    @tab @code{REAL(4)}    @tab None
+@item @code{DCOSD(X)}  @tab @code{REAL(8) X}    @tab @code{REAL(8)}    @tab None
+@end multitable
+
+@item @emph{See also}:
+Inverse function: @ref{ACOSD}
+Radian version: @ref{COS}
 
 @end table
 
@@ -3155,6 +3460,109 @@ Inverse function: @ref{ACOSH}
 
 
 
+@node COTAN
+@section @code{COTAN} --- Tangent function
+@fnindex COTAN
+@fnindex DCOTAN
+@cindex trigonometric function, cotangent
+@cindex cotangent
+
+@table @asis
+@item @emph{Description}:
+@code{COTAN(X)} computes the multiplicative inverse of the tangent of @var{X}.
+
+@item @emph{Standard}:
+None. Enabled with @option{-fdec-math}
+
+@item @emph{Class}:
+Elemental function
+
+@item @emph{Syntax}:
+@code{RESULT = COTAN(X)}
+
+@item @emph{Arguments}:
+@multitable @columnfractions .15 .70
+@item @var{X} @tab The type shall be @code{REAL}. The value must be non-zero,
+is in radians and is treated as modulo @math{2*\pi}.
+@end multitable
+
+@item @emph{Return value}:
+The return value has same type and kind as @var{X}.
+
+@item @emph{Example}:
+@smallexample
+program test_cotan
+  real(8) :: x = 0.6_8
+  x = cotan(x) ! => 1.461696
+end program test_cotan
+@end smallexample
+
+@item @emph{Specific names}:
+@multitable @columnfractions .20 .20 .20 .25
+@item Name            @tab Argument          @tab Return type     @tab Standard
+@item @code{COTAN(X)}   @tab @code{REAL(4) X}  @tab @code{REAL(4)}  @tab None
+@item @code{DCOTAN(X)}  @tab @code{REAL(8) X}  @tab @code{REAL(8)}  @tab None
+@end multitable
+
+@item @emph{See also}:
+Multiplicative inverse: @ref{TAN}
+Degree version: @ref{COTAND}
+@end table
+
+
+
+@node COTAND
+@section @code{COTAND} --- Tangent function
+@fnindex COTAND
+@fnindex DCOTAND
+@cindex trigonometric function, cotangent, degrees
+@cindex cotangent, degrees
+
+@table @asis
+@item @emph{Description}:
+@code{COTAND(X)} computes the multiplicative inverse of the tangent of @var{X},
+which is in degrees.
+
+@item @emph{Standard}:
+None. Enabled with @option{-fdec-math}
+
+@item @emph{Class}:
+Elemental function
+
+@item @emph{Syntax}:
+@code{RESULT = COTAND(X)}
+
+@item @emph{Arguments}:
+@multitable @columnfractions .15 .70
+@item @var{X} @tab The type shall be @code{REAL}. The value must be non-zero,
+is in degrees and is treated as modulo @math{360}.
+@end multitable
+
+@item @emph{Return value}:
+The return value has same type and kind as @var{X}.
+
+@item @emph{Example}:
+@smallexample
+program test_cotand
+  real(8) :: x = 0.6_8
+  x = cotan(x) ! => 95.4895
+end program test_cotand
+@end smallexample
+
+@item @emph{Specific names}:
+@multitable @columnfractions .20 .20 .20 .25
+@item Name            @tab Argument          @tab Return type     @tab Standard
+@item @code{COTAND(X)}   @tab @code{REAL(4) X}  @tab @code{REAL(4)}  @tab None
+@item @code{DCOTAND(X)}  @tab @code{REAL(8) X}  @tab @code{REAL(8)}  @tab None
+@end multitable
+
+@item @emph{See also}:
+Multiplicative inverse: @ref{TAND}
+Radian version: @ref{COTAN}
+@end table
+
+
+
 @node COUNT
 @section @code{COUNT} --- Count function
 @fnindex COUNT
@@ -11414,7 +11822,64 @@ end program test_sin
 @end multitable
 
 @item @emph{See also}:
-@ref{ASIN}
+Inverse function: @ref{ASIN}
+Degree version: @ref{SIND}
+@end table
+
+
+
+@node SIND
+@section @code{SIND} --- Sine function, degree-valued parameter
+@fnindex SIND
+@fnindex DSIND
+@fnindex CSIND
+@fnindex ZSIND
+@fnindex CDSIND
+@cindex trigonometric function, sine, degrees
+@cindex sine, degrees
+
+@table @asis
+@item @emph{Description}:
+@code{SIND(X)} computes the sine of @var{X}, which is in degrees.
+
+@item @emph{Standard}:
+None. Enabled with @option{-fdec-math}
+
+@item @emph{Class}:
+Elemental function
+
+@item @emph{Syntax}:
+@code{RESULT = SIND(X)}
+
+@item @emph{Arguments}:
+@multitable @columnfractions .15 .70
+@item @var{X} @tab The type shall be @code{REAL}. The value is in degrees and
+is treated as modulo 360.
+@end multitable
+
+@item @emph{Return value}:
+The return value is of the same type and kind as @var{X}. The result is in
+radians. The return value lies in the range
+@math{-1} @leq{} @math{\cos (x)} @leq{} @math{1}.
+
+@item @emph{Example}:
+@smallexample
+program test_sind
+  real :: x = 45.0
+  x = sind(x) ! => 0.707
+end program test_sind
+@end smallexample
+
+@item @emph{Specific names}:
+@multitable @columnfractions .20 .20 .20 .25
+@item Name             @tab Argument          @tab Return type    @tab Standard
+@item @code{SIND(X)}   @tab @code{REAL(4) X}  @tab @code{REAL(4)} @tab None
+@item @code{DSIND(X)}  @tab @code{REAL(8) X}  @tab @code{REAL(8)} @tab None
+@end multitable
+
+@item @emph{See also}:
+Inverse function: @ref{ASIND}
+Radian version: @ref{SIN}
 @end table
 
 
@@ -12177,7 +12642,59 @@ end program test_tan
 @end multitable
 
 @item @emph{See also}:
-@ref{ATAN}
+Inverse function: @ref{ATAN}
+Degree version: @ref{TAND}
+@end table
+
+
+
+@node TAND
+@section @code{TAND} --- Tangent functio, degree-valued parameter
+@fnindex TAND
+@fnindex DTAND
+@cindex trigonometric function, tangent, degrees
+@cindex tangent, degrees
+
+@table @asis
+@item @emph{Description}:
+@code{TAND(X)} computes the tangent of @var{X}, which is in degrees.
+
+@item @emph{Standard}:
+None. Enabled with @option{-fdec-math}
+
+@item @emph{Class}:
+Elemental function
+
+@item @emph{Syntax}:
+@code{RESULT = TAND(X)}
+
+@item @emph{Arguments}:
+@multitable @columnfractions .15 .70
+@item @var{X} @tab The type shall be @code{REAL}. The value is in degrees and
+is treated as modulo 360.
+@end multitable
+
+@item @emph{Return value}:
+The return value has same type and kind as @var{X}.
+
+@item @emph{Example}:
+@smallexample
+program test_tand
+  real(8) :: x = 45.0_8
+  x = tand(x) ! => 1.0
+end program test_tand
+@end smallexample
+
+@item @emph{Specific names}:
+@multitable @columnfractions .20 .20 .20 .25
+@item Name            @tab Argument          @tab Return type     @tab Standard
+@item @code{TAND(X)}   @tab @code{REAL(4) X}  @tab @code{REAL(4)}  @tab None
+@item @code{DTAND(X)}  @tab @code{REAL(8) X}  @tab @code{REAL(8)}  @tab None
+@end multitable
+
+@item @emph{See also}:
+Inverse function: @ref{ATAND}
+Radian version: @ref{TAN}
 @end table
 
 
diff --git a/gcc/fortran/invoke.texi b/gcc/fortran/invoke.texi
index b0b43d8..6828d8c 100644
--- a/gcc/fortran/invoke.texi
+++ b/gcc/fortran/invoke.texi
@@ -115,13 +115,17 @@ by type.  Explanations are in the following sections.
 @item Fortran Language Options
 @xref{Fortran Dialect Options,,Options controlling Fortran dialect}.
 @gccoptlist{-fall-intrinsics -fbackslash -fcray-pointer -fd-lines-as-code @gol
--fd-lines-as-comments -fdefault-double-8 -fdefault-integer-8 @gol
--fdefault-real-8 -fdollar-ok -ffixed-line-length-@var{n} @gol
--ffixed-line-length-none -ffree-form -ffree-line-length-@var{n} @gol
--ffree-line-length-none -fimplicit-none -finteger-4-integer-8 @gol
--fmax-identifier-length -fmodule-private -fno-fixed-form -fno-range-check @gol
--fopenmp -freal-4-real-10 -freal-4-real-16 -freal-4-real-8 @gol
--freal-8-real-10 -freal-8-real-16 -freal-8-real-4 -std=@var{std}
+-fd-lines-as-comments @gol
+-fdec -fdec-extended-int -fdec-member-dot -fdec-structure -fdec-math @gol
+-fdec-logical-xor -fdec-bitwise-ops -fdec-io fdec-intrinsic-ints -ffeed @gol
+-fdec-static @gol
+-fdefault-double-8 -fdefault-integer-8 -fdefault-real-8 -fdollar-ok @gol
+-ffixed-line-length-@var{n} -ffixed-line-length-none -ffree-form @gol
+-ffree-line-length-@var{n} -ffree-line-length-none -fimplicit-none @gol
+-finteger-4-integer-8 -floc-rval -fmax-identifier-length -fmodule-private @gol
+-fno-fixed-form -fno-range-check -fopenmp -freal-4-real-10 @gol
+-freal-4-real-16 -freal-4-real-8 -freal-8-real-10 -freal-8-real-16 @gol
+-freal-8-real-4 -std=@var{std}
 }
 
 @item Preprocessing Options
@@ -178,6 +182,7 @@ and warnings}.
 -finit-character=@var{n} -finit-integer=@var{n} -finit-local-zero @gol
 -finit-logical=@var{<true|false>}
 -finit-real=@var{<zero|inf|-inf|nan|snan>} @gol
+-finit-derived @gol
 -fmax-array-constructor=@var{n} -fmax-stack-var-size=@var{n}
 -fno-align-commons @gol
 -fno-automatic -fno-protect-parens -fno-underscoring -fno-whole-file @gol
@@ -227,6 +232,72 @@ given they are treated as if the first column contained a blank.  If the
 @option{-fd-lines-as-comments} option is given, they are treated as
 comment lines.
 
+@item -fdec
+@opindex @code{fdec}
+Enable all supported Digital Equipment Corporation (DEC) extensions.
+These extensions are non-standard and should be avoided when possible.
+For details on GNU Fortran's implementation of these extensions see the 
+full documentation.
+
+The options enabled by this switch are: @option{-fdollar-ok} 
+@option{-fdec-structure} @option{-fdec-member-dot} @option{-fdec-extended-int}
+@option{-fdec-math} @option{-fdec-logical-xor} @option{-fdec-bitwise-ops}
+@option{-fd-lines-as-comments} @option{-fdec-io} @option{-ffeed}
+@option{-fdec-intrinsic-ints} @option{-fdec-static}
+
+@item -fdec-intrinsic-ints
+@opindex @code{fdec-intrinsic-ints}
+Enable B/I/J/K kind variants for integer intrinsics. For a list of supported
+intrinsics see the full documentation.
+
+@item -fdec-bitwise-ops
+@opindex @code{fdec-bitwise-ops}
+When at least one operand of a logical operator is an integer, convert both
+operands to an integer and instead use the corresponding bitwise operator.
+For example, 5 @code{.AND.} 4 is converted to @code{IAND}(5, 4) and returns 4.
+
+@item -fdec-extended-int
+@opindex @code{fdec-extended-int}
+Enable the DEC extended integer constant format. This format allows integer
+constants with bases between 2 and 36 to be specified in the "base#value"
+format.
+
+@item -fdec-io
+@opindex @code{fdec-io}
+Enable DEC extended IO syntax. This includes the @code{READONLY},
+@code{SHARED}, and @code{CARRAIGECONTROL} specifiers in @code{OPEN} statements.
+
+@item -fdec-member-dot
+@opindex @code{fdec-member-dot}
+Enable dot (@code{.}) as a member separator (in addition to the usual @code{%}).
+This is enabled automatically with @option{-fdec-structure}.
+
+@item -fdec-static
+@opindex @code{fdec-static}
+Enable @code{STATIC} and @code{AUTOMATIC} as attributes specifying storage
+location. For GNU Fortran, @code{STATIC} is the same as @code{SAVE} and local
+variables are @code{AUTOMATIC} by default, unless @option{-fno-automatic} is
+used.
+
+@item -fdec-structure
+@opindex @code{fdec-structure}
+Enable DEC old-style @code{STRUCTURE} and @code{RECORD}. This is provided for
+compatibility; Fortran 90 derived types should be used instead where
+possible. This implies @option{-fdec-member-dot}.
+
+@item -fdec-logical-xor
+@opindex @code{fdec-logical-xor}
+Enable the logical @code{.XOR.} function (same as @code{.NEQV.}).
+
+@item -fdec-math
+@opindex @code{fdec-math}
+Enable extra math intrinsics, such as degree-valued trig functions.
+For a list of supported intrinsics see the full documentation.
+
+@item -ffeed
+@opindex @code{ffeed}
+Treat form feed (@code{\f}) characters as whitespace in the source.
+
 @item -fdefault-double-8
 @opindex @code{fdefault-double-8}
 Set the @code{DOUBLE PRECISION} type to an 8 byte wide type.  If
@@ -309,6 +380,11 @@ lines in the source file. The default value is 132.
 @option{-ffree-line-length-0} means the same thing as
 @option{-ffree-line-length-none}.
 
+@item -floc-rval
+@opindex @code{floc-rval}
+Enable the recognition of the %LOC() function as an rvalue. That is, it can
+be used just like the intrinsic LOC() function.
+
 @item -fmax-identifier-length=@var{n}
 @opindex @code{fmax-identifier-length=}@var{n}
 Specify the maximum allowed identifier length. Typical values are
@@ -1518,11 +1594,13 @@ on the stack. This flag cannot be used together with
 @option{-fmax-stack-var-size=} or @option{-fno-automatic}.
 
 @item -finit-local-zero
+@itemx -finit-derived
 @itemx -finit-integer=@var{n}
 @itemx -finit-real=@var{<zero|inf|-inf|nan|snan>}
 @itemx -finit-logical=@var{<true|false>}
 @itemx -finit-character=@var{n}
 @opindex @code{finit-local-zero}
+@opindex @code{finit-derived}
 @opindex @code{finit-integer}
 @opindex @code{finit-real}
 @opindex @code{finit-logical}
@@ -1537,7 +1615,7 @@ initialization options are provided by the
 the real and imaginary parts of local @code{COMPLEX} variables),
 @option{-finit-logical=@var{<true|false>}}, and
 @option{-finit-character=@var{n}} (where @var{n} is an ASCII character
-value) options.  These options do not initialize
+value) options.  By default these options do not initialize
 @itemize @bullet
 @item
 allocatable arrays
@@ -1546,7 +1624,8 @@ components of derived type variables
 @item
 variables that appear in an @code{EQUIVALENCE} statement.
 @end itemize
-(These limitations may be removed in future releases).
+Components of derived type variables will be initialized with the values from
+these flags only with @option{-finit-derived}.
 
 Note that the @option{-finit-real=nan} option initializes @code{REAL}
 and @code{COMPLEX} variables with a quiet NaN. For a signalling NaN
diff --git a/gcc/fortran/io.c b/gcc/fortran/io.c
index 1d46474..83dee53 100644
--- a/gcc/fortran/io.c
+++ b/gcc/fortran/io.c
@@ -38,6 +38,12 @@ typedef struct
 io_tag;
 
 static const io_tag
+        tag_readonly    = {"READONLY", " readonly", NULL, BT_UNKNOWN },
+        tag_shared      = {"SHARED", " shared", NULL, BT_UNKNOWN },
+        tag_noshared    = {"NOSHARED", " noshared", NULL, BT_UNKNOWN },
+        tag_cc          = {"CARRIAGECONTROL",
+                           " carriagecontrol =", " %e", BT_CHARACTER },
+        tag_e_share     = {"SHARE", " share =", " %e", BT_CHARACTER },
 	tag_file	= {"FILE", " file =", " %e", BT_CHARACTER },
 	tag_status	= {"STATUS", " status =", " %e", BT_CHARACTER},
 	tag_e_access	= {"ACCESS", " access =", " %e", BT_CHARACTER},
@@ -1374,6 +1380,92 @@ match_ltag (const io_tag *tag, gfc_st_label ** label)
 }
 
 
+/* Match a tag using match_etag, but only if -fdec-io is enabled. 
+   Gives a nice error if the tag was matched but -fdec-io is not on. */
+static match
+match_dec_etag (const io_tag *tag, gfc_expr **e)
+{
+  match m = match_etag (tag, e);
+  if (gfc_option.flag_dec_io && m != MATCH_NO)
+    return m;
+  else if (m != MATCH_NO)
+  {
+    gfc_error ("%s is a DEC extension at %C, re-compile with"
+               "-fdec-io to enable", tag->name);
+    return MATCH_ERROR;
+  }
+
+  return m;
+}
+
+/* Match a flag tag (tag with no var/expr association, such as READONLY).
+   The open object is messed with accordingly. */
+
+static match
+match_dec_ftag (const io_tag *tag, gfc_open *o)
+{
+  match m;
+  locus *where;
+  const int ch_kind = gfc_default_character_kind;
+
+  m = gfc_match (tag->spec);
+  if (m != MATCH_YES)
+    return m;
+
+  where = &gfc_current_locus;
+
+  if (!gfc_option.flag_dec_io)
+  {
+    gfc_error ("%s is a DEC extension at %C, re-compile with"
+               "-fdec-io to enable", tag->name);
+    return MATCH_ERROR;
+  }
+
+  /* Interpret READONLY as ACTION='READ' */
+  if (tag == &tag_readonly)
+  {
+    if (o->action)
+    {
+      gfc_error ("Cannot specify READONLY and ACTION together at %C"
+                 "(ACTION specified at %L)", &o->action->where);
+      return MATCH_ERROR;
+    }
+    o->action = gfc_get_character_expr (ch_kind, where, "read", 4);
+    o->readonly |= 1;
+    return MATCH_YES;
+  }
+
+  /* Interpret SHARED as SHARE='DENYNONE' (read lock) */
+  if (tag == &tag_shared)
+  {
+    if (o->share)
+    {
+      gfc_error ("Duplicate SHARE specification at %C "
+                 "(previously specified at %L)", &o->share->where);
+      return MATCH_ERROR;
+    }
+    o->share = gfc_get_character_expr (ch_kind, where, "denynone", 8);
+    return MATCH_YES;
+  }
+
+  /* Interpret NOSHARED as SHARE='DENYRW' (exclusive lock) */
+  if (tag == &tag_noshared)
+  {
+    if (o->share)
+    {
+      gfc_error ("Duplicate SHARE specification at %C "
+                 "(previously specified at %L)", &o->share->where);
+      return MATCH_ERROR;
+    }
+    o->share = gfc_get_character_expr (ch_kind, where, "denyrw", 6);
+    return MATCH_YES;
+  }
+
+  gfc_internal_error ("match_dectag(): Unhandled tag");
+  return MATCH_ERROR;
+}
+
+
 /* Resolution of the FORMAT tag, to be called from resolve_tag.  */
 
 static gfc_try
@@ -1620,6 +1712,23 @@ match_open_element (gfc_open *open)
   if (m != MATCH_NO)
     return m;
 
+  /* The following are DEC extensions. */
+  m = match_dec_etag (&tag_e_share, &open->share);
+  if (m != MATCH_NO)
+    return m;
+  m = match_dec_etag (&tag_cc, &open->cc);
+  if (m != MATCH_NO)
+    return m;
+  m = match_dec_ftag (&tag_readonly, open);
+  if (m != MATCH_NO)
+    return m;
+  m = match_dec_ftag (&tag_shared, open);
+  if (m != MATCH_NO)
+    return m;
+  m = match_dec_ftag (&tag_noshared, open);
+  if (m != MATCH_NO)
+    return m;
+
   return MATCH_NO;
 }
 
@@ -1652,6 +1761,8 @@ gfc_free_open (gfc_open *open)
   gfc_free_expr (open->convert);
   gfc_free_expr (open->asynchronous);
   gfc_free_expr (open->newunit);
+  gfc_free_expr (open->share);
+  gfc_free_expr (open->cc);
   free (open);
 }
 
@@ -1682,6 +1793,8 @@ gfc_resolve_open (gfc_open *open)
   RESOLVE_TAG (&tag_e_sign, open->sign);
   RESOLVE_TAG (&tag_convert, open->convert);
   RESOLVE_TAG (&tag_newunit, open->newunit);
+  RESOLVE_TAG (&tag_e_share, open->share);
+  RESOLVE_TAG (&tag_cc, open->cc);
 
   if (gfc_reference_st_label (open->err, ST_LABEL_TARGET) == FAILURE)
     return FAILURE;
@@ -1928,6 +2041,17 @@ gfc_match_open (void)
 	}
     }
 
+  /* Checks on the CARRIAGECONTROL specifier. */
+  if (open->cc)
+    {
+      static const char *cc[] = { "LIST", "FORTRAN", "NONE", NULL };
+
+      if (!compare_to_allowed_values ("CARRIAGECONTROL", cc, NULL, NULL,
+                                      open->cc->value.character.string,
+                                      "OPEN", warn))
+        goto cleanup;
+    }
+
   /* Checks on the DECIMAL specifier.  */
   if (open->decimal)
     {
@@ -2069,6 +2193,17 @@ gfc_match_open (void)
       warn_or_error ("RECL in OPEN statement at %C must be positive");
     }
 
+  /* Checks on the SHARE specifier. */
+  if (open->share && open->share->expr_type == EXPR_CONSTANT)
+    {
+      static const char *share[] = { "DENYNONE", "DENYRW", NULL };
+
+      if (!compare_to_allowed_values ("SHARE", share, NULL, NULL,
+                                      open->share->value.character.string,
+                                      "OPEN", warn))
+        goto cleanup;
+    }
+
   /* Checks on the STATUS specifier.  */
   if (open->status && open->status->expr_type == EXPR_CONSTANT)
     {
@@ -2258,6 +2393,8 @@ gfc_match_close (void)
   /* Checks on the STATUS specifier.  */
   if (close->status && close->status->expr_type == EXPR_CONSTANT)
     {
+      /* TODO: Protect READONLY from DELETE
+         Implement some of SAVE, PRINT, SUBMIT, PRINT/DELETE, SUBMIT/DELETE */
       static const char *status[] = { "KEEP", "DELETE", NULL };
 
       if (!compare_to_allowed_values ("STATUS", status, NULL, NULL,
diff --git a/gcc/fortran/ioparm.def b/gcc/fortran/ioparm.def
index 2499c90..42f5649 100644
--- a/gcc/fortran/ioparm.def
+++ b/gcc/fortran/ioparm.def
@@ -50,6 +50,9 @@ IOPARM (open,    round,		1 << 20, char2)
 IOPARM (open,    sign,		1 << 21, char1)
 IOPARM (open,    asynchronous,	1 << 22, char2)
 IOPARM (open,    newunit,	1 << 23, pint4)
+IOPARM (open,    readonly,      1 << 24, int4)
+IOPARM (open,    share,         1 << 25, char1)
+IOPARM (open,    cc,            1 << 26, char2)
 IOPARM (close,   common,	0,	 common)
 IOPARM (close,   status,	1 << 7,  char1)
 IOPARM (filepos, common,	0,	 common)
diff --git a/gcc/fortran/lang.opt b/gcc/fortran/lang.opt
index fbe8a1b..0fbca87 100644
--- a/gcc/fortran/lang.opt
+++ b/gcc/fortran/lang.opt
@@ -373,6 +373,46 @@ fd-lines-as-comments
 Fortran RejectNegative
 Treat lines with 'D' in column one as comments
 
+fdec
+Fortran
+Enable all DEC/Intel language extensions.
+
+fdec-intrinsic-ints
+Fortran
+Enable kind-specific variants of integer intrinsic functions.
+
+fdec-bitwise-ops
+Fortran
+Use bitwise operators when logical operators are used with int operands.
+
+fdec-extended-int
+Fortran
+Enable extended base#value integer constants
+
+fdec-io
+Fortran
+Enable DEC IO extensions
+
+fdec-logical-xor
+Fortran
+Enable the logical .XOR. operator.
+
+fdec-math
+Fortran
+Enable additional builtin math functions.
+
+fdec-member-dot
+Fortran
+Enable dot (`.`) as a member separator (in addition to the usual `%`).
+
+fdec-static
+Fortran
+Enable STATIC and AUTOMATIC attributes.
+
+fdec-structure
+Fortran
+Enable DEC STRUCTURE extension.
+
 fdefault-double-8
 Fortran
 Set the default double precision kind to an 8 byte wide type
@@ -413,6 +453,10 @@ ff2c
 Fortran
 Use f2c calling convention
 
+ffeed
+Fortran
+Enable form feeds in source
+
 ffixed-form
 Fortran RejectNegative
 Assume that the source file is fixed form
@@ -481,6 +525,14 @@ finit-real=
 Fortran RejectNegative Joined
 -finit-real=<zero|nan|inf|-inf>	Initialize local real variables
 
+finit-derived
+Fortran
+Automatically initialize local derived type variables
+
+floc-rval
+Fortran
+Enable the use of %LOC as an rvalue, like the built-in LOC().
+
 fmax-array-constructor=
 Fortran RejectNegative Joined UInteger
 -fmax-array-constructor=<n>	Maximum number of objects in an array constructor
diff --git a/gcc/fortran/libgfortran.h b/gcc/fortran/libgfortran.h
index 30b3b7b..ef70478 100644
--- a/gcc/fortran/libgfortran.h
+++ b/gcc/fortran/libgfortran.h
@@ -128,7 +128,7 @@ libgfortran_stat_codes;
    used in the run-time library for IO.  */
 typedef enum
 { BT_UNKNOWN = 0, BT_INTEGER, BT_LOGICAL, BT_REAL, BT_COMPLEX,
-  BT_DERIVED, BT_CHARACTER, BT_CLASS, BT_PROCEDURE, BT_HOLLERITH, BT_VOID,
-  BT_ASSUMED
+  BT_DERIVED, BT_CHARACTER, BT_CLASS, BT_PROCEDURE, BT_HOLLERITH, BT_UNION,
+  BT_VOID, BT_ASSUMED
 }
 bt;
diff --git a/gcc/fortran/match.c b/gcc/fortran/match.c
index 9827b6c..dea6c49 100644
--- a/gcc/fortran/match.c
+++ b/gcc/fortran/match.c
@@ -111,6 +111,126 @@ gfc_op2string (gfc_intrinsic_op op)
 
 /******************** Generic matching subroutines ************************/
 
+/* Matches a member separator. With F90+ this is '%', but with
+   -fdec-member-dot we must carefully match dot ('.').
+   Because operators are spelled ".op.", "x.y.z" can be either a component
+   access (x->y)->z or a binary operation y(x,z). Here we choose to deal with
+   the "x.y.z" ambiguity in a manner consistent with Intel:
+     (1) If any user defined operator ".y." exists, this is always y(x,z)
+         (even if ".y." is the wrong type and/or x has a member y).
+     (2) Otherwise if x has a member y, and y is itself a derived type,
+         this is (x->y)->z, even if an intrinsic operator exists which 
+         can handle (x,z). 
+     (3) If x has no member y or (x->y) is not a derived type but ".y." 
+         is an intrinsic operator (such as ".eq."), this is y(x,z).
+     (4) Lastly if there is no operator ".y." and x has no member "y", it is an
+         error.  
+   It is worth noting that [fortunately] Intel does not support mixed use of
+   member accessors within a single string, nor does it support parenthesised
+   member accesses (therefore neither do we).
+   That is, even if x has component y and y has component z, the following
+   are all syntax errors:  "x%y.z"  "x.y%z"  "(x.y).z"  "(x%y)%z"
+ */
+
+match
+gfc_match_member_sep(gfc_symbol *sym)
+{
+    char name[GFC_MAX_SYMBOL_LEN + 1];
+    locus dot_loc, start_loc;
+    gfc_intrinsic_op iop;
+    match m;
+    gfc_symbol *tsym;
+    gfc_component *c;
+
+    /* Thank god; '%' is an unambiguous member separator. */
+    if (gfc_match_char ('%') == MATCH_YES)
+        return MATCH_YES;
+
+    /* Only continue if dot member separators are enabled. */
+    if (!gfc_option.flag_dec_member_dot || !sym)
+        return MATCH_NO;
+
+    tsym = NULL;
+
+    /* We may be given either a derived type variable or the derived type
+       declaration itself (which actually contains the components); 
+       if this is a member access we need the latter to check components. */
+    if (gfc_fl_struct (sym->attr.flavor))
+        tsym = sym;
+    else if (gfc_bt_struct (sym->ts.type))
+        tsym = sym->ts.u.derived;
+    else
+        return MATCH_NO;
+
+    iop = INTRINSIC_NONE;
+    name[0] = '\0';
+    m = MATCH_NO;
+
+    /* If we have to reject, come back here later. */
+    start_loc = gfc_current_locus;
+
+    /* Look for a component access next. */
+    if (gfc_match_char ('.') != MATCH_YES)
+        return MATCH_NO;
+
+    /* If we accept, come back here. */
+    dot_loc = gfc_current_locus;
+
+    /* Try to match a symbol name following '.' */
+    if (gfc_match_name (name) != MATCH_YES)
+    {
+        gfc_error ("Expected structure component or operator name "
+                   "after '.' at %C");
+        goto error;
+    }
+
+    /* If no dot follows we have "x.y" which must be a component access.
+       Ensure the leading symbol is a derived type variable. */
+    if (gfc_match_char ('.') != MATCH_YES)
+        goto yes;
+
+    /* Now we have a string "x.y.z" which could be a nested member access
+       (x->y)->z or a binary operation y on x and z. */
+
+    /* First use any user-defined operators ".y." */
+    if (gfc_find_uop (name, sym->ns) != NULL)
+        goto no;
+
+    /* Match accesses to existing derived-type components for 
+       derived-type vars: "x.y.z" = (x->y)->z */
+    c = gfc_find_component(tsym, name, false, true, NULL);
+    if (c && (c->ts.type == BT_DERIVED || c->ts.type == BT_CLASS))
+        goto yes;
+
+    /* If y is not a component or has no members, try intrinsic operators. */
+    gfc_current_locus = start_loc;
+    if (gfc_match_intrinsic_op (&iop) != MATCH_YES)
+    {
+        /* If ".y." is not an intrinsic operator but y was a valid non-
+           structure component, match and leave the trailing dot to be 
+           dealt with later. */
+        if (c)
+            goto yes;
+
+        gfc_error ("'%s' is neither a defined operator nor a "
+                   "structure component in dotted string at %C", name);
+        goto error;
+    }
+
+    /* .y. is an intrinsic operator, overriding any possible member access. */
+    goto no;
+
+    /* Return keeping the current locus consistent with the match result. */
+error:
+    m = MATCH_ERROR;
+no:
+    gfc_current_locus = start_loc;
+    return m;
+yes:
+    gfc_current_locus = dot_loc;
+    return MATCH_YES;
+}
+
 /* This function scans the current statement counting the opened and closed
    parenthesis to make sure they are balanced.  */
 
@@ -320,6 +440,219 @@ gfc_match_eos (void)
   return (flag) ? MATCH_YES : MATCH_NO;
 }
 
+/* As with gfc_check_digit, but allow any radix in [2,36]. */
+
+static int
+check_digit_extended (char c, int radix)
+{
+  int r = 0;
+  if (radix < 2 || radix > 36)
+      gfc_internal_error ("check_digit_extended(): bad radix");
+  else if (radix <= 10)
+      r = '0' <= c && c < ('0'+radix);
+  else
+      r =    ('0' <= c && c < ('0' +   radix   ))
+          || ('a' <= c && c < ('a' + (radix-10)));
+
+  return r;
+}
+
+/* Given a character and a radix, see if the character is a valid
+   digit in that radix.  */
+
+int
+gfc_check_digit (char c, int radix)
+{
+  int r;
+
+  if (gfc_option.flag_dec_extended_int)
+      return check_digit_extended (c, radix);
+
+  switch (radix)
+    {
+    case 2:
+      r = ('0' <= c && c <= '1');
+      break;
+
+    case 8:
+      r = ('0' <= c && c <= '7');
+      break;
+
+    case 10:
+      r = ('0' <= c && c <= '9');
+      break;
+
+    case 16:
+      r = ISXDIGIT (c);
+      break;
+
+    default:
+      gfc_internal_error ("gfc_check_digit(): bad radix");
+    }
+
+  return r;
+}
+
+/* Matches '+' or '-', and sets sign to 1 or -1 respectively if not NULL. */
+
+match
+gfc_match_sign (int *sign)
+{
+    match m;
+    if ((m = gfc_match_char ('+')) == MATCH_YES && sign)
+        *sign = 1;
+    else if ((m = gfc_match_char ('-')) == MATCH_YES && sign)
+        *sign = -1;
+    return m;
+}
+
+/* Match a radix as a base 10 number between 2 and 36. On MATCH_YES set
+   *radixp to the result if not NULL. (If NULL, still matches a radix.) */
+
+match
+gfc_match_radix (int *radixp)
+{
+    char radixbuf[3] = {'\0', '\0', '\0'};
+    locus old_loc;
+    int length, radix;
+    match m;
+
+    /* Get the length of a potential radix. */
+    old_loc = gfc_current_locus;
+    m = gfc_match_literal_int (NULL, 10, &length);
+    if (m != MATCH_YES)
+        return m;
+    gfc_current_locus = old_loc;
+
+    /* Base can't have more than two digits. */
+    if (length > 2)
+    {
+        gfc_error ("Base too large at %C");
+        return MATCH_ERROR;
+    }
+
+    gcc_assert (gfc_match_literal_int (radixbuf, 10, NULL) == MATCH_YES);
+    radix = atoi(radixbuf);
+
+    if (radix < 2 || radix > 36)
+    {
+        gfc_error ("Base '%d' out of range at %C", radix);
+        return MATCH_ERROR;
+    }
+
+    if (radixp)
+        *radixp = atoi (radixbuf);
+
+    return MATCH_YES;
+}
+
+/* Match the digit string part of an integer. If the buffer 
+   is NULL, we just count characters for the resolution pass returned
+   in *cnt (if not NULL). Returns whether an integer was successfully matched
+   using the given radix. */
+
+match
+gfc_match_literal_int (char *buffer, int radix, int *cnt)
+{
+  locus old_loc;
+  int length;
+  char c;
+  match m;
+
+  length = 0;
+  m = MATCH_YES;
+  old_loc = gfc_current_locus;
+  c = gfc_next_ascii_char ();
+
+  if (!gfc_check_digit (c, radix))
+  {
+    length = -1;
+    m = MATCH_NO;
+    goto done;
+  }
+
+  length++;
+  if (buffer != NULL)
+    *buffer++ = c;
+
+  for (;;)
+    {
+      old_loc = gfc_current_locus;
+      c = gfc_next_ascii_char ();
+
+      if (!gfc_check_digit (c, radix))
+	break;
+
+      if (buffer != NULL)
+	*buffer++ = c;
+      length++;
+    }
+
+
+done:
+  gfc_current_locus = old_loc;
+  if (cnt)
+      *cnt = length;
+  /* If digit belongs to another radix, we can give some helpful information */
+  if (gfc_option.flag_dec_extended_int && check_digit_extended (c, 36))
+      gfc_error ("Invalid digit '%c' in base %d integer constant at %C",
+                 c, radix);
+  return m;
+}
+
+/* Match a DEC extended 'base#value' integer if -fdec-extended-int is
+   enabled. 
+   On MATCH_YES, if not NULL:
+     buffer -> the value string
+     *radix -> the radix of the value
+     *cnt   -> the length of the value string */
+
+match
+gfc_match_extended_integer (char *buffer, int *radix, int *cnt)
+{
+  match m;
+  int base, length;
+  locus old_loc;
+  
+  base = 10;
+  old_loc = gfc_current_locus;
+  gfc_gobble_whitespace ();
+  m = gfc_match_literal_int (buffer, 10, &length);
+
+  /* If we see a '#' this is an extended base#val int; otherwise the number we
+     just matched is the number. */
+  if (gfc_peek_ascii_char () == '#' && gfc_option.flag_dec_extended_int)
+  {
+      gfc_current_locus = old_loc;
+      base = 16;
+      /* If no radix is found we default to 16. Out-of-range is an error. */
+      if (gfc_match_radix (&base) == MATCH_ERROR)
+          return MATCH_ERROR;
+      gcc_assert (gfc_match_char ('#') == MATCH_YES);
+
+      old_loc = gfc_current_locus;
+      m = gfc_match_literal_int (buffer, base, &length);
+      if (buffer)
+          buffer[length] = '\0';
+      if (m != MATCH_YES)
+      {
+          gfc_current_locus = old_loc;
+          gfc_error ("Expected base %d integer after '#' in extended integer "
+                     "constant at %C", base);
+          return MATCH_ERROR;
+      }
+  }
+
+  if (m == MATCH_YES)
+  {
+      if (radix)
+          *radix = base;
+      if (cnt)
+          *cnt = length;
+  }
+
+  return m;
+}
 
 /* Match a literal integer on the input, setting the value on
    MATCH_YES.  Literal ints occur in kind-parameters as well as
@@ -920,6 +1253,18 @@ gfc_match_intrinsic_op (gfc_intrinsic_op *result)
 	    }
 	  break;
 
+        case 'x':
+          if (gfc_option.flag_dec_logical_xor
+              && gfc_next_ascii_char () == 'o'
+              && gfc_next_ascii_char () == 'r'
+              && gfc_next_ascii_char () == '.')
+            {
+              /* Matched ".xor." -> equivalent to ".neqv." */
+              *result = INTRINSIC_NEQV;
+              return MATCH_YES;
+            }
+          break;
+
 	default:
 	  break;
 	}
@@ -1920,7 +2265,7 @@ match_derived_type_spec (gfc_typespec *ts)
   if (derived && derived->attr.flavor == FL_PROCEDURE && derived->attr.generic)
     derived = gfc_find_dt_in_generic (derived);
 
-  if (derived && derived->attr.flavor == FL_DERIVED)
+  if (derived && gfc_fl_struct (derived->attr.flavor))
     {
       ts->type = BT_DERIVED;
       ts->u.derived = derived;
@@ -5222,7 +5567,7 @@ select_intrinsic_set_tmp (gfc_typespec *ts)
   gfc_symtree *tmp;
   int charlen = 0;
 
-  if (ts->type == BT_CLASS || ts->type == BT_DERIVED)
+  if (ts->type == BT_CLASS || gfc_bt_struct (ts->type))
     return NULL;
 
   if (select_type_stack->selector->ts.type == BT_CLASS
diff --git a/gcc/fortran/match.h b/gcc/fortran/match.h
index 48aa405..d5b77ce 100644
--- a/gcc/fortran/match.h
+++ b/gcc/fortran/match.h
@@ -45,6 +45,10 @@ extern gfc_access gfc_typebound_default_access;
 match gfc_match_special_char (gfc_char_t *);
 match gfc_match_space (void);
 match gfc_match_eos (void);
+match gfc_match_literal_int (char *, int, int *);
+match gfc_match_extended_integer (char *, int *, int *);
+match gfc_match_radix (int *);
+match gfc_match_sign (int *);
 match gfc_match_small_literal_int (int *, int *);
 match gfc_match_st_label (gfc_st_label **);
 match gfc_match_label (void);
@@ -59,6 +63,7 @@ match gfc_match_char (char);
 match gfc_match (const char *, ...);
 match gfc_match_iterator (gfc_iterator *, int);
 match gfc_match_parens (void);
+match gfc_match_member_sep(gfc_symbol *);
 
 /* Statement matchers.  */
 match gfc_match_program (void);
@@ -159,6 +164,9 @@ match gfc_match_generic (void);
 match gfc_match_function_decl (void);
 match gfc_match_entry (void);
 match gfc_match_subroutine (void);
+match gfc_match_map (void);
+match gfc_match_union (void);
+match gfc_match_structure_decl (void);
 match gfc_match_derived_decl (void);
 match gfc_match_final_decl (void);
 
@@ -184,6 +192,8 @@ match gfc_match_pointer (void);
 match gfc_match_protected (void);
 match gfc_match_private (gfc_statement *);
 match gfc_match_public (gfc_statement *);
+match gfc_match_automatic (void);
+match gfc_match_static (void);
 match gfc_match_save (void);
 match gfc_match_modproc (void);
 match gfc_match_target (void);
@@ -191,6 +201,7 @@ match gfc_match_value (void);
 match gfc_match_volatile (void);
 
 /* decl.c.  */
+match gfc_match_clist_expr (gfc_expr **, gfc_typespec *, bool);
 
 /* Fortran 2003 c interop.
    TODO: some of these should be moved to another file rather than decl.c */
diff --git a/gcc/fortran/mathbuiltins.def b/gcc/fortran/mathbuiltins.def
index 8236d5c..ea4403a 100644
--- a/gcc/fortran/mathbuiltins.def
+++ b/gcc/fortran/mathbuiltins.def
@@ -70,3 +70,10 @@ OTHER_BUILTIN (POW,       "pow",       1,       true)
 OTHER_BUILTIN (ROUND,     "round",     1,       true)
 OTHER_BUILTIN (SCALBN,    "scalbn",    scalbn,  true)
 OTHER_BUILTIN (TRUNC,     "trunc",     1,       true)
+
+/* MATH_ALIAS_BUILTIN (NEWID, OLDID, NAME, ARGTYPE)
+   NEWID  The new id of the builtin (to match GFC_ISYM_* in gfortran.h)
+   OLDID  The id of the actual builtin to alias ""
+   NAME   Te name of the new builtin
+   ARGTYPE The type of the arguments, to match that of OLDID */
+MATH_ALIAS_BUILTIN (COTAN, TAN, "tan", 0)
diff --git a/gcc/fortran/misc.c b/gcc/fortran/misc.c
index cce599b..8e097e1 100644
--- a/gcc/fortran/misc.c
+++ b/gcc/fortran/misc.c
@@ -92,6 +92,9 @@ gfc_basic_typename (bt type)
     case BT_HOLLERITH:
       p = "HOLLERITH";
       break;
+    case BT_UNION:
+      p = "UNION";
+      break;
     case BT_DERIVED:
       p = "DERIVED";
       break;
@@ -153,6 +156,9 @@ gfc_typename (gfc_typespec *ts)
     case BT_HOLLERITH:
       sprintf (buffer, "HOLLERITH");
       break;
+    case BT_UNION:
+      sprintf (buffer, "UNION(%s)", ts->u.derived->name);
+      break;
     case BT_DERIVED:
       sprintf (buffer, "TYPE(%s)", ts->u.derived->name);
       break;
diff --git a/gcc/fortran/module.c b/gcc/fortran/module.c
index c267ee7..1acb997 100644
--- a/gcc/fortran/module.c
+++ b/gcc/fortran/module.c
@@ -406,8 +406,8 @@ resolve_fixups (fixup_t *f, void *gp)
    to convert the symtree name of a derived-type to the symbol name or to
    the name of the associated generic function.  */
 
-static const char *
-dt_lower_string (const char *name)
+const char *
+gfc_dt_lower_string (const char *name)
 {
   if (name[0] != (char) TOLOWER ((unsigned char) name[0]))
     return gfc_get_string ("%c%s", (char) TOLOWER ((unsigned char) name[0]),
@@ -421,8 +421,8 @@ dt_lower_string (const char *name)
    symtree/symbol name of the associated generic function start with a lower-
    case character.  */
 
-static const char *
-dt_upper_string (const char *name)
+const char *
+gfc_dt_upper_string (const char *name)
 {
   if (name[0] != (char) TOUPPER ((unsigned char) name[0]))
     return gfc_get_string ("%c%s", (char) TOUPPER ((unsigned char) name[0]),
@@ -724,7 +724,7 @@ find_use_name_n (const char *name, int *inst, bool interface)
 
   /* For derived types.  */
   if (name[0] != (char) TOLOWER ((unsigned char) name[0]))
-    low_name = dt_lower_string (name);
+    low_name = gfc_dt_lower_string (name);
 
   i = 0;
   for (u = gfc_rename_list; u; u = u->next)
@@ -753,7 +753,7 @@ find_use_name_n (const char *name, int *inst, bool interface)
     {
       if (u->local_name[0] == '\0')
 	return name;
-      return dt_upper_string (u->local_name);
+      return gfc_dt_upper_string (u->local_name);
     }
 
   return (u->local_name[0] != '\0') ? u->local_name : name;
@@ -881,8 +881,8 @@ add_true_name (gfc_symbol *sym)
 
   t = XCNEW (true_name);
   t->sym = sym;
-  if (sym->attr.flavor == FL_DERIVED)
-    t->name = dt_upper_string (sym->name);
+  if (gfc_fl_struct (sym->attr.flavor))
+    t->name = gfc_dt_upper_string (sym->name);
   else
     t->name = sym->name;
 
@@ -903,8 +903,8 @@ build_tnt (gfc_symtree *st)
   build_tnt (st->left);
   build_tnt (st->right);
 
-  if (st->n.sym->attr.flavor == FL_DERIVED)
-    name = dt_upper_string (st->n.sym->name);
+  if (gfc_fl_struct (st->n.sym->attr.flavor))
+    name = gfc_dt_upper_string (st->n.sym->name);
   else
     name = st->n.sym->name;
 
@@ -2219,6 +2219,8 @@ static const mstring bt_types[] = {
     minit ("COMPLEX", BT_COMPLEX),
     minit ("LOGICAL", BT_LOGICAL),
     minit ("CHARACTER", BT_CHARACTER),
+    minit ("HOLLERITH", BT_HOLLERITH),
+    minit ("UNION", BT_UNION),
     minit ("DERIVED", BT_DERIVED),
     minit ("CLASS", BT_CLASS),
     minit ("PROCEDURE", BT_PROCEDURE),
@@ -2272,7 +2274,7 @@ mio_typespec (gfc_typespec *ts)
 
   ts->type = MIO_NAME (bt) (ts->type, bt_types);
 
-  if (ts->type != BT_DERIVED && ts->type != BT_CLASS)
+  if (!gfc_bt_struct (ts->type) && ts->type != BT_CLASS)
     mio_integer (&ts->kind);
   else
     mio_symbol_ref (&ts->u.derived);
@@ -3088,8 +3090,8 @@ fix_mio_expr (gfc_expr *e)
       if (e->symtree->n.sym && check_unique_name (e->symtree->name))
 	{
           const char *name = e->symtree->n.sym->name;
-	  if (e->symtree->n.sym->attr.flavor == FL_DERIVED)
-	    name = dt_upper_string (name);
+	  if (gfc_fl_struct (e->symtree->n.sym->attr.flavor))
+	    name = gfc_dt_upper_string (name);
 	  ns_st = gfc_find_symtree (gfc_current_ns->sym_root, name);
 	}
 
@@ -3779,7 +3781,7 @@ mio_symbol (gfc_symbol *sym)
   
   mio_integer (&(sym->intmod_sym_id));
 
-  if (sym->attr.flavor == FL_DERIVED)
+  if (gfc_fl_struct (sym->attr.flavor))
     mio_integer (&(sym->hash_value));
 
   mio_rparen ();
@@ -4310,7 +4312,7 @@ load_needed (pointer_info *p)
 				 1, &ns->proc_name);
 
       sym = gfc_new_symbol (p->u.rsym.true_name, ns);
-      sym->name = dt_lower_string (p->u.rsym.true_name);
+      sym->name = gfc_dt_lower_string (p->u.rsym.true_name);
       sym->module = gfc_get_string (p->u.rsym.module);
       if (p->u.rsym.binding_label)
 	sym->binding_label = IDENTIFIER_POINTER (get_identifier 
@@ -4519,7 +4521,7 @@ read_module (void)
 	 can be used in expressions in the module.  To avoid the module loading
 	 failing, we need to associate the module's component pointer indexes
 	 with the existing symbol's component pointers.  */
-      if (sym->attr.flavor == FL_DERIVED)
+      if (gfc_fl_struct (sym->attr.flavor))
 	{
 	  gfc_component *c;
 
@@ -4671,7 +4673,7 @@ read_module (void)
 		{
 		  info->u.rsym.sym = gfc_new_symbol (info->u.rsym.true_name,
 						     gfc_current_ns);
-		  info->u.rsym.sym->name = dt_lower_string (info->u.rsym.true_name);
+		  info->u.rsym.sym->name = gfc_dt_lower_string (info->u.rsym.true_name);
 		  sym = info->u.rsym.sym;
 		  sym->module = gfc_get_string (info->u.rsym.module);
 
@@ -5054,10 +5056,10 @@ write_symbol (int n, gfc_symbol *sym)
 
   mio_integer (&n);
 
-  if (sym->attr.flavor == FL_DERIVED)
+  if (gfc_fl_struct (sym->attr.flavor))
     {
       const char *name;
-      name = dt_upper_string (sym->name);
+      name = gfc_dt_upper_string (sym->name);
       mio_pool_string (&name);
     }
   else
@@ -5868,7 +5870,7 @@ create_derived_type (const char *name, const char *modname,
   sym->attr.function = 1;
   sym->attr.generic = 1;
 
-  gfc_get_sym_tree (dt_upper_string (sym->name),
+  gfc_get_sym_tree (gfc_dt_upper_string (sym->name),
 		    gfc_current_ns, &tmp_symtree, false);
   dt_sym = tmp_symtree->n.sym;
   dt_sym->name = gfc_get_string (sym->name);
diff --git a/gcc/fortran/options.c b/gcc/fortran/options.c
index fba1a3f..9ce5102 100644
--- a/gcc/fortran/options.c
+++ b/gcc/fortran/options.c
@@ -51,6 +51,25 @@ set_default_std_flags (void)
   gfc_option.warn_std = GFC_STD_F95_DEL | GFC_STD_LEGACY;
 }
 
+/* Set all the DEC extension flags. */
+
+static void
+set_dec_flags (int value)
+{
+    if (value) gfc_option.flag_dollar_ok = 1;
+    if (value) gfc_option.flag_d_lines = 0; /* -fd-lines-as-comments */
+    if (value) gfc_option.flag_loc_rval = 1;
+    gfc_option.flag_dec_extended_int = value;
+    gfc_option.flag_dec_structure  = value;
+    gfc_option.flag_dec_member_dot = value;
+    gfc_option.flag_dec_math = value;
+    gfc_option.flag_dec_logical_xor = value;
+    gfc_option.flag_dec_bitwise_ops = value;
+    gfc_option.flag_dec_io = value;
+    gfc_option.flag_dec_intrinsic_ints = value;
+    gfc_option.flag_dec_static = value;
+    gfc_option.flag_feed = value;
+}
 
 /* Return language mask for Fortran options.  */
 
@@ -155,6 +174,7 @@ gfc_init_options (unsigned int decoded_options_count,
   gfc_option.flag_init_logical = GFC_INIT_LOGICAL_OFF;
   gfc_option.flag_init_character = GFC_INIT_CHARACTER_OFF;
   gfc_option.flag_init_character_value = (char)0;
+  gfc_option.flag_init_derived = 0;
   gfc_option.flag_align_commons = 1;
   gfc_option.flag_protect_parens = -1;
   gfc_option.flag_realloc_lhs = -1;
@@ -165,6 +185,9 @@ gfc_init_options (unsigned int decoded_options_count,
   gfc_option.rtcheck = 0;
   gfc_option.coarray = GFC_FCOARRAY_NONE;
 
+  gfc_option.flag_loc_rval = 0;
+  set_dec_flags (0);
+
   set_default_std_flags ();
 
   /* Initialize cpp-related options.  */
@@ -942,6 +965,10 @@ gfc_handle_option (size_t scode, const char *arg, int value,
       gfc_option.flag_init_character_value = (char)0;
       break;
 
+    case OPT_finit_derived:
+      gfc_option.flag_init_derived = 1;
+      break;
+
     case OPT_finit_logical_:
       if (!strcasecmp (arg, "false"))
 	gfc_option.flag_init_logical = GFC_INIT_LOGICAL_FALSE;
@@ -1119,6 +1146,55 @@ gfc_handle_option (size_t scode, const char *arg, int value,
     case OPT_fcoarray_:
       gfc_handle_coarray_option (arg);
       break;
+
+    case OPT_floc_rval:
+      gfc_option.flag_loc_rval = 1;
+      break;
+
+    case OPT_fdec:
+      /* Enable all DEC extensions. */
+      set_dec_flags (1);
+      break;
+
+    case OPT_fdec_extended_int:
+      gfc_option.flag_dec_extended_int = 1;
+      break;
+
+    case OPT_fdec_structure:
+      gfc_option.flag_dec_structure = 1;
+      /* Fall-through: -fdec-structure implies -fdec-member-dot. */
+
+    case OPT_fdec_member_dot:
+      gfc_option.flag_dec_member_dot = 1;
+      break;
+
+    case OPT_fdec_math:
+      gfc_option.flag_dec_math = 1;
+      break;
+
+    case OPT_fdec_logical_xor:
+      gfc_option.flag_dec_logical_xor = 1;
+      break;
+
+    case OPT_fdec_bitwise_ops:
+      gfc_option.flag_dec_bitwise_ops = 1;
+      break;
+
+    case OPT_fdec_io:
+      gfc_option.flag_dec_io = 1;
+      break;
+
+    case OPT_fdec_intrinsic_ints:
+      gfc_option.flag_dec_intrinsic_ints = 1;
+      break;
+
+    case OPT_fdec_static:
+      gfc_option.flag_dec_static = 1;
+      break;
+
+    case OPT_ffeed:
+      gfc_option.flag_feed = 1;
+      break;
     }
 
   Fortran_handle_option_auto (&global_options, &global_options_set, 
diff --git a/gcc/fortran/parse.c b/gcc/fortran/parse.c
index f748fe3..e5658f1 100644
--- a/gcc/fortran/parse.c
+++ b/gcc/fortran/parse.c
@@ -162,6 +162,7 @@ decode_specification_statement (void)
 	     ST_INTERFACE);
       match ("allocatable", gfc_match_allocatable, ST_ATTR_DECL);
       match ("asynchronous", gfc_match_asynchronous, ST_ATTR_DECL);
+      match ("automatic", gfc_match_automatic, ST_ATTR_DECL);
       break;
 
     case 'b':
@@ -227,6 +228,8 @@ decode_specification_statement (void)
 
     case 's':
       match ("save", gfc_match_save, ST_ATTR_DECL);
+      match ("static", gfc_match_static, ST_ATTR_DECL);
+      match ("structure", gfc_match_structure_decl, ST_STRUCTURE_DECL);
       break;
 
     case 't':
@@ -384,6 +387,7 @@ decode_statement (void)
       match ("allocatable", gfc_match_allocatable, ST_ATTR_DECL);
       match ("assign", gfc_match_assign, ST_LABEL_ASSIGNMENT);
       match ("asynchronous", gfc_match_asynchronous, ST_ATTR_DECL);
+      match ("automatic", gfc_match_automatic, ST_ATTR_DECL);
       break;
 
     case 'b':
@@ -454,6 +458,7 @@ decode_statement (void)
       break;
 
     case 'm':
+      match ("map", gfc_match_map, ST_MAP);
       match ("module% procedure", gfc_match_modproc, ST_MODULE_PROC);
       match ("module", gfc_match_module, ST_MODULE);
       break;
@@ -489,8 +494,11 @@ decode_statement (void)
       break;
 
     case 's':
+      // DEC extension: treat STRUCTURE /name/ ... as TYPE name ...
+      match ("structure", gfc_match_structure_decl, ST_STRUCTURE_DECL);
       match ("sequence", gfc_match_eos, ST_SEQUENCE);
       match ("stop", gfc_match_stop, ST_STOP);
+      match ("static", gfc_match_static, ST_ATTR_DECL);
       match ("save", gfc_match_save, ST_ATTR_DECL);
       match ("sync all", gfc_match_sync_all, ST_SYNC_ALL);
       match ("sync images", gfc_match_sync_images, ST_SYNC_IMAGES);
@@ -504,6 +512,7 @@ decode_statement (void)
       break;
 
     case 'u':
+      match ("union", gfc_match_union, ST_UNION);
       match ("unlock", gfc_match_unlock, ST_UNLOCK);
       break;
 
@@ -812,6 +821,9 @@ next_fixed (void)
 	{
 	case ' ':
 	  break;
+        case '\f':
+          if (gfc_option.flag_feed)
+            break;
 
 	case '0':
 	case '1':
@@ -1220,6 +1232,68 @@ gfc_enclosing_unit (gfc_compile_state * result)
   return NULL;
 }
 
+/* Translate a compile state to an ascii string. */
+
+const char *
+gfc_ascii_comp_state(gfc_compile_state c)
+{
+    const char *p = "NONE";
+    switch(c) {
+    case COMP_PROGRAM:
+        p = "PROGRAM"; break;
+    case COMP_MODULE:
+        p = "MODULE"; break;
+    case COMP_SUBROUTINE:
+        p = "SUBROUTINE"; break;
+    case COMP_FUNCTION:
+        p = "FUNCTION"; break;
+    case COMP_BLOCK_DATA:
+        p = "BLOCK DATA"; break;
+    case COMP_INTERFACE:
+        p = "INTERFACE"; break;
+    case COMP_DERIVED:
+        p = "DERIVED"; break;
+    case COMP_DERIVED_CONTAINS:
+        p = "DERIVED CONTAINS"; break;
+    case COMP_UNION:
+        p = "UNION"; break;
+    case COMP_MAP:
+        p = "MAP"; break;
+    case COMP_STRUCTURE:
+        p = "STRUCTURE"; break;
+    case COMP_BLOCK:
+        p = "BLOCK"; break;
+    case COMP_ASSOCIATE:
+        p = "ASSOCIATE"; break;
+    case COMP_IF:
+        p = "IF"; break;
+    case COMP_DO:
+        p = "DO"; break;
+    case COMP_SELECT:
+        p = "SELECT"; break;
+    case COMP_FORALL:
+        p = "FORALL"; break;
+    case COMP_WHERE:
+        p = "WHERE"; break;
+    case COMP_CONTAINS:
+        p = "CONTAINS"; break;
+    case COMP_ENUM:
+        p = "ENUM"; break;
+    case COMP_SELECT_TYPE:
+        p = "SELECT TYPE"; break;
+    case COMP_OMP_STRUCTURED_BLOCK:
+        p = "OMP STRUCTURED BLOCK"; break;
+    case COMP_CRITICAL:
+        p = "CRITICAL"; break;
+    case COMP_DO_CONCURRENT:
+        p = "CONCURRENT DO"; break;
+    case COMP_NONE:
+    default:
+        break;
+    }
+    return p;
+}
+
 
 /* Translate a statement enum to a string.  */
 
@@ -1284,6 +1358,15 @@ gfc_ascii_statement (gfc_statement st)
     case ST_DEALLOCATE:
       p = "DEALLOCATE";
       break;
+    case ST_MAP:
+      p = "MAP";
+      break;
+    case ST_UNION:
+      p = "UNION";
+      break;
+    case ST_STRUCTURE_DECL:
+      p = "STRUCTURE";
+      break;
     case ST_DERIVED_DECL:
       p = _("derived type declaration");
       break;
@@ -1344,6 +1427,15 @@ gfc_ascii_statement (gfc_statement st)
     case ST_END_WHERE:
       p = "END WHERE";
       break;
+    case ST_END_STRUCTURE:
+      p = "END STRUCTURE";
+      break;
+    case ST_END_UNION:
+      p = "END UNION";
+      break;
+    case ST_END_MAP:
+      p = "END MAP";
+      break;
     case ST_END_TYPE:
       p = "END TYPE";
       break;
@@ -1880,6 +1972,7 @@ verify_st_order (st_state *p, gfc_statement st, bool silent)
 
     case ST_PUBLIC:
     case ST_PRIVATE:
+    case ST_STRUCTURE_DECL:
     case ST_DERIVED_DECL:
     case_decl:
       if (p->state >= ORDER_EXEC)
@@ -2073,6 +2166,349 @@ error:
   return error_flag;
 }
 
+/* Set attributes for the parent symbol (gfc_symbol*)data based on the
+   attributes of a component, and raise errors if conflicting attributes
+   are found for the component. */
+
+static void
+check_component (gfc_component *c, gfc_symbol *sym, gfc_component **lockp)
+{
+  gfc_component *lock_comp = NULL;
+  bool coarray, lock_type, allocatable, pointer;
+  coarray = lock_type = allocatable = pointer = false;
+
+  if (lockp) lock_comp = *lockp;
+
+  /* Look for allocatable components.  */
+  if (c->attr.allocatable
+      || (c->ts.type == BT_CLASS && c->attr.class_ok
+          && CLASS_DATA (c)->attr.allocatable)
+      || (c->ts.type == BT_DERIVED && !c->attr.pointer
+          && c->ts.u.derived->attr.alloc_comp))
+    {
+      allocatable = true;
+      sym->attr.alloc_comp = 1;
+    }
+
+  /* Look for pointer components.  */
+  if (c->attr.pointer
+      || (c->ts.type == BT_CLASS && c->attr.class_ok
+          && CLASS_DATA (c)->attr.class_pointer)
+      || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.pointer_comp))
+    {
+      pointer = true;
+      sym->attr.pointer_comp = 1;
+    }
+
+  /* Look for procedure pointer components.  */
+  if (c->attr.proc_pointer
+      || (c->ts.type == BT_DERIVED
+          && c->ts.u.derived->attr.proc_pointer_comp))
+    sym->attr.proc_pointer_comp = 1;
+
+  /* Looking for coarray components.  */
+  if (c->attr.codimension
+      || (c->ts.type == BT_CLASS && c->attr.class_ok
+          && CLASS_DATA (c)->attr.codimension))
+    {
+      coarray = true;
+      sym->attr.coarray_comp = 1;
+    }
+ 
+  if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.coarray_comp)
+    {
+      coarray = true;
+      if (!pointer && !allocatable)
+        sym->attr.coarray_comp = 1;
+    }
+
+  /* Looking for lock_type components.  */
+  if ((c->ts.type == BT_DERIVED
+          && c->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV
+          && c->ts.u.derived->intmod_sym_id == ISOFORTRAN_LOCK_TYPE)
+      || (c->ts.type == BT_CLASS && c->attr.class_ok
+          && CLASS_DATA (c)->ts.u.derived->from_intmod
+             == INTMOD_ISO_FORTRAN_ENV
+          && CLASS_DATA (c)->ts.u.derived->intmod_sym_id
+             == ISOFORTRAN_LOCK_TYPE)
+      || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.lock_comp
+          && !allocatable && !pointer))
+    {
+      lock_type = 1;
+      lock_comp = c;
+      sym->attr.lock_comp = 1;
+    }
+
+  /* Check for F2008, C1302 - and recall that pointers may not be coarrays
+     (5.3.14) and that subobjects of coarray are coarray themselves (2.4.7),
+     unless there are nondirect [allocatable or pointer] components
+     involved (cf. 1.3.33.1 and 1.3.33.3).  */
+
+  if (pointer && !coarray && lock_type)
+    gfc_error ("Component %s at %L of type LOCK_TYPE must have a "
+               "codimension or be a subcomponent of a coarray, "
+               "which is not possible as the component has the "
+               "pointer attribute", c->name, &c->loc);
+  else if (pointer && !coarray && c->ts.type == BT_DERIVED
+           && c->ts.u.derived->attr.lock_comp)
+    gfc_error ("Pointer component %s at %L has a noncoarray subcomponent "
+               "of type LOCK_TYPE, which must have a codimension or be a "
+               "subcomponent of a coarray", c->name, &c->loc);
+
+  if (lock_type && allocatable && !coarray)
+    gfc_error ("Allocatable component %s at %L of type LOCK_TYPE must have "
+               "a codimension", c->name, &c->loc);
+  else if (lock_type && allocatable && c->ts.type == BT_DERIVED
+           && c->ts.u.derived->attr.lock_comp)
+    gfc_error ("Allocatable component %s at %L must have a codimension as "
+               "it has a noncoarray subcomponent of type LOCK_TYPE",
+               c->name, &c->loc);
+
+  if (sym->attr.coarray_comp && !coarray && lock_type)
+    gfc_error ("Noncoarray component %s at %L of type LOCK_TYPE or with "
+               "subcomponent of type LOCK_TYPE must have a codimension or "
+               "be a subcomponent of a coarray. (Variables of type %s may "
+               "not have a codimension as already a coarray "
+               "subcomponent exists)", c->name, &c->loc, sym->name);
+
+  if (sym->attr.lock_comp && coarray && !lock_type)
+    gfc_error ("Noncoarray component %s at %L of type LOCK_TYPE or with "
+               "subcomponent of type LOCK_TYPE must have a codimension or "
+               "be a subcomponent of a coarray. (Variables of type %s may "
+               "not have a codimension as %s at %L has a codimension or a "
+               "coarray subcomponent)", lock_comp->name, &lock_comp->loc,
+               sym->name, c->name, &c->loc);
+
+  /* Look for private components.  */
+  if (sym->component_access == ACCESS_PRIVATE
+      || c->attr.access == ACCESS_PRIVATE
+      || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.private_comp))
+    sym->attr.private_comp = 1;
+
+  if (lockp) *lockp = lock_comp;
+}
+
+static void parse_map (void);
+
+/* Parse a union component definition within a structure/derived-type 
+   definition. */
+
+static void
+parse_union (void)
+{
+    int compiling;
+    gfc_statement st;
+    gfc_state_data s;
+    gfc_component *c;
+    gfc_symbol *un;
+
+    accept_statement(ST_UNION);
+    push_state (&s, COMP_UNION, gfc_new_block);
+    un = gfc_new_block;
+
+    compiling = 1;
+
+    while (compiling)
+    {
+      st = next_statement ();
+      /* Only MAP declarations valid within a union. */
+      switch (st)
+        {
+        case ST_NONE:
+          unexpected_eof ();
+
+        case ST_MAP:
+          accept_statement (ST_MAP);
+          parse_map ();
+          /* Add a component to the union for each map. */
+          if (gfc_add_component (un, gfc_new_block->name, &c) == FAILURE)
+          {
+            gfc_internal_error ("failed to create map component '%s'", 
+                gfc_new_block->name);
+            reject_statement ();
+            return;
+          }
+          c->ts.type = BT_DERIVED;
+          c->ts.u.derived = gfc_new_block;
+          break;
+
+        case ST_END_UNION:
+          compiling = 0;
+          accept_statement (ST_END_UNION);
+          break;
+
+        default:
+          gfc_error ("Unexpected statement at %C; only MAP blocks are valid in"
+                     " a UNION block");
+          reject_statement ();
+          break;
+        }
+    }
+
+    for (c = un->components; c; c = c->next)
+      check_component (c, un, NULL);
+
+    /* Add the union as a component in its parent structure. */
+    pop_state ();
+    if (gfc_add_component (gfc_current_block (), un->name, &c) == FAILURE)
+    {
+      gfc_internal_error ("failed to create union component '%s'", un->name);
+      reject_statement ();
+      return;
+    }
+    c->ts.type = BT_UNION;
+    c->ts.u.derived = un;
+
+    un->attr.zero_comp = un->components == NULL;
+}
+
+/* Parse a structure definition. */
+
+static void
+parse_structure (void)
+{ 
+    int compiling_type;
+    gfc_statement st;
+    gfc_state_data s;
+    gfc_symbol *sym;
+    gfc_component *c;
+
+    accept_statement(ST_STRUCTURE_DECL);
+    push_state (&s, COMP_STRUCTURE, gfc_new_block);
+
+    gfc_new_block->component_access = ACCESS_PUBLIC;
+    compiling_type = 1;
+
+    while (compiling_type)
+    {
+      st = next_statement ();
+      switch (st)
+        {
+        case ST_NONE:
+          unexpected_eof ();
+          break;
+
+        /* Nested structure declarations should be captured as ST_DATA_DECL. */
+        case ST_STRUCTURE_DECL:
+          /* Let a more specific error take over. */
+          if (gfc_error_check () == 0)
+            gfc_error ("Syntax error in nested structure declaration at %C");
+          reject_statement ();
+          /* Skip the rest of this statement. */
+          gfc_error_recovery ();
+          break;
+
+        case ST_UNION:
+          accept_statement (ST_UNION);
+          parse_union ();
+          break;
+
+        case ST_DATA_DECL:
+          accept_statement (ST_DATA_DECL);
+          /* The data declaration was a nested/ad-hoc STRUCTURE field */
+          if (gfc_new_block && gfc_new_block != gfc_current_block ()
+                            && gfc_new_block->attr.flavor == FL_STRUCT)
+              parse_structure ();
+          break;
+
+        case ST_END_STRUCTURE:
+          compiling_type = 0;
+          accept_statement (ST_END_STRUCTURE);
+          break;
+
+        default:
+          unexpected_statement (st);
+          break;
+        }
+    }
+
+    /* need to verify that all fields of the derived type are
+    * interoperable with C if the type is declared to be bind(c)
+    */
+    sym = gfc_current_block ();
+    for (c = sym->components; c; c = c->next)
+      check_component (c, sym, NULL);
+
+    sym->attr.zero_comp = sym->components == NULL;
+
+    pop_state ();
+
+}
+
+/* Parse a map definition within a union. Similar to a structure definition
+   itself. */
+
+static void
+parse_map (void)
+{
+    int compiling_type;
+    gfc_statement st;
+    gfc_state_data s;
+    gfc_symbol *sym;
+    gfc_component *c;
+
+    accept_statement(ST_MAP);
+    push_state (&s, COMP_MAP, gfc_new_block);
+
+    gfc_new_block->component_access = ACCESS_PUBLIC;
+    compiling_type = 1;
+
+    while (compiling_type)
+    {
+      st = next_statement ();
+      switch (st)
+        {
+        case ST_NONE:
+          unexpected_eof ();
+
+        /* Nested structure declarations should be captured as ST_DATA_DECL. */
+        case ST_STRUCTURE_DECL:
+          /* Let a more specific error make it to decode_statement(). */
+          if (gfc_error_check () == 0)
+            gfc_error ("Syntax error in nested structure declaration at %C");
+          reject_statement ();
+          /* Skip the rest of this statement. */
+          gfc_error_recovery ();
+          break;
+
+        case ST_UNION:
+          accept_statement (ST_UNION);
+          parse_union ();
+          break;
+
+        case ST_DATA_DECL:
+          accept_statement (ST_DATA_DECL);
+          /* The data declaration was a nested/ad-hoc STRUCTURE field */
+          if (gfc_new_block && gfc_new_block != gfc_current_block ()
+                            && gfc_new_block->attr.flavor == FL_STRUCT)
+              parse_structure ();
+          break;
+
+        case ST_END_MAP:
+          compiling_type = 0;
+          accept_statement (ST_END_MAP);
+          break;
+
+        default:
+          unexpected_statement (st);
+          break;
+        }
+    }
+
+    /* need to verify that all fields of the derived type are
+    * interoperable with C if the type is declared to be bind(c)
+    */
+    sym = gfc_current_block ();
+    for (c = sym->components; c; c = c->next)
+      check_component (c, sym, NULL);
+
+    sym->attr.zero_comp = sym->components == NULL;
+
+    /* So parse_union can add this structure to its list of maps */
+    gfc_new_block = gfc_current_block ();
+
+    pop_state ();
+}
 
 /* Parse a derived type.  */
 
@@ -2103,10 +2539,24 @@ parse_derived (void)
 	case ST_NONE:
 	  unexpected_eof ();
 
+        /* Nested structure declarations should be captured as ST_DATA_DECL. */
+        case ST_STRUCTURE_DECL:
+          /* Let a more specific error make it to decode_statement(). */
+          if (gfc_error_check () == 0)
+            gfc_error ("Syntax error in nested structure declaration at %C");
+          reject_statement ();
+          /* Skip the rest of this statement. */
+          gfc_error_recovery ();
+          break;
+
 	case ST_DATA_DECL:
 	case ST_PROCEDURE:
 	  accept_statement (st);
 	  seen_component = 1;
+          /* The data declaration was a nested/ad-hoc STRUCTURE field */
+          if (gfc_new_block && gfc_new_block != gfc_current_block ()
+                            && gfc_new_block->attr.flavor == FL_STRUCT)
+              parse_structure ();
 	  break;
 
 	case ST_FINAL:
@@ -2190,119 +2640,9 @@ endType:
    */
   sym = gfc_current_block ();
   for (c = sym->components; c; c = c->next)
-    {
-      bool coarray, lock_type, allocatable, pointer;
-      coarray = lock_type = allocatable = pointer = false;
-
-      /* Look for allocatable components.  */
-      if (c->attr.allocatable
-	  || (c->ts.type == BT_CLASS && c->attr.class_ok
-	      && CLASS_DATA (c)->attr.allocatable)
-	  || (c->ts.type == BT_DERIVED && !c->attr.pointer
-	      && c->ts.u.derived->attr.alloc_comp))
-	{
-	  allocatable = true;
-	  sym->attr.alloc_comp = 1;
-	}
-
-      /* Look for pointer components.  */
-      if (c->attr.pointer
-	  || (c->ts.type == BT_CLASS && c->attr.class_ok
-	      && CLASS_DATA (c)->attr.class_pointer)
-	  || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.pointer_comp))
-	{
-	  pointer = true;
-	  sym->attr.pointer_comp = 1;
-	}
+    check_component (c, sym, &lock_comp);
 
-      /* Look for procedure pointer components.  */
-      if (c->attr.proc_pointer
-	  || (c->ts.type == BT_DERIVED
-	      && c->ts.u.derived->attr.proc_pointer_comp))
-	sym->attr.proc_pointer_comp = 1;
-
-      /* Looking for coarray components.  */
-      if (c->attr.codimension
-	  || (c->ts.type == BT_CLASS && c->attr.class_ok
-	      && CLASS_DATA (c)->attr.codimension))
-	{
-	  coarray = true;
-	  sym->attr.coarray_comp = 1;
-	}
-     
-      if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.coarray_comp)
-	{
-	  coarray = true;
-	  if (!pointer && !allocatable)
-	    sym->attr.coarray_comp = 1;
-	}
-
-      /* Looking for lock_type components.  */
-      if ((c->ts.type == BT_DERIVED
-	      && c->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV
-	      && c->ts.u.derived->intmod_sym_id == ISOFORTRAN_LOCK_TYPE)
-	  || (c->ts.type == BT_CLASS && c->attr.class_ok
-	      && CLASS_DATA (c)->ts.u.derived->from_intmod
-		 == INTMOD_ISO_FORTRAN_ENV
-	      && CLASS_DATA (c)->ts.u.derived->intmod_sym_id
-		 == ISOFORTRAN_LOCK_TYPE)
-	  || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.lock_comp
-	      && !allocatable && !pointer))
-	{
-	  lock_type = 1;
-	  lock_comp = c;
-	  sym->attr.lock_comp = 1;
-	}
-
-      /* Check for F2008, C1302 - and recall that pointers may not be coarrays
-	 (5.3.14) and that subobjects of coarray are coarray themselves (2.4.7),
-	 unless there are nondirect [allocatable or pointer] components
-	 involved (cf. 1.3.33.1 and 1.3.33.3).  */
-
-      if (pointer && !coarray && lock_type)
-	gfc_error ("Component %s at %L of type LOCK_TYPE must have a "
-		   "codimension or be a subcomponent of a coarray, "
-		   "which is not possible as the component has the "
-		   "pointer attribute", c->name, &c->loc);
-      else if (pointer && !coarray && c->ts.type == BT_DERIVED
-	       && c->ts.u.derived->attr.lock_comp)
-	gfc_error ("Pointer component %s at %L has a noncoarray subcomponent "
-		   "of type LOCK_TYPE, which must have a codimension or be a "
-		   "subcomponent of a coarray", c->name, &c->loc);
-
-      if (lock_type && allocatable && !coarray)
-	gfc_error ("Allocatable component %s at %L of type LOCK_TYPE must have "
-		   "a codimension", c->name, &c->loc);
-      else if (lock_type && allocatable && c->ts.type == BT_DERIVED
-	       && c->ts.u.derived->attr.lock_comp)
-	gfc_error ("Allocatable component %s at %L must have a codimension as "
-		   "it has a noncoarray subcomponent of type LOCK_TYPE",
-		   c->name, &c->loc);
-
-      if (sym->attr.coarray_comp && !coarray && lock_type)
-	gfc_error ("Noncoarray component %s at %L of type LOCK_TYPE or with "
-		   "subcomponent of type LOCK_TYPE must have a codimension or "
-		   "be a subcomponent of a coarray. (Variables of type %s may "
-		   "not have a codimension as already a coarray "
-		   "subcomponent exists)", c->name, &c->loc, sym->name);
-
-      if (sym->attr.lock_comp && coarray && !lock_type)
-	gfc_error ("Noncoarray component %s at %L of type LOCK_TYPE or with "
-		   "subcomponent of type LOCK_TYPE must have a codimension or "
-		   "be a subcomponent of a coarray. (Variables of type %s may "
-		   "not have a codimension as %s at %L has a codimension or a "
-		   "coarray subcomponent)", lock_comp->name, &lock_comp->loc,
-		   sym->name, c->name, &c->loc);
-
-      /* Look for private components.  */
-      if (sym->component_access == ACCESS_PRIVATE
-	  || c->attr.access == ACCESS_PRIVATE
-	  || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.private_comp))
-	sym->attr.private_comp = 1;
-    }
-
-  if (!seen_component)
-    sym->attr.zero_comp = 1;
+  sym->attr.zero_comp = !seen_component;
 
   pop_state ();
 }
@@ -2685,6 +3025,7 @@ loop:
     case ST_PARAMETER:
     case ST_PUBLIC:
     case ST_PRIVATE:
+    case ST_STRUCTURE_DECL:
     case ST_DERIVED_DECL:
     case_decl:
 declSt:
@@ -2701,6 +3042,10 @@ declSt:
 	  parse_interface ();
 	  break;
 
+        case ST_STRUCTURE_DECL:
+          parse_structure ();
+          break;
+
 	case ST_DERIVED_DECL:
 	  parse_derived ();
 	  break;
@@ -3938,9 +4283,9 @@ gfc_fixup_sibling_symbols (gfc_symbol *sym, gfc_namespace *siblings)
       if (!st || (st->n.sym->attr.dummy && ns == st->n.sym->ns))
 	goto fixup_contained;
 
-      if ((st->n.sym->attr.flavor == FL_DERIVED
+      if ((gfc_fl_struct (st->n.sym->attr.flavor)
 	   && sym->attr.generic && sym->attr.function)
-	  ||(sym->attr.flavor == FL_DERIVED
+	  ||(gfc_fl_struct (sym->attr.flavor)
 	     && st->n.sym->attr.generic && st->n.sym->attr.function))
 	goto fixup_contained;
 
diff --git a/gcc/fortran/parse.h b/gcc/fortran/parse.h
index dbe3c49..a8c9cf9 100644
--- a/gcc/fortran/parse.h
+++ b/gcc/fortran/parse.h
@@ -27,6 +27,7 @@ typedef enum
 {
   COMP_NONE, COMP_PROGRAM, COMP_MODULE, COMP_SUBROUTINE, COMP_FUNCTION,
   COMP_BLOCK_DATA, COMP_INTERFACE, COMP_DERIVED, COMP_DERIVED_CONTAINS,
+  COMP_STRUCTURE, COMP_UNION, COMP_MAP,
   COMP_BLOCK, COMP_ASSOCIATE, COMP_IF,
   COMP_DO, COMP_SELECT, COMP_FORALL, COMP_WHERE, COMP_CONTAINS, COMP_ENUM,
   COMP_SELECT_TYPE, COMP_OMP_STRUCTURED_BLOCK, COMP_CRITICAL, COMP_DO_CONCURRENT
@@ -59,10 +60,15 @@ extern gfc_state_data *gfc_state_stack;
 #define gfc_current_block() (gfc_state_stack->sym)
 #define gfc_current_state() (gfc_state_stack->state)
 
+/* STRUCTURE and TYPE are treated similarly, so these are common checks. */
+#define gfc_comp_is_derived(s) \
+    (((s) == COMP_DERIVED) || ((s) == COMP_STRUCTURE) || ((s) == COMP_MAP))
+
 int gfc_check_do_variable (gfc_symtree *);
 gfc_try gfc_find_state (gfc_compile_state);
 gfc_state_data *gfc_enclosing_unit (gfc_compile_state *);
 const char *gfc_ascii_statement (gfc_statement);
+const char *gfc_ascii_comp_state (gfc_compile_state);
 match gfc_match_enum (void);
 match gfc_match_enumerator_def (void);
 void gfc_free_enum_history (void);
diff --git a/gcc/fortran/primary.c b/gcc/fortran/primary.c
index a94ae21..8a3e485 100644
--- a/gcc/fortran/primary.c
+++ b/gcc/fortran/primary.c
@@ -107,116 +107,51 @@ get_kind (int *is_iso_c)
   return (m == MATCH_YES) ? kind : -1;
 }
 
-
-/* Given a character and a radix, see if the character is a valid
-   digit in that radix.  */
-
-int
-gfc_check_digit (char c, int radix)
-{
-  int r;
-
-  switch (radix)
-    {
-    case 2:
-      r = ('0' <= c && c <= '1');
-      break;
-
-    case 8:
-      r = ('0' <= c && c <= '7');
-      break;
-
-    case 10:
-      r = ('0' <= c && c <= '9');
-      break;
-
-    case 16:
-      r = ISXDIGIT (c);
-      break;
-
-    default:
-      gfc_internal_error ("gfc_check_digit(): bad radix");
-    }
-
-  return r;
-}
-
-
-/* Match the digit string part of an integer if signflag is not set,
-   the signed digit string part if signflag is set.  If the buffer 
-   is NULL, we just count characters for the resolution pass.  Returns 
-   the number of characters matched, -1 for no match.  */
-
-static int
-match_digits (int signflag, int radix, char *buffer)
-{
-  locus old_loc;
-  int length;
-  char c;
-
-  length = 0;
-  c = gfc_next_ascii_char ();
-
-  if (signflag && (c == '+' || c == '-'))
-    {
-      if (buffer != NULL)
-	*buffer++ = c;
-      gfc_gobble_whitespace ();
-      c = gfc_next_ascii_char ();
-      length++;
-    }
-
-  if (!gfc_check_digit (c, radix))
-    return -1;
-
-  length++;
-  if (buffer != NULL)
-    *buffer++ = c;
-
-  for (;;)
-    {
-      old_loc = gfc_current_locus;
-      c = gfc_next_ascii_char ();
-
-      if (!gfc_check_digit (c, radix))
-	break;
-
-      if (buffer != NULL)
-	*buffer++ = c;
-      length++;
-    }
-
-  gfc_current_locus = old_loc;
-
-  return length;
-}
-
-
 /* Match an integer (digit string and optional kind).  
    A sign will be accepted if signflag is set.  */
 
 static match
 match_integer_constant (gfc_expr **result, int signflag)
 {
+  int radix, sign;
   int length, kind, is_iso_c;
-  locus old_loc;
-  char *buffer;
+  locus old_loc, start_loc;
+  char *buffer, *matchbuf;
   gfc_expr *e;
+  match m;
+
+  sign = 0; /* Not present */
+  start_loc = gfc_current_locus;
 
-  old_loc = gfc_current_locus;
   gfc_gobble_whitespace ();
 
-  length = match_digits (signflag, 10, NULL);
+  if (signflag)
+      gfc_match_sign (&sign);
+
+  /* Get the length of the match first. */
+  old_loc = gfc_current_locus;
+  m = gfc_match_extended_integer (NULL, &radix, &length);
+
+  if (m != MATCH_YES)
+  {
+      gfc_current_locus = start_loc;
+      return m;
+  }
   gfc_current_locus = old_loc;
-  if (length == -1)
-    return MATCH_NO;
+
+  /* Reserve a space in buffer for '-' */
+  if (sign < 0)
+      ++length;
 
   buffer = (char *) alloca (length + 1);
   memset (buffer, '\0', length + 1);
 
-  gfc_gobble_whitespace ();
+  /* Match number after sign. */
+  matchbuf = buffer;
+  if (sign < 0)
+      matchbuf++[0] = '-';
 
-  match_digits (signflag, 10, buffer);
+  gcc_assert (gfc_match_extended_integer (matchbuf, NULL, NULL) == MATCH_YES);
 
   kind = get_kind (&is_iso_c);
   if (kind == -2)
@@ -233,7 +168,7 @@ match_integer_constant (gfc_expr **result, int signflag)
       return MATCH_ERROR;
     }
 
-  e = gfc_convert_integer (buffer, kind, 10, &gfc_current_locus);
+  e = gfc_convert_integer (buffer, kind, radix, &gfc_current_locus);
   e->ts.is_c_interop = is_iso_c;
 
   if (gfc_range_check (e) != ARITH_OK)
@@ -264,6 +199,18 @@ match_hollerith_constant (gfc_expr **result)
   old_loc = gfc_current_locus;
   gfc_gobble_whitespace ();
 
+  if (gfc_match_literal_int (NULL, 10, NULL) == MATCH_YES)
+  {
+    gfc_gobble_whitespace ();
+    if (gfc_peek_ascii_char () == '#' && gfc_option.flag_dec_extended_int)
+    {
+      /* This is actually an extended integer constant. */
+      gfc_current_locus = old_loc;
+      return MATCH_NO;
+    }
+  }
+  gfc_current_locus = old_loc;
+
   if (match_integer_constant (&e, 0) == MATCH_YES
       && gfc_match_char ('h') == MATCH_YES)
     {
@@ -349,6 +296,7 @@ match_boz_constant (gfc_expr **result)
   locus old_loc, start_loc;
   char *buffer, post, delim;
   gfc_expr *e;
+  match m;
 
   start_loc = old_loc = gfc_current_locus;
   gfc_gobble_whitespace ();
@@ -398,8 +346,14 @@ match_boz_constant (gfc_expr **result)
 
   old_loc = gfc_current_locus;
 
-  length = match_digits (0, radix, NULL);
-  if (length == -1)
+  length = -1;
+  m = gfc_match_literal_int (NULL, radix, &length);
+
+  /* Error set by gfc_match_literal_int */
+  if (m == MATCH_ERROR)
+      return MATCH_ERROR;
+
+  if (length == -1 || m == MATCH_NO)
     {
       gfc_error ("Empty set of digits in BOZ constant at %C");
       return MATCH_ERROR;
@@ -441,7 +395,7 @@ match_boz_constant (gfc_expr **result)
   buffer = (char *) alloca (length + 1);
   memset (buffer, '\0', length + 1);
 
-  match_digits (0, radix, buffer);
+  gfc_match_literal_int (buffer, radix, NULL);
   gfc_next_ascii_char ();    /* Eat delimiter.  */
   if (post == 1)
     gfc_next_ascii_char ();  /* Eat postfixed b, o, z, or x.  */
@@ -1822,11 +1776,12 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,
 		   bool ppc_arg)
 {
   char name[GFC_MAX_SYMBOL_LEN + 1];
-  gfc_ref *substring, *tail;
+  gfc_ref *substring, *tail, *tmp;
   gfc_component *component;
   gfc_symbol *sym = primary->symtree->n.sym;
   match m;
   bool unknown;
+  char sep;
 
   tail = NULL;
 
@@ -1907,25 +1862,30 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,
   if (equiv_flag)
     return MATCH_YES;
 
-  if (sym->ts.type == BT_UNKNOWN && gfc_peek_ascii_char () == '%'
+  sep = gfc_peek_ascii_char ();
+  m = gfc_match_member_sep (sym);
+  if(m == MATCH_ERROR)
+      return MATCH_ERROR;
+
+  if (sym->ts.type == BT_UNKNOWN && m == MATCH_YES
       && gfc_get_default_type (sym->name, sym->ns)->type == BT_DERIVED)
     gfc_set_default_type (sym, 0, sym->ns);
 
-  if (sym->ts.type == BT_UNKNOWN && gfc_match_char ('%') == MATCH_YES)
+  if (sym->ts.type == BT_UNKNOWN && m == MATCH_YES)
     {
       gfc_error ("Symbol '%s' at %C has no IMPLICIT type", sym->name);
       return MATCH_ERROR;
     }
   else if ((sym->ts.type != BT_DERIVED && sym->ts.type != BT_CLASS)
-	   && gfc_match_char ('%') == MATCH_YES)
+          && m == MATCH_YES)
     {
-      gfc_error ("Unexpected '%%' for nonderived-type variable '%s' at %C",
-		 sym->name);
+      gfc_error ("Unexpected '%c' for nonderived-type variable "
+                 "'%s' at %C", sep, sym->name);
       return MATCH_ERROR;
     }
 
   if ((sym->ts.type != BT_DERIVED && sym->ts.type != BT_CLASS)
-      || gfc_match_char ('%') != MATCH_YES)
+      || m != MATCH_YES)
     goto check_substring;
 
   sym = sym->ts.u.derived;
@@ -1994,15 +1954,20 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,
 	  break;
 	}
 
-      component = gfc_find_component (sym, name, false, false);
+      component = gfc_find_component (sym, name, false, false, &tmp);
       if (component == NULL)
-	return MATCH_ERROR;
+        return MATCH_ERROR;
 
-      tail = extend_ref (primary, tail);
-      tail->type = REF_COMPONENT;
+      /* Extend the reference chain through the determined ref. */
+      if (primary->ref == NULL)
+        primary->ref = tmp;
+      else
+        tail->next = tmp;
 
-      tail->u.c.component = component;
-      tail->u.c.sym = sym;
+      /* The reference chain may be longer than one hop for union
+         subcomponents; find the new tail. */
+      for (tail = tmp; tail->next; tail = tail->next)
+        ;
 
       primary->ts = component->ts;
 
@@ -2053,7 +2018,7 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,
 	}
 
       if ((component->ts.type != BT_DERIVED && component->ts.type != BT_CLASS)
-	  || gfc_match_char ('%') != MATCH_YES)
+	  || gfc_match_member_sep (component->ts.u.derived) != MATCH_YES)
 	break;
 
       sym = component->ts.u.derived;
@@ -2061,7 +2026,7 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,
 
 check_substring:
   unknown = false;
-  if (primary->ts.type == BT_UNKNOWN && sym->attr.flavor != FL_DERIVED)
+  if (primary->ts.type == BT_UNKNOWN && !gfc_fl_struct (sym->attr.flavor))
     {
       if (gfc_get_default_type (sym->name, sym->ns)->type == BT_CHARACTER)
        {
@@ -2463,11 +2428,11 @@ gfc_convert_to_structure_constructor (gfc_expr *e, gfc_symbol *sym, gfc_expr **c
       /* Find the current component in the structure definition and check
 	     its access is not private.  */
       if (comp)
-	this_comp = gfc_find_component (sym, comp->name, false, false);
+	this_comp = gfc_find_component (sym, comp->name, false, false, NULL);
       else
 	{
 	  this_comp = gfc_find_component (sym, (const char *)comp_tail->name,
-					  false, false);
+					  false, false, NULL);
 	  comp = NULL; /* Reset needed!  */
 	}
 
@@ -2511,7 +2476,7 @@ gfc_convert_to_structure_constructor (gfc_expr *e, gfc_symbol *sym, gfc_expr **c
           if (comp && comp == sym->components
                 && sym->attr.extension
 		&& comp_tail->val
-                && (comp_tail->val->ts.type != BT_DERIVED
+                && (!gfc_bt_struct (comp_tail->val->ts.type)
                       ||
                     comp_tail->val->ts.u.derived != this_comp->ts.u.derived))
             {
@@ -2612,7 +2577,7 @@ gfc_match_structure_constructor (gfc_symbol *sym, gfc_expr **result)
   e->symtree = symtree;
   e->expr_type = EXPR_FUNCTION;
 
-  gcc_assert (sym->attr.flavor == FL_DERIVED
+  gcc_assert (gfc_fl_struct (sym->attr.flavor)
 	      && symtree->n.sym->attr.flavor == FL_PROCEDURE);
   e->value.function.esym = sym;
   e->symtree->n.sym->attr.generic = 1;
@@ -2701,18 +2666,43 @@ gfc_match_rvalue (gfc_expr **result)
   bool implicit_char;
   gfc_ref *ref;
 
-  m = gfc_match_name (name);
-  if (m != MATCH_YES)
-    return m;
+  m = MATCH_NO;
+  if (gfc_option.flag_loc_rval)
+  {
+    /* Let %LOC() act as a valid rvalue; treat it like GFC_ISYM_LOC */
+    m = gfc_match ("%%loc");
+    if (m == MATCH_YES)
+        strcpy (name, "loc");
+  }
 
-  if (gfc_find_state (COMP_INTERFACE) == SUCCESS
-      && !gfc_current_ns->has_import_set)
-    i = gfc_get_sym_tree (name, NULL, &symtree, false);
-  else
-    i = gfc_get_ha_sym_tree (name, &symtree);
+  if (m != MATCH_YES)
+  {
+      m = gfc_match_name (name);
+      if (m != MATCH_YES)
+        return m;
+  }
 
+  /* Check if the symbol exists first */
+  i = gfc_find_sym_tree (name, NULL, 1, &symtree);
   if (i)
     return MATCH_ERROR;
+  /* If not, we do not create it if there is a corresponding structure decl */
+  if (!symtree)
+  {
+    i = gfc_find_sym_tree (gfc_dt_upper_string (name), NULL, 1, &symtree);
+    if (i)
+      return MATCH_ERROR;
+  }
+  if (!symtree || symtree->n.sym->attr.flavor != FL_STRUCT)
+  {
+    if (gfc_find_state (COMP_INTERFACE) == SUCCESS
+        && !gfc_current_ns->has_import_set)
+      i = gfc_get_sym_tree (name, NULL, &symtree, false);
+    else
+      i = gfc_get_ha_sym_tree (name, &symtree);
+    if (i)
+      return MATCH_ERROR;
+  }
 
   sym = symtree->n.sym;
   e = NULL;
@@ -2824,6 +2814,7 @@ gfc_match_rvalue (gfc_expr **result)
 
       break;
 
+    case FL_STRUCT:
     case FL_DERIVED:
       sym = gfc_use_derived (sym);
       if (sym == NULL)
@@ -2964,10 +2955,12 @@ gfc_match_rvalue (gfc_expr **result)
 	 via an IMPLICIT statement.  This can't wait for the
 	 resolution phase.  */
 
-      if (gfc_peek_ascii_char () == '%'
+      old_loc = gfc_current_locus;
+      if (gfc_match_member_sep (sym) == MATCH_YES
 	  && sym->ts.type == BT_UNKNOWN
 	  && gfc_get_default_type (sym->name, sym->ns)->type == BT_DERIVED)
 	gfc_set_default_type (sym, 0, sym->ns);
+      gfc_current_locus = old_loc;
 
       /* If the symbol has a (co)dimension attribute, the expression is a
 	 variable.  */
@@ -3123,13 +3116,17 @@ gfc_match_rvalue (gfc_expr **result)
       break;
 
     generic_function:
-      gfc_get_sym_tree (name, NULL, &symtree, false);	/* Can't fail */
+      gfc_find_sym_tree (name, NULL, 1, &symtree);
+      if (!symtree)
+        gfc_find_sym_tree (gfc_dt_upper_string (name), NULL, 1, &symtree);
+      if (!symtree || symtree->n.sym->attr.flavor != FL_STRUCT)
+        gfc_get_sym_tree (name, NULL, &symtree, false); /* Can't fail */
 
       e = gfc_get_expr ();
       e->symtree = symtree;
       e->expr_type = EXPR_FUNCTION;
 
-      if (sym->attr.flavor == FL_DERIVED)
+      if (gfc_fl_struct (sym->attr.flavor))
 	{
 	  e->value.function.esym = sym;
 	  e->symtree->n.sym->attr.generic = 1;
@@ -3169,10 +3166,10 @@ gfc_match_rvalue (gfc_expr **result)
 static match
 match_variable (gfc_expr **result, int equiv_flag, int host_flag)
 {
-  gfc_symbol *sym;
+  gfc_symbol *sym, *dt_sym;
   gfc_symtree *st;
   gfc_expr *expr;
-  locus where;
+  locus where, old_loc;
   match m;
 
   /* Since nothing has any business being an lvalue in a module
@@ -3202,6 +3199,17 @@ match_variable (gfc_expr **result, int equiv_flag, int host_flag)
   sym->attr.implied_index = 0;
 
   gfc_set_sym_referenced (sym);
+
+  /* Check for generic symbols representing derived or structure types. */
+  if (sym->attr.flavor == FL_PROCEDURE && sym->generic
+      && (dt_sym = gfc_find_dt_in_generic (sym)))
+  {
+    if (dt_sym->attr.flavor == FL_DERIVED)
+      gfc_error ("Derived type '%s' cannot be used as a variable at %C",
+                 sym->name);
+    return MATCH_ERROR;
+  }
+
   switch (sym->attr.flavor)
     {
     case FL_VARIABLE:
@@ -3288,10 +3296,12 @@ match_variable (gfc_expr **result, int equiv_flag, int host_flag)
       else
 	implicit_ns = sym->ns;
 	
-      if (gfc_peek_ascii_char () == '%'
+      old_loc = gfc_current_locus;
+      if (gfc_match_member_sep (sym) == MATCH_YES
 	  && sym->ts.type == BT_UNKNOWN
 	  && gfc_get_default_type (sym->name, implicit_ns)->type == BT_DERIVED)
 	gfc_set_default_type (sym, 0, implicit_ns);
+      gfc_current_locus = old_loc;
     }
 
   expr = gfc_get_expr ();
diff --git a/gcc/fortran/resolve.c b/gcc/fortran/resolve.c
index 43eb240..fdfed7a 100644
--- a/gcc/fortran/resolve.c
+++ b/gcc/fortran/resolve.c
@@ -520,7 +520,7 @@ static void
 find_arglists (gfc_symbol *sym)
 {
   if (sym->attr.if_source == IFSRC_UNKNOWN || sym->ns != gfc_current_ns
-      || sym->attr.flavor == FL_DERIVED)
+      || gfc_fl_struct (sym->attr.flavor))
     return;
 
   resolve_formal_arglist (sym);
@@ -933,9 +933,9 @@ resolve_common_vars (gfc_symbol *sym, bool named_common)
 		       "has an ultimate component that is "
 		       "allocatable", csym->name, &csym->declared_at);
       if (gfc_has_default_initializer (csym->ts.u.derived))
-	gfc_error_now ("Derived type variable '%s' in COMMON at %L "
-		       "may not have default initializer", csym->name,
-		       &csym->declared_at);
+        gfc_error_now ("Derived type variable '%s' in COMMON at %L "
+                       "may not have default initializer", csym->name,
+                       &csym->declared_at);
 
       if (csym->attr.flavor == FL_UNKNOWN && !csym->attr.proc_pointer)
 	gfc_add_flavor (&csym->attr, FL_VARIABLE, csym->name, &csym->declared_at);
@@ -1017,7 +1017,7 @@ resolve_contained_functions (gfc_namespace *ns)
 
 
 static gfc_try resolve_fl_derived0 (gfc_symbol *sym);
-
+static gfc_try resolve_fl_union (gfc_symbol *sym);
 
 /* Resolve all of the elements of a structure constructor and make sure that
    the types are correct. The 'init' flag indicates that the given
@@ -1035,6 +1035,8 @@ resolve_structure_cons (gfc_expr *expr, int init)
 
   if (expr->ts.type == BT_DERIVED)
     resolve_fl_derived0 (expr->ts.u.derived);
+  else if (expr->ts.type == BT_UNION)
+    resolve_fl_union (expr->ts.u.derived);
 
   cons = gfc_constructor_first (expr->value.constructor);
 
@@ -1055,6 +1057,10 @@ resolve_structure_cons (gfc_expr *expr, int init)
       && cons->expr && cons->expr->expr_type == EXPR_NULL)
     return SUCCESS;
 
+  /* Union constructors only have one constructor. */
+  if (expr->ts.type == BT_UNION)
+    return SUCCESS;
+
   /* A constructor may have references if it is the result of substituting a
      parameter variable.  In this case we just pull out the component we
      want.  */
@@ -1477,7 +1483,7 @@ is_illegal_recursion (gfc_symbol* sym, gfc_namespace* context)
   gfc_namespace* real_context;
 
   if (sym->attr.flavor == FL_PROGRAM
-      || sym->attr.flavor == FL_DERIVED)
+      || gfc_fl_struct (sym->attr.flavor))
     return false;
 
   gcc_assert (sym->attr.flavor == FL_PROCEDURE);
@@ -2446,7 +2452,7 @@ resolve_generic_f (gfc_expr *expr)
 generic:
       if (!intr)
 	for (intr = sym->generic; intr; intr = intr->next)
-	  if (intr->sym->attr.flavor == FL_DERIVED)
+	  if (gfc_fl_struct (intr->sym->attr.flavor))
 	    break;
 
       if (sym->ns->parent == NULL)
@@ -3889,6 +3895,72 @@ compare_shapes (gfc_expr *op1, gfc_expr *op2)
   return t;
 }
 
+/* Convert a logical operator to the corresponding bitwise intrinsic function
+   call; i.e. A .AND. B becomes IAND(A, B). */
+static gfc_expr *
+logical_to_bitwise (gfc_expr *e)
+{
+  gfc_expr *tmp, *op1, *op2;
+  gfc_isym_id isym;
+  gfc_actual_arglist *args = NULL;
+
+  gcc_assert (e->expr_type = EXPR_OP);
+
+  isym = GFC_ISYM_NONE;
+  op1 = e->value.op.op1;
+  op2 = e->value.op.op2;
+
+  switch (e->value.op.op)
+  {
+    case INTRINSIC_NOT:
+      isym = GFC_ISYM_NOT;
+      break;
+    case INTRINSIC_AND:
+      isym = GFC_ISYM_IAND;
+      break;
+    case INTRINSIC_OR:
+      isym = GFC_ISYM_IOR;
+      break;
+    case INTRINSIC_NEQV:
+      isym = GFC_ISYM_IEOR;
+      break;
+    case INTRINSIC_EQV:
+      /* Bitwise "eqv" is actually the complement of XOR. 
+         Change the old expression to NEQV === XOR and wrap it in NOT. */
+      tmp = gfc_copy_expr (e);
+      tmp->value.op.op = INTRINSIC_NEQV;
+      tmp = logical_to_bitwise (tmp);
+      isym = GFC_ISYM_NOT;
+      op1 = tmp;
+      op2 = NULL;
+      break;
+    default:
+      gfc_internal_error ("logical_to_bitwise(): Bad intrinsic");
+  }
+
+  /* Inherit the original operation's operands as arguments. */
+  args = gfc_get_actual_arglist ();
+  args->expr = op1;
+  if (op2)
+  {
+    args->next = gfc_get_actual_arglist ();
+    args->next->expr = op2;
+  }
+
+  /* Convert the expression to a function call. */
+  e->expr_type = EXPR_FUNCTION;
+  /* ? mpz_init_set_ui (e->shape, 0) ? */
+  e->value.function.actual = args;
+  e->value.function.isym = gfc_intrinsic_function_by_id(isym);
+  e->value.function.name = e->value.function.isym->name;
+  e->value.function.esym = NULL;
+
+  args->name = e->value.function.isym->formal->name;
+  if (e->value.function.isym->formal->next)
+    args->next->name = e->value.function.isym->formal->next->name;
+
+  return e;
+}
 
 /* Resolve an operator expression node.  This can involve replacing the
    operation with a user defined function call.  */
@@ -3995,6 +4067,20 @@ resolve_operator (gfc_expr *e)
 	  break;
 	}
 
+      /* Logical ops on integers become bitwise ops with -fdec-bitwise-ops */
+      else if (gfc_option.flag_dec_bitwise_ops &&
+              (op1->ts.type == BT_INTEGER || op2->ts.type == BT_INTEGER))
+        {
+          e->ts.type = BT_INTEGER;
+          e->ts.kind = gfc_kind_max (op1, op2);
+          if (op1->ts.type == BT_LOGICAL)
+              gfc_convert_type (op1, &op2->ts, 1);
+          else if (op2->ts.type == BT_LOGICAL)
+              gfc_convert_type (op2, &op1->ts, 1);
+          e = logical_to_bitwise (e);
+          return resolve_function (e);
+        }
+
       sprintf (msg, _("Operands of logical operator '%s' at %%L are %s/%s"),
 	       gfc_op2string (e->value.op.op), gfc_typename (&op1->ts),
 	       gfc_typename (&op2->ts));
@@ -4009,6 +4095,15 @@ resolve_operator (gfc_expr *e)
 	  break;
 	}
 
+      /* Logical ops on integers become bitwise ops with -fdec-bitwise-ops */
+      else if (gfc_option.flag_dec_bitwise_ops && op1->ts.type == BT_INTEGER)
+        {
+          e->ts.type = BT_INTEGER;
+          e->ts.kind = op1->ts.kind;
+          e = logical_to_bitwise (e);
+          return resolve_function (e);
+        }
+
       sprintf (msg, _("Operand of .not. operator at %%L is %s"),
 	       gfc_typename (&op1->ts));
       goto bad_op;
@@ -5455,14 +5550,14 @@ resolve_procedure:
 	{
 	  gfc_component *c;
 	  c = ref2 ? ref2->u.c.component : e->symtree->n.sym->components;
-	  for ( ; c; c = c->next)
-	    if (c->attr.allocatable && c->ts.type == BT_CLASS)
-	      {
-		gfc_error ("Coindexed object with polymorphic allocatable "
-			 "subcomponent at %L", &e->where);
-		t = FAILURE;
-		break;
-	      }
+          for ( ; c; c = c->next)
+            if (c->attr.allocatable && c->ts.type == BT_CLASS)
+              {
+                gfc_error ("Coindexed object with polymorphic allocatable "
+                           "subcomponent at %L", &e->where);
+                t = FAILURE;
+                break;
+              }
 	}
     }
 
@@ -5935,7 +6030,7 @@ get_declared_from_expr (gfc_ref **class_ref, gfc_ref **new_ref,
 	continue;
 
       if ((ref->u.c.component->ts.type == BT_CLASS
-	     || (check_types && ref->u.c.component->ts.type == BT_DERIVED))
+	     || (check_types && gfc_bt_struct (ref->u.c.component->ts.type)))
 	  && ref->u.c.component->attr.flavor != FL_PROCEDURE)
 	{
 	  declared = ref->u.c.component->ts.u.derived;
@@ -6192,7 +6287,7 @@ resolve_typebound_function (gfc_expr* e)
 	 is present.  */
       ts = expr->ts;
       declared = ts.u.derived;
-      c = gfc_find_component (declared, "_vptr", true, true);
+      c = gfc_find_component (declared, "_vptr", true, true, NULL);
       if (c->ts.u.derived == NULL)
 	c->ts.u.derived = gfc_find_derived_vtab (declared);
 
@@ -6236,14 +6331,14 @@ resolve_typebound_function (gfc_expr* e)
   declared = get_declared_from_expr (&class_ref, &new_ref, e, true);
 
   /* Weed out cases of the ultimate component being a derived type.  */
-  if ((class_ref && class_ref->u.c.component->ts.type == BT_DERIVED)
+  if ((class_ref && gfc_bt_struct (class_ref->u.c.component->ts.type))
 	 || (!class_ref && st->n.sym->ts.type != BT_CLASS))
     {
       gfc_free_ref_list (new_ref);
       return resolve_compcall (e, NULL);
     }
 
-  c = gfc_find_component (declared, "_data", true, true);
+  c = gfc_find_component (declared, "_data", true, true, NULL);
   declared = c->ts.u.derived;
 
   /* Treat the call as if it is a typebound procedure, in order to roll
@@ -6320,7 +6415,7 @@ resolve_typebound_subroutine (gfc_code *code)
 	 that any delays in resolution are corrected and that the vtab
 	 is present.  */
       declared = expr->ts.u.derived;
-      c = gfc_find_component (declared, "_vptr", true, true);
+      c = gfc_find_component (declared, "_vptr", true, true, NULL);
       if (c->ts.u.derived == NULL)
 	c->ts.u.derived = gfc_find_derived_vtab (declared);
 
@@ -6365,7 +6460,7 @@ resolve_typebound_subroutine (gfc_code *code)
   get_declared_from_expr (&class_ref, &new_ref, code->expr1, true);
 
   /* Weed out cases of the ultimate component being a derived type.  */
-  if ((class_ref && class_ref->u.c.component->ts.type == BT_DERIVED)
+  if ((class_ref && gfc_bt_struct (class_ref->u.c.component->ts.type))
 	 || (!class_ref && st->n.sym->ts.type != BT_CLASS))
     {
       gfc_free_ref_list (new_ref);
@@ -6857,8 +6952,8 @@ derived_inaccessible (gfc_symbol *sym)
 
   for (c = sym->components; c; c = c->next)
     {
-	if (c->ts.type == BT_DERIVED && derived_inaccessible (c->ts.u.derived))
-	  return 1;
+      if (c->ts.type == BT_DERIVED && derived_inaccessible (c->ts.u.derived))
+        return 1;
     }
 
   return 0;
@@ -7310,7 +7405,7 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)
 	 using _copy and trans_call. It is convenient to exploit that
 	 when the allocated type is different from the declared type but
 	 no SOURCE exists by setting expr3.  */
-      code->expr3 = gfc_default_initializer (&code->ext.alloc.ts);
+      code->expr3 = gfc_default_initializer (&code->ext.alloc.ts, false);
     }
   else if (!code->expr3)
     {
@@ -7318,7 +7413,7 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)
       gfc_typespec ts;
       gfc_expr *init_e;
 
-      if (code->ext.alloc.ts.type == BT_DERIVED)
+      if (gfc_bt_struct (code->ext.alloc.ts.type))
 	ts = code->ext.alloc.ts;
       else
 	ts = e->ts;
@@ -7326,7 +7421,8 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)
       if (ts.type == BT_CLASS)
 	ts = ts.u.derived->components->ts;
 
-      if (ts.type == BT_DERIVED && (init_e = gfc_default_initializer (&ts)))
+      if (gfc_bt_struct (ts.type) && (init_e = gfc_default_initializer (&ts,
+                                                                        false)))
 	{
 	  gfc_code *init_st = gfc_get_code ();
 	  init_st->loc = code->loc;
@@ -7340,7 +7436,7 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)
   else if (code->expr3->mold && code->expr3->ts.type == BT_DERIVED)
     {
       /* Default initialization via MOLD (non-polymorphic).  */
-      gfc_expr *rhs = gfc_default_initializer (&code->expr3->ts);
+      gfc_expr *rhs = gfc_default_initializer (&code->expr3->ts, false);
       gfc_resolve_expr (rhs);
       gfc_free_expr (code->expr3);
       code->expr3 = rhs;
@@ -7442,7 +7538,7 @@ check_symbols:
 	  sym = a->expr->symtree->n.sym;
 
 	  /* TODO - check derived type components.  */
-	  if (sym->ts.type == BT_DERIVED || sym->ts.type == BT_CLASS)
+	  if (gfc_bt_struct (sym->ts.type) || sym->ts.type == BT_CLASS)
 	    continue;
 
 	  if ((ar->start[i] != NULL
@@ -9799,7 +9895,7 @@ nonscalar_typebound_assign (gfc_symbol *derived, int depth)
 
   for (c= derived->components; c; c = c->next)
     {
-      if ((c->ts.type != BT_DERIVED
+      if ((!gfc_bt_struct (c->ts.type)
 	    || c->attr.pointer
 	    || c->attr.allocatable
 	    || c->attr.proc_pointer_comp
@@ -9873,9 +9969,172 @@ static int component_assignment_level = 0;
 static gfc_code *tmp_head = NULL, *tmp_tail = NULL;
 
 static void
+generate_derived_component_assignments (gfc_code **code, gfc_namespace *ns,
+    gfc_code **this_code, gfc_code **head, gfc_code **tail, gfc_expr **t1,
+    gfc_symbol *d1, gfc_symbol *d2)
+{
+  gfc_component *comp1, *comp2, *map1, *map2;
+
+  comp1 = d1->components;
+  comp2 = d2->components;
+
+  for (; comp1; comp1 = comp1->next, comp2 = comp2->next)
+  {
+    bool inout = false;
+
+    /* For unions, just recurse into the maps. */
+    if (comp1->ts.type == BT_UNION)
+    {
+      map1 = comp1->ts.u.derived->components;
+      map2 = comp2->ts.u.derived->components;
+      for (; map1; map1 = map1->next, map2 = map2->next)
+      {
+        generate_derived_component_assignments (code, ns,
+            this_code, head, tail, t1, map1->ts.u.derived, map2->ts.u.derived);
+      }
+      continue;
+    }
+
+    /* The intrinsic assignment does the right thing for pointers
+       of all kinds and allocatable components.  */
+    if (comp1->ts.type != BT_DERIVED
+        || comp1->attr.pointer
+        || comp1->attr.allocatable
+        || comp1->attr.proc_pointer_comp
+        || comp1->attr.class_pointer
+        || comp1->attr.proc_pointer)
+      continue;
+
+    /* Make an assigment for this component.  */
+    *this_code = build_assignment (EXEC_ASSIGN,
+                                  (*code)->expr1, (*code)->expr2,
+                                  comp1, comp2, (*code)->loc);
+
+    /* Convert the assignment if there is a defined assignment for
+       this type.  Otherwise, using the call from resolve_code,
+       recurse into its components.  */
+    resolve_code (*this_code, ns);
+
+    if ((*this_code)->op == EXEC_ASSIGN_CALL)
+      {
+        gfc_formal_arglist *dummy_args;
+        gfc_symbol *rsym;
+        /* Check that there is a typebound defined assignment.  If not,
+           then this must be a module defined assignment.  We cannot
+           use the defined_assign_comp attribute here because it must
+           be this derived type that has the defined assignment and not
+           a parent type.  */
+        if (!(comp1->ts.u.derived->f2k_derived
+              && comp1->ts.u.derived->f2k_derived
+                                      ->tb_op[INTRINSIC_ASSIGN]))
+          {
+            gfc_free_statements (*this_code);
+            *this_code = NULL;
+            continue;
+          }
+
+        /* If the first argument of the subroutine has intent INOUT
+           a temporary must be generated and used instead.  */
+        rsym = (*this_code)->resolved_sym;
+        dummy_args = gfc_sym_get_dummy_args (rsym);
+        if (dummy_args
+            && dummy_args->sym->attr.intent == INTENT_INOUT)
+          {
+            gfc_code *temp_code;
+            inout = true;
+
+            /* Build the temporary required for the assignment and put
+               it at the head of the generated code.  */
+            if (!*t1)
+              {
+                *t1 = get_temp_from_expr ((*code)->expr1, ns);
+                temp_code = build_assignment (EXEC_ASSIGN,
+                                              *t1, (*code)->expr1,
+                              NULL, NULL, (*code)->loc);
+
+                /* For allocatable LHS, check whether it is allocated.  Note
+                   that allocatable components with defined assignment are
+                   not yet support.  See PR 57696.  */
+                if ((*code)->expr1->symtree->n.sym->attr.allocatable)
+                  {
+                    gfc_code *block;
+                    gfc_expr *e =
+                      gfc_lval_expr_from_sym ((*code)->expr1->symtree->n.sym);
+                    block = gfc_get_code ();
+                    block->op = EXEC_IF;
+                    block->block = gfc_get_code ();
+                    block->block->op = EXEC_IF;
+                    block->block->expr1
+                        = gfc_build_intrinsic_call (ns,
+                                  GFC_ISYM_ALLOCATED, "allocated",
+                                  (*code)->loc, 1, e);
+                    block->block->next = temp_code;
+                    temp_code = block;
+                  }
+                add_code_to_chain (&temp_code, &tmp_head, &tmp_tail);
+              }
+
+            /* Replace the first actual arg with the component of the
+               temporary.  */
+            gfc_free_expr ((*this_code)->ext.actual->expr);
+            (*this_code)->ext.actual->expr = gfc_copy_expr (*t1);
+            add_comp_ref ((*this_code)->ext.actual->expr, comp1);
+
+            /* If the LHS variable is allocatable and wasn't allocated and
+               the temporary is allocatable, pointer assign the address of
+               the freshly allocated LHS to the temporary.  */
+            if ((*code)->expr1->symtree->n.sym->attr.allocatable
+                && gfc_expr_attr ((*code)->expr1).allocatable)
+              {
+                gfc_code *block;
+                gfc_expr *cond;
+
+                cond = gfc_get_expr ();
+                cond->ts.type = BT_LOGICAL;
+                cond->ts.kind = gfc_default_logical_kind;
+                cond->expr_type = EXPR_OP;
+                cond->where = (*code)->loc;
+                cond->value.op.op = INTRINSIC_NOT;
+                cond->value.op.op1 = gfc_build_intrinsic_call (ns,
+                                        GFC_ISYM_ALLOCATED, "allocated",
+                                        (*code)->loc, 1, gfc_copy_expr (*t1));
+                block = gfc_get_code ();
+                block->op = EXEC_IF;
+                block->block = gfc_get_code ();
+                block->block->op = EXEC_IF;
+                block->block->expr1 = cond;
+                block->block->next = build_assignment (EXEC_POINTER_ASSIGN,
+                                      *t1, (*code)->expr1,
+                                      NULL, NULL, (*code)->loc);
+                add_code_to_chain (&block, head, tail);
+              }
+          }
+      }
+    else if ((*this_code)->op == EXEC_ASSIGN && !(*this_code)->next)
+      {
+        /* Don't add intrinsic assignments since they are already
+           effected by the intrinsic assignment of the structure.  */
+        gfc_free_statements (*this_code);
+        (*this_code) = NULL;
+        continue;
+      }
+
+    add_code_to_chain (this_code, head, tail);
+
+    if (*t1 && inout)
+      {
+        /* Transfer the value to the final result.  */
+        *this_code = build_assignment (EXEC_ASSIGN,
+                                      (*code)->expr1, *t1,
+                                      comp1, comp2, (*code)->loc);
+        add_code_to_chain (this_code, head, tail);
+      }
+  }
+}
+
+static void
 generate_component_assignments (gfc_code **code, gfc_namespace *ns)
 {
-  gfc_component *comp1, *comp2;
   gfc_code *this_code = NULL, *head = NULL, *tail = NULL;
   gfc_expr *t1;
   int error_count, depth;
@@ -9929,149 +10188,11 @@ generate_component_assignments (gfc_code **code, gfc_namespace *ns)
       add_code_to_chain (&this_code, &head, &tail);
     }
 
-  comp1 = (*code)->expr1->ts.u.derived->components;
-  comp2 = (*code)->expr2->ts.u.derived->components;
-
   t1 = NULL;
-  for (; comp1; comp1 = comp1->next, comp2 = comp2->next)
-    {
-      bool inout = false;
-
-      /* The intrinsic assignment does the right thing for pointers
-	 of all kinds and allocatable components.  */
-      if (comp1->ts.type != BT_DERIVED
-	  || comp1->attr.pointer
-	  || comp1->attr.allocatable
-	  || comp1->attr.proc_pointer_comp
-	  || comp1->attr.class_pointer
-	  || comp1->attr.proc_pointer)
-	continue;
-
-      /* Make an assigment for this component.  */
-      this_code = build_assignment (EXEC_ASSIGN,
-				    (*code)->expr1, (*code)->expr2,
-				    comp1, comp2, (*code)->loc);
-
-      /* Convert the assignment if there is a defined assignment for
-	 this type.  Otherwise, using the call from resolve_code,
-	 recurse into its components.  */
-      resolve_code (this_code, ns);
-
-      if (this_code->op == EXEC_ASSIGN_CALL)
-	{
-	  gfc_formal_arglist *dummy_args;
-	  gfc_symbol *rsym;
-	  /* Check that there is a typebound defined assignment.  If not,
-	     then this must be a module defined assignment.  We cannot
-	     use the defined_assign_comp attribute here because it must
-	     be this derived type that has the defined assignment and not
-	     a parent type.  */
-	  if (!(comp1->ts.u.derived->f2k_derived
-		&& comp1->ts.u.derived->f2k_derived
-					->tb_op[INTRINSIC_ASSIGN]))
-	    {
-	      gfc_free_statements (this_code);
-	      this_code = NULL;
-	      continue;
-	    }
-
-	  /* If the first argument of the subroutine has intent INOUT
-	     a temporary must be generated and used instead.  */
-	  rsym = this_code->resolved_sym;
-	  dummy_args = gfc_sym_get_dummy_args (rsym);
-	  if (dummy_args
-	      && dummy_args->sym->attr.intent == INTENT_INOUT)
-	    {
-	      gfc_code *temp_code;
-	      inout = true;
-
-	      /* Build the temporary required for the assignment and put
-		 it at the head of the generated code.  */
-	      if (!t1)
-		{
-		  t1 = get_temp_from_expr ((*code)->expr1, ns);
-		  temp_code = build_assignment (EXEC_ASSIGN,
-						t1, (*code)->expr1,
-				NULL, NULL, (*code)->loc);
-
-		  /* For allocatable LHS, check whether it is allocated.  Note
-		     that allocatable components with defined assignment are
-		     not yet support.  See PR 57696.  */
-		  if ((*code)->expr1->symtree->n.sym->attr.allocatable)
-		    {
-		      gfc_code *block;
-		      gfc_expr *e =
-			gfc_lval_expr_from_sym ((*code)->expr1->symtree->n.sym);
-		      block = gfc_get_code ();
-		      block->op = EXEC_IF;
-		      block->block = gfc_get_code ();
-		      block->block->op = EXEC_IF;
-		      block->block->expr1
-			  = gfc_build_intrinsic_call (ns,
-				    GFC_ISYM_ALLOCATED, "allocated",
-				    (*code)->loc, 1, e);
-		      block->block->next = temp_code;
-		      temp_code = block;
-		    }
-		  add_code_to_chain (&temp_code, &tmp_head, &tmp_tail);
-		}
-
-	      /* Replace the first actual arg with the component of the
-		 temporary.  */
-	      gfc_free_expr (this_code->ext.actual->expr);
-	      this_code->ext.actual->expr = gfc_copy_expr (t1);
-	      add_comp_ref (this_code->ext.actual->expr, comp1);
-
-	      /* If the LHS variable is allocatable and wasn't allocated and
-                 the temporary is allocatable, pointer assign the address of
-                 the freshly allocated LHS to the temporary.  */
-	      if ((*code)->expr1->symtree->n.sym->attr.allocatable
-		  && gfc_expr_attr ((*code)->expr1).allocatable)
-		{
-		  gfc_code *block;
-		  gfc_expr *cond;
-
-		  cond = gfc_get_expr ();
-		  cond->ts.type = BT_LOGICAL;
-		  cond->ts.kind = gfc_default_logical_kind;
-		  cond->expr_type = EXPR_OP;
-		  cond->where = (*code)->loc;
-		  cond->value.op.op = INTRINSIC_NOT;
-		  cond->value.op.op1 = gfc_build_intrinsic_call (ns,
-					  GFC_ISYM_ALLOCATED, "allocated",
-					  (*code)->loc, 1, gfc_copy_expr (t1));
-		  block = gfc_get_code ();
-		  block->op = EXEC_IF;
-		  block->block = gfc_get_code ();
-		  block->block->op = EXEC_IF;
-		  block->block->expr1 = cond;
-		  block->block->next = build_assignment (EXEC_POINTER_ASSIGN,
-					t1, (*code)->expr1,
-					NULL, NULL, (*code)->loc);
-		  add_code_to_chain (&block, &head, &tail);
-		}
-	    }
-	}
-      else if (this_code->op == EXEC_ASSIGN && !this_code->next)
-	{
-	  /* Don't add intrinsic assignments since they are already
-	     effected by the intrinsic assignment of the structure.  */
-	  gfc_free_statements (this_code);
-	  this_code = NULL;
-	  continue;
-	}
-
-      add_code_to_chain (&this_code, &head, &tail);
 
-      if (t1 && inout)
-	{
-	  /* Transfer the value to the final result.  */
-	  this_code = build_assignment (EXEC_ASSIGN,
-					(*code)->expr1, t1,
-					comp1, comp2, (*code)->loc);
-	  add_code_to_chain (&this_code, &head, &tail);
-	}
-    }
+  generate_derived_component_assignments (code, ns,
+      &this_code, &head, &tail, &t1,
+      (*code)->expr1->ts.u.derived, (*code)->expr2->ts.u.derived);
 
   /* Put the temporary assignments at the top of the generated code.  */
   if (tmp_head && component_assignment_level == 1)
@@ -10643,7 +10764,7 @@ resolve_bind_c_comms (gfc_symtree *comm_block_tree)
 static void
 resolve_bind_c_derived_types (gfc_symbol *derived_sym)
 {
-  if (derived_sym != NULL && derived_sym->attr.flavor == FL_DERIVED
+  if (derived_sym != NULL && gfc_fl_struct (derived_sym->attr.flavor)
       && derived_sym->attr.is_bind_c == 1)
     verify_bind_c_derived_type (derived_sym);
 
@@ -10660,7 +10781,7 @@ gfc_verify_binding_labels (gfc_symbol *sym)
   int has_error = 0;
 
   if (sym != NULL && sym->attr.is_bind_c && sym->attr.is_iso_c == 0
-      && sym->attr.flavor != FL_DERIVED && sym->binding_label)
+      && !gfc_fl_struct (sym->attr.flavor) && sym->binding_label)
     {
       gfc_gsymbol *bind_c_sym;
 
@@ -10895,6 +11016,34 @@ build_init_assign (gfc_symbol *sym, gfc_expr *init)
   init_st->expr2 = init;
 }
 
+/* Whether or not we can create an initializer for the given symbol.  */
+
+static bool
+can_create_init (gfc_symbol *sym)
+{
+  symbol_attribute *a;
+  if (!sym)
+    return false;
+  a = &sym->attr;
+
+  /* These symbols should never have a default initialization.  */
+  return !(
+       a->allocatable
+    || a->external
+    || a->pointer
+    || a->in_equivalence
+    || a->in_common
+    || a->data
+    || sym->module
+    || a->cray_pointee
+    || a->cray_pointer
+    || sym->assoc
+    || (!a->referenced && !a->result)
+    || (a->dummy && a->intent != INTENT_OUT)
+    || (a->function && sym != sym->result)
+  );
+} 
+
 /* Assign the default initializer to a derived type variable or result.  */
 
 static void
@@ -10906,7 +11055,7 @@ apply_default_init (gfc_symbol *sym)
     return;
 
   if (sym->ts.type == BT_DERIVED && sym->ts.u.derived)
-    init = gfc_default_initializer (&sym->ts);
+    init = gfc_default_initializer (&sym->ts, can_create_init (sym));
 
   if (init == NULL && sym->ts.type != BT_CLASS)
     return;
@@ -10915,17 +11064,11 @@ apply_default_init (gfc_symbol *sym)
   sym->attr.referenced = 1;
 }
 
-/* Build an initializer for a local integer, real, complex, logical, or
-   character variable, based on the command line flags finit-local-zero,
-   finit-integer=, finit-real=, finit-logical=, and finit-runtime.  Returns
-   null if the symbol should not have a default initialization.  */
+/* Wrapper around gfc_build_default_init_expr that takes a symbol and
+   returns NULL if the symbol should not have a default initializer. */
 static gfc_expr *
 build_default_init_expr (gfc_symbol *sym)
 {
-  int char_len;
-  gfc_expr *init_expr;
-  int i;
-
   /* These symbols should never have a default initialization.  */
   if (sym->attr.allocatable
       || sym->attr.external
@@ -10940,145 +11083,8 @@ build_default_init_expr (gfc_symbol *sym)
       || sym->assoc)
     return NULL;
 
-  /* Now we'll try to build an initializer expression.  */
-  init_expr = gfc_get_constant_expr (sym->ts.type, sym->ts.kind,
-				     &sym->declared_at);
-
-  /* We will only initialize integers, reals, complex, logicals, and
-     characters, and only if the corresponding command-line flags
-     were set.  Otherwise, we free init_expr and return null.  */
-  switch (sym->ts.type)
-    {
-    case BT_INTEGER:
-      if (gfc_option.flag_init_integer != GFC_INIT_INTEGER_OFF)
-	mpz_set_si (init_expr->value.integer,
-			 gfc_option.flag_init_integer_value);
-      else
-	{
-	  gfc_free_expr (init_expr);
-	  init_expr = NULL;
-	}
-      break;
-
-    case BT_REAL:
-      switch (gfc_option.flag_init_real)
-	{
-	case GFC_INIT_REAL_SNAN:
-	  init_expr->is_snan = 1;
-	  /* Fall through.  */
-	case GFC_INIT_REAL_NAN:
-	  mpfr_set_nan (init_expr->value.real);
-	  break;
-
-	case GFC_INIT_REAL_INF:
-	  mpfr_set_inf (init_expr->value.real, 1);
-	  break;
-
-	case GFC_INIT_REAL_NEG_INF:
-	  mpfr_set_inf (init_expr->value.real, -1);
-	  break;
-
-	case GFC_INIT_REAL_ZERO:
-	  mpfr_set_ui (init_expr->value.real, 0.0, GFC_RND_MODE);
-	  break;
-
-	default:
-	  gfc_free_expr (init_expr);
-	  init_expr = NULL;
-	  break;
-	}
-      break;
-
-    case BT_COMPLEX:
-      switch (gfc_option.flag_init_real)
-	{
-	case GFC_INIT_REAL_SNAN:
-	  init_expr->is_snan = 1;
-	  /* Fall through.  */
-	case GFC_INIT_REAL_NAN:
-	  mpfr_set_nan (mpc_realref (init_expr->value.complex));
-	  mpfr_set_nan (mpc_imagref (init_expr->value.complex));
-	  break;
-
-	case GFC_INIT_REAL_INF:
-	  mpfr_set_inf (mpc_realref (init_expr->value.complex), 1);
-	  mpfr_set_inf (mpc_imagref (init_expr->value.complex), 1);
-	  break;
-
-	case GFC_INIT_REAL_NEG_INF:
-	  mpfr_set_inf (mpc_realref (init_expr->value.complex), -1);
-	  mpfr_set_inf (mpc_imagref (init_expr->value.complex), -1);
-	  break;
-
-	case GFC_INIT_REAL_ZERO:
-	  mpc_set_ui (init_expr->value.complex, 0, GFC_MPC_RND_MODE);
-	  break;
-
-	default:
-	  gfc_free_expr (init_expr);
-	  init_expr = NULL;
-	  break;
-	}
-      break;
-
-    case BT_LOGICAL:
-      if (gfc_option.flag_init_logical == GFC_INIT_LOGICAL_FALSE)
-	init_expr->value.logical = 0;
-      else if (gfc_option.flag_init_logical == GFC_INIT_LOGICAL_TRUE)
-	init_expr->value.logical = 1;
-      else
-	{
-	  gfc_free_expr (init_expr);
-	  init_expr = NULL;
-	}
-      break;
-
-    case BT_CHARACTER:
-      /* For characters, the length must be constant in order to
-	 create a default initializer.  */
-      if (gfc_option.flag_init_character == GFC_INIT_CHARACTER_ON
-	  && sym->ts.u.cl->length
-	  && sym->ts.u.cl->length->expr_type == EXPR_CONSTANT)
-	{
-	  char_len = mpz_get_si (sym->ts.u.cl->length->value.integer);
-	  init_expr->value.character.length = char_len;
-	  init_expr->value.character.string = gfc_get_wide_string (char_len+1);
-	  for (i = 0; i < char_len; i++)
-	    init_expr->value.character.string[i]
-	      = (unsigned char) gfc_option.flag_init_character_value;
-	}
-      else
-	{
-	  gfc_free_expr (init_expr);
-	  init_expr = NULL;
-	}
-      if (!init_expr && gfc_option.flag_init_character == GFC_INIT_CHARACTER_ON
-	  && sym->ts.u.cl->length && gfc_option.flag_max_stack_var_size != 0)
-	{
-	  gfc_actual_arglist *arg;
-	  init_expr = gfc_get_expr ();
-	  init_expr->where = sym->declared_at;
-	  init_expr->ts = sym->ts;
-	  init_expr->expr_type = EXPR_FUNCTION;
-	  init_expr->value.function.isym =
-		gfc_intrinsic_function_by_id (GFC_ISYM_REPEAT);
-	  init_expr->value.function.name = "repeat";
-	  arg = gfc_get_actual_arglist ();
-	  arg->expr = gfc_get_character_expr (sym->ts.kind, &sym->declared_at,
-					      NULL, 1);
-	  arg->expr->value.character.string[0]
-		= gfc_option.flag_init_character_value;
-	  arg->next = gfc_get_actual_arglist ();
-	  arg->next->expr = gfc_copy_expr (sym->ts.u.cl->length);
-	  init_expr->value.function.actual = arg;
-	}
-      break;
-
-    default:
-     gfc_free_expr (init_expr);
-     init_expr = NULL;
-    }
-  return init_expr;
+  /* Get the appropriate init expression. */
+  return gfc_build_default_init_expr(&sym->ts, &sym->declared_at);
 }
 
 /* Add an initialization expression to a local variable.  */
@@ -11102,9 +11108,11 @@ apply_default_init_local (gfc_symbol *sym)
      entry, so we just add a static initializer. Note that automatic variables
      are stack allocated even with -fno-automatic; we have also to exclude
      result variable, which are also nonstatic.  */
-  if (sym->attr.save || sym->ns->save_all
-      || (gfc_option.flag_max_stack_var_size == 0 && !sym->attr.result
-	  && (!sym->attr.dimension || !is_non_constant_shape_array (sym))))
+  if (!sym->attr.automatic
+      && (sym->attr.save || sym->ns->save_all
+          || (gfc_option.flag_max_stack_var_size == 0 && !sym->attr.result
+              && !sym->ns->proc_name->attr.recursive
+              && (!sym->attr.dimension || !is_non_constant_shape_array (sym)))))
     {
       /* Don't clobber an existing initializer!  */
       gcc_assert (sym->value == NULL);
@@ -11228,7 +11236,7 @@ resolve_fl_variable_derived (gfc_symbol *sym, int no_init_flag)
       gfc_find_symbol (sym->ts.u.derived->name, sym->ns, 0, &s);
       if (s && s->attr.generic)
 	s = gfc_find_dt_in_generic (s);
-      if (s && s->attr.flavor != FL_DERIVED)
+      if (s && !gfc_fl_struct (s->attr.flavor))
 	{
 	  gfc_error ("The type '%s' cannot be host associated at %L "
 		     "because it is blocked by an incompatible object "
@@ -11249,7 +11257,7 @@ resolve_fl_variable_derived (gfc_symbol *sym, int no_init_flag)
      a hidden default for allocatable components.  */
   if (!(sym->value || no_init_flag) && sym->ns->proc_name
       && sym->ns->proc_name->attr.flavor == FL_MODULE
-      && !sym->ns->save_all && !sym->attr.save
+      && !(sym->ns->save_all && !sym->attr.automatic) && !sym->attr.save
       && !sym->attr.pointer && !sym->attr.allocatable
       && gfc_has_default_initializer (sym->ts.u.derived)
       && gfc_notify_std (GFC_STD_F2008, "Implied SAVE for "
@@ -11262,7 +11270,7 @@ resolve_fl_variable_derived (gfc_symbol *sym, int no_init_flag)
   if (!(sym->value || sym->attr.pointer || sym->attr.allocatable)
       && (!no_init_flag || sym->attr.intent == INTENT_OUT))
     {
-      sym->value = gfc_default_initializer (&sym->ts);
+      sym->value = gfc_default_initializer (&sym->ts, can_create_init (sym));
     }
 
   return SUCCESS;
@@ -12226,7 +12234,7 @@ resolve_typebound_procedure (gfc_symtree* stree)
   locus where;
   gfc_symbol* me_arg;
   gfc_symbol* super_type;
-  gfc_component* comp;
+  gfc_component *comp;
 
   gcc_assert (stree);
 
@@ -12403,7 +12411,8 @@ resolve_typebound_procedure (gfc_symtree* stree)
       }
 
   /* Try to find a name collision with an inherited component.  */
-  if (super_type && gfc_find_component (super_type, stree->name, true, true))
+  if (super_type && gfc_find_component (super_type, stree->name, true, true,
+                                        NULL))
     {
       gfc_error ("Procedure '%s' at %L has the same name as an inherited"
 		 " component of '%s'",
@@ -12551,7 +12560,7 @@ check_defined_assignments (gfc_symbol *derived)
 
   for (c = derived->components; c; c = c->next)
     {
-      if (c->ts.type != BT_DERIVED
+      if (!gfc_bt_struct (c->ts.type)
 	  || c->attr.pointer
 	  || c->attr.allocatable
 	  || c->attr.proc_pointer_comp
@@ -12576,402 +12585,440 @@ check_defined_assignments (gfc_symbol *derived)
     }
 }
 
-
-/* Resolve the components of a derived type. This does not have to wait until
-   resolution stage, but can be done as soon as the dt declaration has been
-   parsed.  */
+/* Resolve a component (for resolve_fl_derived0). */
 
 static gfc_try
-resolve_fl_derived0 (gfc_symbol *sym)
+resolve_component (gfc_component *c, void *data)
 {
-  gfc_symbol* super_type;
-  gfc_component *c;
+  gfc_symbol *sym = (gfc_symbol *)data;
+  gfc_symbol *super_type = gfc_get_derived_super_type (sym);
 
-  if (sym->attr.unlimited_polymorphic)
+  if (c->attr.artificial)
     return SUCCESS;
 
-  super_type = gfc_get_derived_super_type (sym);
+  /* See PRs 51550, 47545, 48654, 49050, 51075 - and 45170.  */
+  if (c->ts.type == BT_CHARACTER && c->ts.deferred && !c->attr.function)
+    {
+      gfc_error ("Deferred-length character component '%s' at %L is not "
+                 "yet supported", c->name, &c->loc);
+      return FAILURE;
+    }
 
-  /* F2008, C432. */
-  if (super_type && sym->attr.coarray_comp && !super_type->attr.coarray_comp)
+  /* F2008, C442.  */
+  if ((!sym->attr.is_class || c != sym->components)
+      && c->attr.codimension
+      && (!c->attr.allocatable || (c->as && c->as->type != AS_DEFERRED)))
     {
-      gfc_error ("As extending type '%s' at %L has a coarray component, "
-		 "parent type '%s' shall also have one", sym->name,
-		 &sym->declared_at, super_type->name);
+      gfc_error ("Coarray component '%s' at %L must be allocatable with "
+                 "deferred shape", c->name, &c->loc);
       return FAILURE;
     }
 
-  /* Ensure the extended type gets resolved before we do.  */
-  if (super_type && resolve_fl_derived0 (super_type) == FAILURE)
-    return FAILURE;
+  /* F2008, C443.  */
+  if (c->attr.codimension && c->ts.type == BT_DERIVED
+      && c->ts.u.derived->ts.is_iso_c)
+    {
+      gfc_error ("Component '%s' at %L of TYPE(C_PTR) or TYPE(C_FUNPTR) "
+                 "shall not be a coarray", c->name, &c->loc);
+      return FAILURE;
+    }
 
-  /* An ABSTRACT type must be extensible.  */
-  if (sym->attr.abstract && !gfc_type_is_extensible (sym))
+  /* F2008, C444.  */
+  if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.coarray_comp
+      && (c->attr.codimension || c->attr.pointer || c->attr.dimension
+          || c->attr.allocatable))
     {
-      gfc_error ("Non-extensible derived-type '%s' at %L must not be ABSTRACT",
-		 sym->name, &sym->declared_at);
+      gfc_error ("Component '%s' at %L with coarray component "
+                 "shall be a nonpointer, nonallocatable scalar",
+                 c->name, &c->loc);
       return FAILURE;
     }
 
-  c = (sym->attr.is_class) ? sym->components->ts.u.derived->components
-			   : sym->components;
+  /* F2008, C448.  */
+  if (c->attr.contiguous && (!c->attr.dimension || !c->attr.pointer))
+    {
+      gfc_error ("Component '%s' at %L has the CONTIGUOUS attribute but "
+                 "is not an array pointer", c->name, &c->loc);
+      return FAILURE;
+    }
 
-  for ( ; c != NULL; c = c->next)
+  if (c->attr.proc_pointer && c->ts.interface)
     {
-      if (c->attr.artificial)
-	continue;
+      gfc_symbol *ifc = c->ts.interface;
 
-      /* See PRs 51550, 47545, 48654, 49050, 51075 - and 45170.  */
-      if (c->ts.type == BT_CHARACTER && c->ts.deferred && !c->attr.function)
-	{
-	  gfc_error ("Deferred-length character component '%s' at %L is not "
-		     "yet supported", c->name, &c->loc);
-	  return FAILURE;
-	}
+      if (!sym->attr.vtype
+          && check_proc_interface (ifc, &c->loc) == FAILURE)
+        return FAILURE;
 
-      /* F2008, C442.  */
-      if ((!sym->attr.is_class || c != sym->components)
-	  && c->attr.codimension
-	  && (!c->attr.allocatable || (c->as && c->as->type != AS_DEFERRED)))
-	{
-	  gfc_error ("Coarray component '%s' at %L must be allocatable with "
-		     "deferred shape", c->name, &c->loc);
-	  return FAILURE;
-	}
+      if (ifc->attr.if_source || ifc->attr.intrinsic)
+        {
+          /* Resolve interface and copy attributes.  */
+          if (ifc->formal && !ifc->formal_ns)
+            resolve_symbol (ifc);
+          if (ifc->attr.intrinsic)
+            gfc_resolve_intrinsic (ifc, &ifc->declared_at);
 
-      /* F2008, C443.  */
-      if (c->attr.codimension && c->ts.type == BT_DERIVED
-	  && c->ts.u.derived->ts.is_iso_c)
-	{
-	  gfc_error ("Component '%s' at %L of TYPE(C_PTR) or TYPE(C_FUNPTR) "
-		     "shall not be a coarray", c->name, &c->loc);
-	  return FAILURE;
-	}
+          if (ifc->result)
+            {
+              c->ts = ifc->result->ts;
+              c->attr.allocatable = ifc->result->attr.allocatable;
+              c->attr.pointer = ifc->result->attr.pointer;
+              c->attr.dimension = ifc->result->attr.dimension;
+              c->as = gfc_copy_array_spec (ifc->result->as);
+              c->attr.class_ok = ifc->result->attr.class_ok;
+            }
+          else
+            {
+              c->ts = ifc->ts;
+              c->attr.allocatable = ifc->attr.allocatable;
+              c->attr.pointer = ifc->attr.pointer;
+              c->attr.dimension = ifc->attr.dimension;
+              c->as = gfc_copy_array_spec (ifc->as);
+              c->attr.class_ok = ifc->attr.class_ok;
+            }
+          c->ts.interface = ifc;
+          c->attr.function = ifc->attr.function;
+          c->attr.subroutine = ifc->attr.subroutine;
+
+          c->attr.pure = ifc->attr.pure;
+          c->attr.elemental = ifc->attr.elemental;
+          c->attr.recursive = ifc->attr.recursive;
+          c->attr.always_explicit = ifc->attr.always_explicit;
+          c->attr.ext_attr |= ifc->attr.ext_attr;
+          /* Copy char length.  */
+          if (ifc->ts.type == BT_CHARACTER && ifc->ts.u.cl)
+            {
+              gfc_charlen *cl = gfc_new_charlen (sym->ns, ifc->ts.u.cl);
+              if (cl->length && !cl->resolved
+                  && gfc_resolve_expr (cl->length) == FAILURE)
+                return FAILURE;
+              c->ts.u.cl = cl;
+            }
+        }
+    }
+  else if (c->attr.proc_pointer && c->ts.type == BT_UNKNOWN)
+    {
+      /* Since PPCs are not implicitly typed, a PPC without an explicit
+         interface must be a subroutine.  */
+      gfc_add_subroutine (&c->attr, c->name, &c->loc);
+    }
 
-      /* F2008, C444.  */
-      if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.coarray_comp
-	  && (c->attr.codimension || c->attr.pointer || c->attr.dimension
-	      || c->attr.allocatable))
-	{
-	  gfc_error ("Component '%s' at %L with coarray component "
-		     "shall be a nonpointer, nonallocatable scalar",
-		     c->name, &c->loc);
-	  return FAILURE;
-	}
+  /* Procedure pointer components: Check PASS arg.  */
+  if (c->attr.proc_pointer && !c->tb->nopass && c->tb->pass_arg_num == 0
+      && !sym->attr.vtype)
+    {
+      gfc_symbol* me_arg;
 
-      /* F2008, C448.  */
-      if (c->attr.contiguous && (!c->attr.dimension || !c->attr.pointer))
-	{
-	  gfc_error ("Component '%s' at %L has the CONTIGUOUS attribute but "
-		     "is not an array pointer", c->name, &c->loc);
-	  return FAILURE;
-	}
+      if (c->tb->pass_arg)
+        {
+          gfc_formal_arglist* i;
 
-      if (c->attr.proc_pointer && c->ts.interface)
-	{
-	  gfc_symbol *ifc = c->ts.interface;
+          /* If an explicit passing argument name is given, walk the arg-list
+            and look for it.  */
 
-	  if (!sym->attr.vtype
-	      && check_proc_interface (ifc, &c->loc) == FAILURE)
-	    return FAILURE;
+          me_arg = NULL;
+          c->tb->pass_arg_num = 1;
+          for (i = c->ts.interface->formal; i; i = i->next)
+            {
+              if (!strcmp (i->sym->name, c->tb->pass_arg))
+                {
+                  me_arg = i->sym;
+                  break;
+                }
+              c->tb->pass_arg_num++;
+            }
 
-	  if (ifc->attr.if_source || ifc->attr.intrinsic)
-	    {
-	      /* Resolve interface and copy attributes.  */
-	      if (ifc->formal && !ifc->formal_ns)
-		resolve_symbol (ifc);
-	      if (ifc->attr.intrinsic)
-		gfc_resolve_intrinsic (ifc, &ifc->declared_at);
+          if (!me_arg)
+            {
+              gfc_error ("Procedure pointer component '%s' with PASS(%s) "
+                         "at %L has no argument '%s'", c->name,
+                         c->tb->pass_arg, &c->loc, c->tb->pass_arg);
+              c->tb->error = 1;
+              return FAILURE;
+            }
+        }
+      else
+        {
+          /* Otherwise, take the first one; there should in fact be at least
+            one.  */
+          c->tb->pass_arg_num = 1;
+          if (!c->ts.interface->formal)
+            {
+              gfc_error ("Procedure pointer component '%s' with PASS at %L "
+                         "must have at least one argument",
+                         c->name, &c->loc);
+              c->tb->error = 1;
+              return FAILURE;
+            }
+          me_arg = c->ts.interface->formal->sym;
+        }
 
-	      if (ifc->result)
-		{
-		  c->ts = ifc->result->ts;
-		  c->attr.allocatable = ifc->result->attr.allocatable;
-		  c->attr.pointer = ifc->result->attr.pointer;
-		  c->attr.dimension = ifc->result->attr.dimension;
-		  c->as = gfc_copy_array_spec (ifc->result->as);
-		  c->attr.class_ok = ifc->result->attr.class_ok;
-		}
-	      else
-		{
-		  c->ts = ifc->ts;
-		  c->attr.allocatable = ifc->attr.allocatable;
-		  c->attr.pointer = ifc->attr.pointer;
-		  c->attr.dimension = ifc->attr.dimension;
-		  c->as = gfc_copy_array_spec (ifc->as);
-		  c->attr.class_ok = ifc->attr.class_ok;
-		}
-	      c->ts.interface = ifc;
-	      c->attr.function = ifc->attr.function;
-	      c->attr.subroutine = ifc->attr.subroutine;
-
-	      c->attr.pure = ifc->attr.pure;
-	      c->attr.elemental = ifc->attr.elemental;
-	      c->attr.recursive = ifc->attr.recursive;
-	      c->attr.always_explicit = ifc->attr.always_explicit;
-	      c->attr.ext_attr |= ifc->attr.ext_attr;
-	      /* Copy char length.  */
-	      if (ifc->ts.type == BT_CHARACTER && ifc->ts.u.cl)
-		{
-		  gfc_charlen *cl = gfc_new_charlen (sym->ns, ifc->ts.u.cl);
-		  if (cl->length && !cl->resolved
-		      && gfc_resolve_expr (cl->length) == FAILURE)
-		    return FAILURE;
-		  c->ts.u.cl = cl;
-		}
-	    }
-	}
-      else if (c->attr.proc_pointer && c->ts.type == BT_UNKNOWN)
-	{
-	  /* Since PPCs are not implicitly typed, a PPC without an explicit
-	     interface must be a subroutine.  */
-	  gfc_add_subroutine (&c->attr, c->name, &c->loc);
-	}
+      /* Now check that the argument-type matches.  */
+      gcc_assert (me_arg);
+      if ((me_arg->ts.type != BT_DERIVED && me_arg->ts.type != BT_CLASS)
+          || (me_arg->ts.type == BT_DERIVED && me_arg->ts.u.derived != sym)
+          || (me_arg->ts.type == BT_CLASS
+              && CLASS_DATA (me_arg)->ts.u.derived != sym))
+        {
+          gfc_error ("Argument '%s' of '%s' with PASS(%s) at %L must be of"
+                     " the derived type '%s'", me_arg->name, c->name,
+                     me_arg->name, &c->loc, sym->name);
+          c->tb->error = 1;
+          return FAILURE;
+        }
 
-      /* Procedure pointer components: Check PASS arg.  */
-      if (c->attr.proc_pointer && !c->tb->nopass && c->tb->pass_arg_num == 0
-	  && !sym->attr.vtype)
-	{
-	  gfc_symbol* me_arg;
+      /* Check for C453.  */
+      if (me_arg->attr.dimension)
+        {
+          gfc_error ("Argument '%s' of '%s' with PASS(%s) at %L "
+                     "must be scalar", me_arg->name, c->name, me_arg->name,
+                     &c->loc);
+          c->tb->error = 1;
+          return FAILURE;
+        }
 
-	  if (c->tb->pass_arg)
-	    {
-	      gfc_formal_arglist* i;
+      if (me_arg->attr.pointer)
+        {
+          gfc_error ("Argument '%s' of '%s' with PASS(%s) at %L "
+                     "may not have the POINTER attribute", me_arg->name,
+                     c->name, me_arg->name, &c->loc);
+          c->tb->error = 1;
+          return FAILURE;
+        }
 
-	      /* If an explicit passing argument name is given, walk the arg-list
-		and look for it.  */
+      if (me_arg->attr.allocatable)
+        {
+          gfc_error ("Argument '%s' of '%s' with PASS(%s) at %L "
+                     "may not be ALLOCATABLE", me_arg->name, c->name,
+                     me_arg->name, &c->loc);
+          c->tb->error = 1;
+          return FAILURE;
+        }
 
-	      me_arg = NULL;
-	      c->tb->pass_arg_num = 1;
-	      for (i = c->ts.interface->formal; i; i = i->next)
-		{
-		  if (!strcmp (i->sym->name, c->tb->pass_arg))
-		    {
-		      me_arg = i->sym;
-		      break;
-		    }
-		  c->tb->pass_arg_num++;
-		}
+      if (gfc_type_is_extensible (sym) && me_arg->ts.type != BT_CLASS)
+        gfc_error ("Non-polymorphic passed-object dummy argument of '%s'"
+                   " at %L", c->name, &c->loc);
 
-	      if (!me_arg)
-		{
-		  gfc_error ("Procedure pointer component '%s' with PASS(%s) "
-			     "at %L has no argument '%s'", c->name,
-			     c->tb->pass_arg, &c->loc, c->tb->pass_arg);
-		  c->tb->error = 1;
-		  return FAILURE;
-		}
-	    }
-	  else
-	    {
-	      /* Otherwise, take the first one; there should in fact be at least
-		one.  */
-	      c->tb->pass_arg_num = 1;
-	      if (!c->ts.interface->formal)
-		{
-		  gfc_error ("Procedure pointer component '%s' with PASS at %L "
-			     "must have at least one argument",
-			     c->name, &c->loc);
-		  c->tb->error = 1;
-		  return FAILURE;
-		}
-	      me_arg = c->ts.interface->formal->sym;
-	    }
+    }
 
-	  /* Now check that the argument-type matches.  */
-	  gcc_assert (me_arg);
-	  if ((me_arg->ts.type != BT_DERIVED && me_arg->ts.type != BT_CLASS)
-	      || (me_arg->ts.type == BT_DERIVED && me_arg->ts.u.derived != sym)
-	      || (me_arg->ts.type == BT_CLASS
-		  && CLASS_DATA (me_arg)->ts.u.derived != sym))
-	    {
-	      gfc_error ("Argument '%s' of '%s' with PASS(%s) at %L must be of"
-			 " the derived type '%s'", me_arg->name, c->name,
-			 me_arg->name, &c->loc, sym->name);
-	      c->tb->error = 1;
-	      return FAILURE;
-	    }
+  /* Check type-spec if this is not the parent-type component.  */
+  if (((sym->attr.is_class
+        && (!sym->components->ts.u.derived->attr.extension
+            || c != sym->components->ts.u.derived->components))
+       || (!sym->attr.is_class
+           && (!sym->attr.extension || c != sym->components)))
+      && !sym->attr.vtype
+      && resolve_typespec_used (&c->ts, &c->loc, c->name) == FAILURE)
+    return FAILURE;
 
-	  /* Check for C453.  */
-	  if (me_arg->attr.dimension)
-	    {
-	      gfc_error ("Argument '%s' of '%s' with PASS(%s) at %L "
-			 "must be scalar", me_arg->name, c->name, me_arg->name,
-			 &c->loc);
-	      c->tb->error = 1;
-	      return FAILURE;
-	    }
+  /* If this type is an extension, set the accessibility of the parent
+     component.  */
+  if (super_type
+      && ((sym->attr.is_class
+           && c == sym->components->ts.u.derived->components)
+          || (!sym->attr.is_class && c == sym->components))
+      && strcmp (super_type->name, c->name) == 0)
+    c->attr.access = super_type->attr.access;
+
+  /* If this type is an extension, see if this component has the same name
+     as an inherited type-bound procedure.  */
+  if (super_type && !sym->attr.is_class
+      && gfc_find_typebound_proc (super_type, NULL, c->name, true, NULL))
+    {
+      gfc_error ("Component '%s' of '%s' at %L has the same name as an"
+                 " inherited type-bound procedure",
+                 c->name, sym->name, &c->loc);
+      return FAILURE;
+    }
 
-	  if (me_arg->attr.pointer)
-	    {
-	      gfc_error ("Argument '%s' of '%s' with PASS(%s) at %L "
-			 "may not have the POINTER attribute", me_arg->name,
-			 c->name, me_arg->name, &c->loc);
-	      c->tb->error = 1;
-	      return FAILURE;
-	    }
+  if (c->ts.type == BT_CHARACTER && !c->attr.proc_pointer
+        && !c->ts.deferred)
+    {
+     if (c->ts.u.cl->length == NULL
+         || (resolve_charlen (c->ts.u.cl) == FAILURE)
+         || !gfc_is_constant_expr (c->ts.u.cl->length))
+       {
+         gfc_error ("Character length of component '%s' needs to "
+                    "be a constant specification expression at %L",
+                    c->name,
+                    c->ts.u.cl->length ? &c->ts.u.cl->length->where : &c->loc);
+         return FAILURE;
+       }
+    }
 
-	  if (me_arg->attr.allocatable)
-	    {
-	      gfc_error ("Argument '%s' of '%s' with PASS(%s) at %L "
-			 "may not be ALLOCATABLE", me_arg->name, c->name,
-			 me_arg->name, &c->loc);
-	      c->tb->error = 1;
-	      return FAILURE;
-	    }
+  if (c->ts.type == BT_CHARACTER && c->ts.deferred
+      && !c->attr.pointer && !c->attr.allocatable)
+    {
+      gfc_error ("Character component '%s' of '%s' at %L with deferred "
+                 "length must be a POINTER or ALLOCATABLE",
+                 c->name, sym->name, &c->loc);
+      return FAILURE;
+    }
 
-	  if (gfc_type_is_extensible (sym) && me_arg->ts.type != BT_CLASS)
-	    gfc_error ("Non-polymorphic passed-object dummy argument of '%s'"
-		       " at %L", c->name, &c->loc);
+  if (c->ts.type == BT_DERIVED
+      && sym->component_access != ACCESS_PRIVATE
+      && gfc_check_symbol_access (sym)
+      && !is_sym_host_assoc (c->ts.u.derived, sym->ns)
+      && !c->ts.u.derived->attr.use_assoc
+      && !gfc_check_symbol_access (c->ts.u.derived)
+      && gfc_notify_std (GFC_STD_F2003, "the component '%s' "
+                         "is a PRIVATE type and cannot be a component of "
+                         "'%s', which is PUBLIC at %L", c->name,
+                         sym->name, &sym->declared_at) == FAILURE)
+    return FAILURE;
 
-	}
+  if ((sym->attr.sequence || sym->attr.is_bind_c) && c->ts.type == BT_CLASS)
+    {
+      gfc_error ("Polymorphic component %s at %L in SEQUENCE or BIND(C) "
+                 "type %s", c->name, &c->loc, sym->name);
+      return FAILURE;
+    }
 
-      /* Check type-spec if this is not the parent-type component.  */
-      if (((sym->attr.is_class
-	    && (!sym->components->ts.u.derived->attr.extension
-		|| c != sym->components->ts.u.derived->components))
-	   || (!sym->attr.is_class
-	       && (!sym->attr.extension || c != sym->components)))
-	  && !sym->attr.vtype
-	  && resolve_typespec_used (&c->ts, &c->loc, c->name) == FAILURE)
-	return FAILURE;
+  if (sym->attr.sequence)
+    {
+      if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.sequence == 0)
+        {
+          gfc_error ("Component %s of SEQUENCE type declared at %L does "
+                     "not have the SEQUENCE attribute",
+                     c->ts.u.derived->name, &sym->declared_at);
+          return FAILURE;
+        }
+    }
 
-      /* If this type is an extension, set the accessibility of the parent
-	 component.  */
-      if (super_type
-	  && ((sym->attr.is_class
-	       && c == sym->components->ts.u.derived->components)
-	      || (!sym->attr.is_class && c == sym->components))
-	  && strcmp (super_type->name, c->name) == 0)
-	c->attr.access = super_type->attr.access;
-
-      /* If this type is an extension, see if this component has the same name
-	 as an inherited type-bound procedure.  */
-      if (super_type && !sym->attr.is_class
-	  && gfc_find_typebound_proc (super_type, NULL, c->name, true, NULL))
-	{
-	  gfc_error ("Component '%s' of '%s' at %L has the same name as an"
-		     " inherited type-bound procedure",
-		     c->name, sym->name, &c->loc);
-	  return FAILURE;
-	}
+  if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.generic)
+    c->ts.u.derived = gfc_find_dt_in_generic (c->ts.u.derived);
+  else if (c->ts.type == BT_CLASS && c->attr.class_ok
+           && CLASS_DATA (c)->ts.u.derived->attr.generic)
+    CLASS_DATA (c)->ts.u.derived
+                    = gfc_find_dt_in_generic (CLASS_DATA (c)->ts.u.derived);
 
-      if (c->ts.type == BT_CHARACTER && !c->attr.proc_pointer
-	    && !c->ts.deferred)
-	{
-	 if (c->ts.u.cl->length == NULL
-	     || (resolve_charlen (c->ts.u.cl) == FAILURE)
-	     || !gfc_is_constant_expr (c->ts.u.cl->length))
-	   {
-	     gfc_error ("Character length of component '%s' needs to "
-			"be a constant specification expression at %L",
-			c->name,
-			c->ts.u.cl->length ? &c->ts.u.cl->length->where : &c->loc);
-	     return FAILURE;
-	   }
-	}
+  if (!sym->attr.is_class && c->ts.type == BT_DERIVED && !sym->attr.vtype
+      && c->attr.pointer && c->ts.u.derived->components == NULL
+      && !c->ts.u.derived->attr.zero_comp)
+    {
+      gfc_error ("The pointer component '%s' of '%s' at %L is a type "
+                 "that has not been declared", c->name, sym->name,
+                 &c->loc);
+      return FAILURE;
+    }
 
-      if (c->ts.type == BT_CHARACTER && c->ts.deferred
-	  && !c->attr.pointer && !c->attr.allocatable)
-	{
-	  gfc_error ("Character component '%s' of '%s' at %L with deferred "
-		     "length must be a POINTER or ALLOCATABLE",
-		     c->name, sym->name, &c->loc);
-	  return FAILURE;
-	}
+  if (c->ts.type == BT_CLASS && c->attr.class_ok
+      && CLASS_DATA (c)->attr.class_pointer
+      && CLASS_DATA (c)->ts.u.derived->components == NULL
+      && !CLASS_DATA (c)->ts.u.derived->attr.zero_comp
+      && !UNLIMITED_POLY (c))
+    {
+      gfc_error ("The pointer component '%s' of '%s' at %L is a type "
+                 "that has not been declared", c->name, sym->name,
+                 &c->loc);
+      return FAILURE;
+    }
 
-      if (c->ts.type == BT_DERIVED
-	  && sym->component_access != ACCESS_PRIVATE
-	  && gfc_check_symbol_access (sym)
-	  && !is_sym_host_assoc (c->ts.u.derived, sym->ns)
-	  && !c->ts.u.derived->attr.use_assoc
-	  && !gfc_check_symbol_access (c->ts.u.derived)
-	  && gfc_notify_std (GFC_STD_F2003, "the component '%s' "
-			     "is a PRIVATE type and cannot be a component of "
-			     "'%s', which is PUBLIC at %L", c->name,
-			     sym->name, &sym->declared_at) == FAILURE)
-	return FAILURE;
+  /* C437.  */
+  if (c->ts.type == BT_CLASS && c->attr.flavor != FL_PROCEDURE
+      && (!c->attr.class_ok
+          || !(CLASS_DATA (c)->attr.class_pointer
+               || CLASS_DATA (c)->attr.allocatable)))
+    {
+      gfc_error ("Component '%s' with CLASS at %L must be allocatable "
+                 "or pointer", c->name, &c->loc);
+      /* Prevent a recurrence of the error.  */
+      c->ts.type = BT_UNKNOWN;
+      return FAILURE;
+    }
 
-      if ((sym->attr.sequence || sym->attr.is_bind_c) && c->ts.type == BT_CLASS)
-	{
-	  gfc_error ("Polymorphic component %s at %L in SEQUENCE or BIND(C) "
-		     "type %s", c->name, &c->loc, sym->name);
-	  return FAILURE;
-	}
+  if (c->ts.type == BT_UNION && resolve_fl_union (c->ts.u.derived) == FAILURE)
+      return FAILURE;
 
-      if (sym->attr.sequence)
-	{
-	  if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.sequence == 0)
-	    {
-	      gfc_error ("Component %s of SEQUENCE type declared at %L does "
-			 "not have the SEQUENCE attribute",
-			 c->ts.u.derived->name, &sym->declared_at);
-	      return FAILURE;
-	    }
-	}
+  /* Ensure that all the derived type components are put on the
+     derived type list; even in formal namespaces, where derived type
+     pointer components might not have been declared.  */
+  if (c->ts.type == BT_DERIVED
+        && c->ts.u.derived
+        && c->ts.u.derived->components
+        && c->attr.pointer
+        && sym != c->ts.u.derived)
+    add_dt_to_dt_list (c->ts.u.derived);
+
+  if (gfc_resolve_array_spec (c->as, !(c->attr.pointer
+                                       || c->attr.proc_pointer
+                                       || c->attr.allocatable)) == FAILURE)
+    return FAILURE;
 
-      if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.generic)
-	c->ts.u.derived = gfc_find_dt_in_generic (c->ts.u.derived);
-      else if (c->ts.type == BT_CLASS && c->attr.class_ok
-	       && CLASS_DATA (c)->ts.u.derived->attr.generic)
-	CLASS_DATA (c)->ts.u.derived
-			= gfc_find_dt_in_generic (CLASS_DATA (c)->ts.u.derived);
+  if (c->initializer && !sym->attr.vtype
+      && gfc_check_assign_symbol (sym, c, c->initializer) == FAILURE)
+    return FAILURE;
 
-      if (!sym->attr.is_class && c->ts.type == BT_DERIVED && !sym->attr.vtype
-	  && c->attr.pointer && c->ts.u.derived->components == NULL
-	  && !c->ts.u.derived->attr.zero_comp)
-	{
-	  gfc_error ("The pointer component '%s' of '%s' at %L is a type "
-		     "that has not been declared", c->name, sym->name,
-		     &c->loc);
-	  return FAILURE;
-	}
+  return SUCCESS;
+}
 
-      if (c->ts.type == BT_CLASS && c->attr.class_ok
-	  && CLASS_DATA (c)->attr.class_pointer
-	  && CLASS_DATA (c)->ts.u.derived->components == NULL
-	  && !CLASS_DATA (c)->ts.u.derived->attr.zero_comp
-	  && !UNLIMITED_POLY (c))
-	{
-	  gfc_error ("The pointer component '%s' of '%s' at %L is a type "
-		     "that has not been declared", c->name, sym->name,
-		     &c->loc);
-	  return FAILURE;
-	}
+/* Resolve the components of a union type. */
 
-      /* C437.  */
-      if (c->ts.type == BT_CLASS && c->attr.flavor != FL_PROCEDURE
-	  && (!c->attr.class_ok
-	      || !(CLASS_DATA (c)->attr.class_pointer
-		   || CLASS_DATA (c)->attr.allocatable)))
-	{
-	  gfc_error ("Component '%s' with CLASS at %L must be allocatable "
-		     "or pointer", c->name, &c->loc);
-	  /* Prevent a recurrence of the error.  */
-	  c->ts.type = BT_UNKNOWN;
-	  return FAILURE;
-	}
+static gfc_try
+resolve_fl_union (gfc_symbol *sym)
+{
+  gfc_component *map;
 
-      /* Ensure that all the derived type components are put on the
-	 derived type list; even in formal namespaces, where derived type
-	 pointer components might not have been declared.  */
-      if (c->ts.type == BT_DERIVED
-	    && c->ts.u.derived
-	    && c->ts.u.derived->components
-	    && c->attr.pointer
-	    && sym != c->ts.u.derived)
-	add_dt_to_dt_list (c->ts.u.derived);
+  gcc_assert (sym->attr.flavor == FL_UNION);
 
-      if (gfc_resolve_array_spec (c->as, !(c->attr.pointer
-					   || c->attr.proc_pointer
-					   || c->attr.allocatable)) == FAILURE)
-	return FAILURE;
+  for (map = sym->components; map; map = map->next)
+  {
+    if (resolve_component (map, (void *)sym) == FAILURE)
+      return FAILURE;
+  }
 
-      if (c->initializer && !sym->attr.vtype
-	  && gfc_check_assign_symbol (sym, c, c->initializer) == FAILURE)
-	return FAILURE;
+  if (sym->components)
+    add_dt_to_dt_list (sym);
+
+  return SUCCESS;
+}
+
+/* Resolve the components of a derived type. This does not have to wait until
+   resolution stage, but can be done as soon as the dt declaration has been
+   parsed.  */
+
+static gfc_try
+resolve_fl_derived0 (gfc_symbol *sym)
+{
+  gfc_symbol* super_type;
+  gfc_component *c;
+
+  if (sym->attr.unlimited_polymorphic)
+    return SUCCESS;
+
+  super_type = gfc_get_derived_super_type (sym);
+
+  /* F2008, C432. */
+  if (super_type && sym->attr.coarray_comp && !super_type->attr.coarray_comp)
+    {
+      gfc_error ("As extending type '%s' at %L has a coarray component, "
+		 "parent type '%s' shall also have one", sym->name,
+		 &sym->declared_at, super_type->name);
+      return FAILURE;
+    }
+
+  /* Ensure the extended type gets resolved before we do.  */
+  if (super_type && resolve_fl_derived0 (super_type) == FAILURE)
+    return FAILURE;
+
+  /* An ABSTRACT type must be extensible.  */
+  if (sym->attr.abstract && !gfc_type_is_extensible (sym))
+    {
+      gfc_error ("Non-extensible derived-type '%s' at %L must not be ABSTRACT",
+		 sym->name, &sym->declared_at);
+      return FAILURE;
     }
 
+  c = (sym->attr.is_class) ? sym->components->ts.u.derived->components
+			   : sym->components;
+
+  /* Resolve all components of this type. */
+  for (; c; c = c->next)
+  {
+    if (resolve_component (c, (void *)sym) == FAILURE)
+      return FAILURE;
+  }
+
   check_defined_assignments (sym);
 
   if (!sym->attr.defined_assign_comp && super_type)
@@ -13033,8 +13080,8 @@ resolve_fl_derived (gfc_symbol *sym)
   if (sym->attr.is_class && sym->ts.u.derived == NULL)
     {
       /* Fix up incomplete CLASS symbols.  */
-      gfc_component *data = gfc_find_component (sym, "_data", true, true);
-      gfc_component *vptr = gfc_find_component (sym, "_vptr", true, true);
+      gfc_component *data = gfc_find_component (sym, "_data", true, true, NULL);
+      gfc_component *vptr = gfc_find_component (sym, "_vptr", true, true, NULL);
 
       /* Nothing more to do for unlimited polymorphic entities.  */
       if (data->ts.u.derived->attr.unlimited_polymorphic)
@@ -13255,6 +13302,11 @@ resolve_symbol (gfc_symbol *sym)
     return;
   sym->resolved = 1;
 
+  /* No symbol will ever have union type; only components can be unions.
+     Union type declaration symbols have type BT_UNKNOWN but flavor FL_UNION
+     (just like derived type declaration symbols have flavor FL_DERIVED). */
+  gcc_assert (sym->ts.type != BT_UNION);
+
   if (sym->attr.artificial)
     return;
 
@@ -13320,7 +13372,11 @@ resolve_symbol (gfc_symbol *sym)
       return;
     }
 
-  if (sym->attr.flavor == FL_DERIVED && resolve_fl_derived (sym) == FAILURE)
+  if ((sym->attr.flavor == FL_DERIVED || sym->attr.flavor == FL_STRUCT)
+      && resolve_fl_derived (sym) == FAILURE)
+    return;
+
+  if (sym->attr.flavor == FL_UNION && resolve_fl_union (sym) == FAILURE)
     return;
 
   /* Symbols that are module procedures with results (functions) have
@@ -13540,7 +13596,7 @@ resolve_symbol (gfc_symbol *sym)
      interoperability when a variable is declared of that type.  */
   if (sym->attr.is_bind_c && sym->attr.implicit_type == 0 &&
       sym->attr.use_assoc == 0 && sym->attr.dummy == 0 &&
-      sym->attr.flavor != FL_PROCEDURE && sym->attr.flavor != FL_DERIVED)
+      sym->attr.flavor != FL_PROCEDURE && !gfc_fl_struct (sym->attr.flavor))
     {
       gfc_try t = SUCCESS;
 
@@ -13716,7 +13772,7 @@ resolve_symbol (gfc_symbol *sym)
   if (class_attr.codimension
       && !(class_attr.allocatable || sym->attr.dummy || sym->attr.save
 	   || sym->attr.select_type_temporary
-	   || sym->ns->save_all
+	   || (sym->ns->save_all && !sym->attr.automatic)
 	   || sym->ns->proc_name->attr.flavor == FL_MODULE
 	   || sym->ns->proc_name->attr.is_main_program
 	   || sym->attr.function || sym->attr.result || sym->attr.use_assoc))
@@ -13854,7 +13910,8 @@ resolve_symbol (gfc_symbol *sym)
     }
 
   /* Check threadprivate restrictions.  */
-  if (sym->attr.threadprivate && !sym->attr.save && !sym->ns->save_all
+  if (sym->attr.threadprivate && !sym->attr.save 
+      && !(sym->ns->save_all && !sym->attr.automatic)
       && (!sym->attr.in_common
 	  && sym->module == NULL
 	  && (sym->ns->proc_name == NULL
@@ -14472,8 +14529,7 @@ sequence_type (gfc_typespec ts)
 
   switch (ts.type)
   {
-    case BT_DERIVED:
-
+    case_struct_bt:
       if (ts.u.derived->components == NULL)
 	return SEQ_NONDEFAULT;
 
@@ -14559,7 +14615,7 @@ resolve_equivalence_derived (gfc_symbol *derived, gfc_symbol *sym, gfc_expr *e)
 
   for (; c ; c = c->next)
     {
-      if (c->ts.type == BT_DERIVED
+      if (gfc_bt_struct (c->ts.type)
 	  && (resolve_equivalence_derived (c->ts.u.derived, sym, e) == FAILURE))
 	return FAILURE;
 
diff --git a/gcc/fortran/simplify.c b/gcc/fortran/simplify.c
index 7c21f22..804a96b 100644
--- a/gcc/fortran/simplify.c
+++ b/gcc/fortran/simplify.c
@@ -1699,6 +1699,235 @@ gfc_simplify_conjg (gfc_expr *e)
   return range_check (result, "CONJG");
 }
 
+/* Return the simplification of the constant expression func(x). */
+
+static gfc_expr *
+simplify_trig_call (gfc_expr *icall)
+{
+  gfc_isym_id func = icall->value.function.isym->id;
+  gfc_expr *x = icall->value.function.actual->expr;
+
+  switch (func)
+  {
+    case GFC_ISYM_ACOS:
+        return gfc_simplify_acos (x);
+    case GFC_ISYM_ASIN:
+        return gfc_simplify_asin (x);
+    case GFC_ISYM_ATAN:
+        return gfc_simplify_atan (x); 
+    case GFC_ISYM_COS:
+        return gfc_simplify_cos (x);
+    case GFC_ISYM_COTAN:
+        return gfc_simplify_cotan (icall);
+    case GFC_ISYM_SIN:
+        return gfc_simplify_sin (x);
+    case GFC_ISYM_TAN:
+        return gfc_simplify_tan (x);
+    default:
+         break;
+  }
+  /* Unreachable. */
+  gfc_internal_error ("in simplify_trig_call(): Bad intrinsic");
+  return NULL;
+}
+
+/* Convert a floating-point number from radians to degrees. */
+
+static void
+degrees_f (mpfr_t x, mp_rnd_t rnd_mode)
+{
+    mpfr_t tmp;
+    mpfr_init (tmp);
+
+    /* x = x * 180 */
+    mpfr_set_d (tmp, 180.0l, rnd_mode);
+    mpfr_mul (x, x, tmp, rnd_mode);
+
+    /* x = x / pi */
+    mpfr_const_pi (tmp, rnd_mode);
+    mpfr_div (x, x, tmp, rnd_mode); 
+
+    mpfr_clear (tmp);
+}
+
+/* Convert a floating-point number from degrees to radians. */
+
+static void
+radians_f (mpfr_t x, mp_rnd_t rnd_mode)
+{
+    mpfr_t tmp;
+    mpfr_init (tmp);
+
+    /* x = x * pi */
+    mpfr_const_pi (tmp, rnd_mode);
+    mpfr_mul (x, x, tmp, rnd_mode);
+
+    /* x = x / 180 */
+    mpfr_set_d (tmp, 180.0l, rnd_mode);
+    mpfr_div (x, x, tmp, rnd_mode); 
+
+    mpfr_clear (tmp);
+}
+
+/* Build an expression for converting degrees to radians. */
+
+static gfc_expr *
+get_radians (gfc_expr *deg)
+{
+  mpfr_t tmp;
+  gfc_expr *factor; /* pi / 180 */
+
+  gcc_assert (deg->ts.type == BT_REAL);
+
+  factor = gfc_get_constant_expr (deg->ts.type, deg->ts.kind, &deg->where);
+
+  /* Factor = pi / 180 */
+  mpfr_init (tmp);
+  mpfr_set_d (tmp, 180.0l, GFC_RND_MODE);
+  mpfr_const_pi (factor->value.real, GFC_RND_MODE);
+  mpfr_div (factor->value.real, factor->value.real, tmp, GFC_RND_MODE);
+  mpfr_clear (tmp);
+
+  /* rad = deg * (pi / 180) */
+  return gfc_multiply (deg, factor);
+}
+
+/* Build an expression for converting radians to degrees. */
+
+static gfc_expr *
+get_degrees (gfc_expr *rad)
+{
+  mpfr_t tmp;
+  gfc_expr *factor; /* 180 / pi */
+
+  gcc_assert (rad->ts.type == BT_REAL);
+
+  factor = gfc_get_constant_expr (rad->ts.type, rad->ts.kind, &rad->where);
+
+  /* Factor = 180 / pi */
+  mpfr_init (tmp);
+  mpfr_const_pi (tmp, GFC_RND_MODE);
+  mpfr_set_d (factor->value.real, 180.0l, GFC_RND_MODE);
+  mpfr_div (factor->value.real, factor->value.real, tmp, GFC_RND_MODE);
+  mpfr_clear (tmp);
+
+  /* deg = rad * (180 / pi) */
+  return gfc_multiply (rad, factor);
+}
+
+/* Convert argument from degrees to radians before calling the trig
+   function in icall. */
+
+gfc_expr *
+gfc_simplify_trigd (gfc_expr *icall)
+{
+  gfc_expr *x;
+
+  /* The actual argument. */
+  x = icall->value.function.actual->expr;
+
+  if (x->ts.type != BT_REAL)
+    gfc_internal_error ("in gfc_simplify_trigd(): Bad type");
+
+  if (x->expr_type == EXPR_CONSTANT)
+      /* Convert constant to radians before passing off to simplifier. */
+      radians_f (x->value.real, GFC_RND_MODE);
+  else
+      /* Argument expression is not constant: replace it with degree to radian
+         conversion of original argument. */
+      icall->value.function.actual->expr = get_radians (x);
+
+  /* Let the actual simplifier take over; we just changed icall's argument. */
+  return simplify_trig_call (icall);
+}
+
+/* Convert result from degrees to radians after calling the inverse trig
+   function in icall. */
+
+gfc_expr *
+gfc_simplify_atrigd (gfc_expr *icall)
+{
+  gfc_expr *x;
+  gfc_actual_arglist *arg;
+
+  /* The actual argument. */
+  x = icall->value.function.actual->expr;
+
+  if (x->ts.type != BT_REAL)
+    gfc_internal_error ("in gfc_simplify_atrigd(): Bad type");
+
+  /* See if another simplifier has work to do first. */
+  x = simplify_trig_call (icall);
+
+  if (x && x->expr_type == EXPR_CONSTANT)
+  {
+      /* Convert constant to degrees after passing off to actual simplifier. */
+      degrees_f (x->value.real, GFC_RND_MODE);
+      return x;
+  }
+
+  /* Expression was simplified. The old icall will be freed by do_simplify. */
+  else if (x != NULL)
+      icall = x;
+
+  /* Expression was not simplified. We must copy icall because do_simplify
+     will free it. We must carefully copy value.function by hand, as future
+     functions depend on its fields and gfc_copy_expr does not do this. */
+  else
+  {
+      x = gfc_copy_expr (icall);
+      /* arg is the only thing in value.function copied by gfc_copy_expr;
+         do not overwrite the pointer to the new copy. */
+      arg = x->value.function.actual;
+      x->value = icall->value;
+      x->value.function.actual = arg;
+      icall = x;
+      /* Resolve manually since do_simplify assumes we're done with x. */
+      (*icall->value.function.isym->resolve.f1) (icall, arg->expr);
+  }
+
+  /* Return expression for converting the result to degrees. */
+  return get_degrees (icall);
+}
+
+/* This has to look like a two-parameter function, but its call is
+   intercepted by do_simplify because we need to have the handle to the
+   actual function call to wrap it in get_degrees. */
+
+gfc_expr *
+gfc_simplify_atan2d (gfc_expr *icall, gfc_expr *dummy ATTRIBUTE_UNUSED)
+{
+  gfc_expr *result, *y, *x;
+  gfc_actual_arglist *arg;
+  y = icall->value.function.actual->expr;
+  x = icall->value.function.actual->next->expr;
+
+  if (x->ts.type != BT_REAL || y->ts.type != BT_REAL)
+    gfc_internal_error ("in gfc_simplify_atan2d(): Bad type");
+
+  if (x->expr_type == EXPR_CONSTANT && y->expr_type == EXPR_CONSTANT)
+  {
+      result = gfc_simplify_atan2 (y, x);
+      degrees_f (result->value.real, GFC_RND_MODE);
+      return result;
+  }
+
+  /* Argument expression is not constant: replace result with radian to degree
+     conversion. We must use a copy here because do_simplify will replace (free)
+     the original expression. The value is not copied by gfc_copy_expr, but the
+     actual arg is. */
+  result = gfc_copy_expr (icall);
+  arg = result->value.function.actual; /* Copy of icall's actual */
+  result->value = icall->value;
+  result->value.function.actual = arg;
+  icall = result;
+
+  /* Resolve manually since do_simplify assumes we're done with result. */
+  (*icall->value.function.isym->resolve.f2) (icall, x, y);
+  result = get_degrees (icall);
+
+  return result;
+}
 
 gfc_expr *
 gfc_simplify_cos (gfc_expr *x)
@@ -1877,13 +2106,22 @@ gfc_simplify_dim (gfc_expr *x, gfc_expr *y)
 gfc_expr*
 gfc_simplify_dot_product (gfc_expr *vector_a, gfc_expr *vector_b)
 {
+
+  gfc_expr temp;
+
   if (!is_constant_array_expr (vector_a)
       || !is_constant_array_expr (vector_b))
     return NULL;
 
   gcc_assert (vector_a->rank == 1);
   gcc_assert (vector_b->rank == 1);
-  gcc_assert (gfc_compare_types (&vector_a->ts, &vector_b->ts));
+
+  temp.expr_type = EXPR_OP;
+  gfc_clear_ts (&temp.ts);
+  temp.value.op.op = INTRINSIC_NONE;
+  temp.value.op.op1 = vector_a;
+  temp.value.op.op2 = vector_b;
+  gfc_type_convert_binary (&temp, 1);
 
   return compute_dot_product (vector_a, 1, 0, vector_b, 1, 0, true);
 }
@@ -5936,6 +6174,45 @@ gfc_simplify_sum (gfc_expr *array, gfc_expr *dim, gfc_expr *mask)
 
 
 gfc_expr *
+gfc_simplify_cotan (gfc_expr *icall)
+{
+  gfc_actual_arglist *arg;
+  gfc_expr *result, *x;
+  x = icall->value.function.actual->expr;
+
+  gcc_assert (x->ts.type == BT_REAL);
+
+  /* Compute the result for constant expressions at compile-time. */
+  if (x->expr_type == EXPR_CONSTANT)
+  {
+    result = gfc_get_constant_expr (x->ts.type, x->ts.kind, &x->where);
+    mpfr_cot (result->value.real, x->value.real, GFC_RND_MODE);
+    return range_check (result, "COTAN");
+  }
+
+  /* Expression is not constant; generate inverse of tangent expression.
+     We must copy icall because do_simplify will free it. We must carefully
+     copy value.function by hand, as future functions depend on its fields 
+     and gfc_copy_expr does not do this. */
+  x = gfc_copy_expr (icall);
+  /* arg is the only thing in value.function copied by gfc_copy_expr;
+     do not overwrite the pointer to the new copy. */
+  arg = x->value.function.actual;
+  x->value = icall->value;
+  x->value.function.actual = arg;
+  icall = x;
+
+  /* Resolve first, since do_simplify assumes we are done with result. */
+  (*icall->value.function.isym->resolve.f1) (icall, arg->expr);
+
+  /* cotan = 1 / tan */
+  x = gfc_get_constant_expr (icall->ts.type, icall->ts.kind, &icall->where);
+  mpfr_set_d (x->value.real, 1.0l, GFC_RND_MODE);
+  return gfc_divide (x, icall); 
+}
+
+
+gfc_expr *
 gfc_simplify_tan (gfc_expr *x)
 {
   gfc_expr *result;
diff --git a/gcc/fortran/symbol.c b/gcc/fortran/symbol.c
index 1b3702f..704a509 100644
--- a/gcc/fortran/symbol.c
+++ b/gcc/fortran/symbol.c
@@ -40,6 +40,7 @@ const mstring flavors[] =
   minit ("VARIABLE", FL_VARIABLE), minit ("PARAMETER", FL_PARAMETER),
   minit ("LABEL", FL_LABEL), minit ("PROCEDURE", FL_PROCEDURE),
   minit ("DERIVED", FL_DERIVED), minit ("NAMELIST", FL_NAMELIST),
+  minit ("UNION", FL_UNION), minit ("STRUCTURE", FL_STRUCT),
   minit (NULL, -1)
 };
 
@@ -362,7 +363,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)
     *volatile_ = "VOLATILE", *is_protected = "PROTECTED",
     *is_bind_c = "BIND(C)", *procedure = "PROCEDURE",
     *asynchronous = "ASYNCHRONOUS", *codimension = "CODIMENSION",
-    *contiguous = "CONTIGUOUS", *generic = "GENERIC";
+    *contiguous = "CONTIGUOUS", *generic = "GENERIC", *automatic = "AUTOMATIC";
   static const char *threadprivate = "THREADPRIVATE";
 
   const char *a1, *a2;
@@ -421,6 +422,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)
       conf (dummy, save);
       conf (in_common, save);
       conf (result, save);
+      conf (automatic, save);
 
       switch (attr->flavor)
 	{
@@ -428,8 +430,8 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)
 	  case FL_BLOCK_DATA:
 	  case FL_MODULE:
 	  case FL_LABEL:
-	  case FL_DERIVED:
 	  case FL_PARAMETER:
+          case_struct_fl:
             a1 = gfc_code2string (flavors, attr->flavor);
             a2 = save;
 	    goto conflict;
@@ -455,6 +457,12 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)
   conf (pointer, elemental);
   conf (allocatable, elemental);
 
+  conf (in_common, automatic);
+  conf (in_equivalence, automatic);
+  conf (result, automatic);
+  conf (use_assoc, automatic);
+  conf (dummy, automatic);
+
   conf (target, external);
   conf (target, intrinsic);
 
@@ -694,7 +702,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)
 
       break;
 
-    case FL_DERIVED:
+    case_struct_fl:
       conf2 (dummy);
       conf2 (pointer);
       conf2 (target);
@@ -1095,6 +1103,21 @@ gfc_add_result (symbol_attribute *attr, const char *name, locus *where)
 
 
 gfc_try
+gfc_add_automatic (symbol_attribute *attr, const char *name, locus *where)
+{
+  if (check_used (attr, name, where))
+    return FAILURE;
+
+  if (attr->automatic && gfc_notify_std (GFC_STD_LEGACY, 
+      "Duplicate AUTOMATIC attribute specified at %L", where) == FAILURE)
+    return FAILURE;
+
+  attr->automatic = 1;
+  return check_conflict (attr, name, where);
+}
+
+
+gfc_try
 gfc_add_save (symbol_attribute *attr, save_state s, const char *name,
 	      locus *where)
 {
@@ -1454,7 +1477,7 @@ gfc_add_flavor (symbol_attribute *attr, sym_flavor f, const char *name,
 {
 
   if ((f == FL_PROGRAM || f == FL_BLOCK_DATA || f == FL_MODULE
-       || f == FL_PARAMETER || f == FL_LABEL || f == FL_DERIVED
+       || f == FL_PARAMETER || f == FL_LABEL || gfc_fl_struct (f)
        || f == FL_NAMELIST) && check_used (attr, name, where))
     return FAILURE;
 
@@ -1689,7 +1712,7 @@ gfc_add_type (gfc_symbol *sym, gfc_typespec *ts, locus *where)
   if (flavor == FL_PROGRAM || flavor == FL_BLOCK_DATA || flavor == FL_MODULE
       || flavor == FL_LABEL
       || (flavor == FL_PROCEDURE && sym->attr.subroutine)
-      || flavor == FL_DERIVED || flavor == FL_NAMELIST)
+      || gfc_fl_struct (flavor) || flavor == FL_NAMELIST)
     {
       gfc_error ("Symbol '%s' at %L cannot have a type", sym->name, where);
       return FAILURE;
@@ -1749,6 +1772,8 @@ gfc_copy_attr (symbol_attribute *dest, symbol_attribute *src, locus *where)
     goto fail;
   if (src->is_protected && gfc_add_protected (dest, NULL, where) == FAILURE)
     goto fail;
+  if (src->automatic && gfc_add_automatic (dest, NULL, where) == FAILURE)
+    goto fail;
   if (src->save && gfc_add_save (dest, src->save, NULL, where) == FAILURE)
     goto fail;
   if (src->value && gfc_add_value (dest, NULL, where) == FAILURE)
@@ -1835,7 +1860,6 @@ fail:
   return FAILURE;
 }
 
-
 /************** Component name management ************/
 
 /* Component names of a derived type form their own little namespaces
@@ -1854,22 +1878,27 @@ gfc_add_component (gfc_symbol *sym, const char *name,
 {
   gfc_component *p, *tail;
 
-  tail = NULL;
-
+  /* Check for existing components with the same name, but not for union
+     components or containers. Unions and maps are anonymous so they have
+     unique internal names which will never conflict.
+     Don't use gfc_find_component here because it calls gfc_use_derived,
+     but the derived type may not be fully defined yet. */
   for (p = sym->components; p; p = p->next)
     {
       if (strcmp (p->name, name) == 0)
-	{
-	  gfc_error ("Component '%s' at %C already declared at %L",
-		     name, &p->loc);
-	  return FAILURE;
-	}
+        {
+          gfc_error ("Component '%s' at %C already declared at %L",
+                     name, &p->loc);
+          return FAILURE;
+        }
+    }
 
+  tail = NULL;
+  for (p = sym->components; p; p = p->next)
       tail = p;
-    }
 
   if (sym->attr.extension
-	&& gfc_find_component (sym->components->ts.u.derived, name, true, true))
+	&& gfc_find_component (sym->components->ts.u.derived, name, true, true, NULL))
     {
       gfc_error ("Component '%s' at %C already in the parent type "
 		 "at %L", name, &sym->components->ts.u.derived->declared_at);
@@ -1892,7 +1921,6 @@ gfc_add_component (gfc_symbol *sym, const char *name,
   return SUCCESS;
 }
 
-
 /* Recursive function to switch derived types of all symbol in a
    namespace.  */
 
@@ -1960,7 +1988,7 @@ gfc_use_derived (gfc_symbol *sym)
       return NULL;
     }
 
-  if (s == NULL || s->attr.flavor != FL_DERIVED)
+  if (s == NULL || !gfc_fl_struct (s->attr.flavor))
     goto bad;
 
   /* Get rid of symbol sym, translating all references to s.  */
@@ -1993,17 +2021,66 @@ bad:
   return NULL;
 }
 
+   
+static gfc_component *
+find_union_component (gfc_symbol *un, const char *name,
+                      bool noaccess, gfc_ref **ref)
+{
+  gfc_component *m, *check;
+  gfc_ref *sref, *tmp;
+
+  for (m = un->components; m; m = m->next)
+  {
+    check = gfc_find_component (m->ts.u.derived, name, noaccess, true, &tmp);
+    if (check == NULL)
+      continue;
+
+    /* Found it somewhere in m; chain the refs together. */
+    if (ref)
+    {
+      /* Map ref. */
+      sref = gfc_get_ref ();
+      sref->type = REF_COMPONENT;
+      sref->u.c.component = m;
+      sref->u.c.sym = m->ts.u.derived;
+      sref->next = tmp;
+
+      *ref = sref;
+    }
+    /* Other checks (such as access) were done in the recursive calls.
+       Now we are done! */
+    return check;
+  }
+  return NULL;
+}
+
 
 /* Given a derived type node and a component name, try to locate the
    component structure.  Returns the NULL pointer if the component is
    not found or the components are private.  If noaccess is set, no access
-   checks are done.  */
+   checks are done. Unless silent is set, a gfc_error is generated when the
+   component cannot be found or accessed.
+   
+   If ref is not NULL, *ref is set to represent the chain of components
+   required to get to the ultimate component.
+
+   If the component is simply a direct subcomponent, or is inherited from a
+   parent derived type in the given derived type, this is a single ref with its
+   component set to the returned component.
+
+   Otherwise, *ref is constructed as a chain of subcomponents. This occurs
+   when the component is found through an implicit chain of nested union and
+   map components. Unions and maps are "anonymous" substructures in FORTRAN
+   which cannot be explicitly referenced, but the reference chain must be
+   considered as in C for backend translation to correctly compute layouts.
+   (For example, x.a may refer to x->(UNION)->(MAP)->(UNION)->(MAP)->a). */
 
 gfc_component *
 gfc_find_component (gfc_symbol *sym, const char *name,
-		    bool noaccess, bool silent)
+		    bool noaccess, bool silent, gfc_ref **ref)
 {
-  gfc_component *p;
+  gfc_component *p, *check;
+  gfc_ref *sref = NULL, *tmp = NULL;
 
   if (name == NULL || sym == NULL)
     return NULL;
@@ -2013,10 +2090,38 @@ gfc_find_component (gfc_symbol *sym, const char *name,
   if (sym == NULL)
     return NULL;
 
+  /* Handle UNIONs specially. */
+  if (sym->attr.flavor == FL_UNION)
+    return find_union_component (sym, name, noaccess, ref);
+
+  if (ref) *ref = NULL;
   for (p = sym->components; p; p = p->next)
-    if (strcmp (p->name, name) == 0)
+  {
+    /* Nest search into union's maps. */
+    if (p->ts.type == BT_UNION)
+    {
+      check = find_union_component (p->ts.u.derived, name, noaccess, &tmp);
+      if (check != NULL)
+      {
+        /* Union ref. */
+        if (ref)
+        {
+          sref = gfc_get_ref ();
+          sref->type = REF_COMPONENT;
+          sref->u.c.component = p;
+          sref->u.c.sym = p->ts.u.derived;
+          sref->next = tmp;
+          *ref = sref;
+        }
+        return check;
+      }
+    }
+    else if (strcmp (p->name, name) == 0)
       break;
 
+    continue;
+  }
+
   if (p && sym->attr.use_assoc && !noaccess)
     {
       bool is_parent_comp = sym->attr.extension && (p == sym->components);
@@ -2032,12 +2137,14 @@ gfc_find_component (gfc_symbol *sym, const char *name,
 	}
     }
 
+  /* Look in the parent type. */
   if (p == NULL
+        && sym->attr.flavor == FL_DERIVED
 	&& sym->attr.extension
 	&& sym->components->ts.type == BT_DERIVED)
     {
       p = gfc_find_component (sym->components->ts.u.derived, name,
-			      noaccess, silent);
+			      noaccess, silent, ref);
       /* Do not overwrite the error.  */
       if (p == NULL)
 	return p;
@@ -2047,6 +2154,25 @@ gfc_find_component (gfc_symbol *sym, const char *name,
     gfc_error ("'%s' at %C is not a member of the '%s' structure",
 	       name, sym->name);
 
+  /* Component was found; build the ultimate component reference. */
+  if (p != NULL && ref)
+  {
+    tmp = gfc_get_ref ();
+    tmp->type = REF_COMPONENT;
+    tmp->u.c.component = p;
+    tmp->u.c.sym = sym;
+    /* Link the final component ref to the end of the chain of subrefs. */
+    if (sref)
+    {
+      *ref = sref;
+      for (; sref->next; sref = sref->next)
+        ;
+      sref->next = tmp;
+    }
+    else
+      *ref = tmp;
+  }
+
   return p;
 }
 
@@ -3115,11 +3241,9 @@ gfc_restore_last_undo_checkpoint (void)
 	  /* The derived type is saved in the symtree with the first
 	     letter capitalized; the all lower-case version to the
 	     derived type contains its associated generic function.  */
-	  if (p->attr.flavor == FL_DERIVED)
-	    gfc_delete_symtree (&p->ns->sym_root, gfc_get_string ("%c%s",
-                        (char) TOUPPER ((unsigned char) p->name[0]),
-                        &p->name[1]));
-	  else
+	  if (gfc_fl_struct (p->attr.flavor))
+	    gfc_delete_symtree (&p->ns->sym_root,gfc_dt_upper_string (p->name));
+          else
 	    gfc_delete_symtree (&p->ns->sym_root, p->name);
 
 	  gfc_release_symbol (p);
@@ -3636,6 +3760,10 @@ gfc_is_var_automatic (gfc_symbol *sym)
       && sym->ts.u.cl
       && !gfc_is_constant_expr (sym->ts.u.cl->length))
     return true;
+  /* Variables with explicit AUTOMATIC attribute. */
+  if (sym->attr.automatic)
+    return true;
+
   return false;
 }
 
@@ -3859,7 +3987,7 @@ verify_bind_c_derived_type (gfc_symbol *derived_sym)
         }
       
       /* BIND(C) derived types must have interoperable components.  */
-      if (curr_comp->ts.type == BT_DERIVED
+      if (gfc_bt_struct (curr_comp->ts.type)
 	  && curr_comp->ts.u.derived->ts.is_iso_c != 1 
           && curr_comp->ts.u.derived != derived_sym)
         {
@@ -4548,9 +4676,7 @@ generate_isocbinding_symbol (const char *mod_name, iso_c_binding_symbol s,
 	  gfc_component *tmp_comp = NULL;
 	  char comp_name[(GFC_MAX_SYMBOL_LEN * 2) + 1];
 
-	  hidden_name = gfc_get_string ("%c%s",
-			    (char) TOUPPER ((unsigned char) tmp_sym->name[0]),
-                            &tmp_sym->name[1]);
+	  hidden_name = gfc_dt_upper_string (tmp_sym->name);
 
 	  /* Generate real derived type.  */
 	  tmp_symtree = gfc_find_symtree (gfc_current_ns->sym_root,
@@ -4911,15 +5037,21 @@ gfc_type_compatible (gfc_typespec *ts1, gfc_typespec *ts2)
   bool is_class2 = (ts2->type == BT_CLASS);
   bool is_derived1 = (ts1->type == BT_DERIVED);
   bool is_derived2 = (ts2->type == BT_DERIVED);
+  bool is_union1 = (ts1->type == BT_UNION);
+  bool is_union2 = (ts2->type == BT_UNION);
 
   if (is_class1
       && ts1->u.derived->components
       && ts1->u.derived->components->ts.u.derived->attr.unlimited_polymorphic)
     return 1;
 
-  if (!is_derived1 && !is_derived2 && !is_class1 && !is_class2)
+  if (!is_derived1 && !is_derived2 && !is_class1 && !is_class2
+      && !is_union1 && !is_union2)
     return (ts1->type == ts2->type);
 
+  if (is_union1 && is_union2)
+    return gfc_compare_union_types (ts1->u.derived, ts2->u.derived);
+
   if (is_derived1 && is_derived2)
     return gfc_compare_derived_types (ts1->u.derived, ts2->u.derived);
 
@@ -4978,12 +5110,12 @@ gfc_find_dt_in_generic (gfc_symbol *sym)
 {
   gfc_interface *intr = NULL;
 
-  if (!sym || sym->attr.flavor == FL_DERIVED)
+  if (!sym || gfc_fl_struct (sym->attr.flavor))
     return sym;
 
   if (sym->attr.generic)
     for (intr = sym->generic; intr; intr = intr->next)
-      if (intr->sym->attr.flavor == FL_DERIVED)
+      if (gfc_fl_struct (intr->sym->attr.flavor))
         break;
   return intr ? intr->sym : NULL;
 }
diff --git a/gcc/fortran/target-memory.c b/gcc/fortran/target-memory.c
index 26a5de2..4fe7d5c 100644
--- a/gcc/fortran/target-memory.c
+++ b/gcc/fortran/target-memory.c
@@ -107,8 +107,8 @@ gfc_element_size (gfc_expr *e)
 
     case BT_HOLLERITH:
       return e->representation.length;
-    case BT_DERIVED:
     case BT_CLASS:
+    case_struct_bt:
       {
 	/* Determine type size without clobbering the typespec for ISO C
 	   binding types.  */
@@ -279,6 +279,9 @@ gfc_target_encode_expr (gfc_expr *source, unsigned char *buffer,
   if (source == NULL)
     return 0;
 
+  /* Assumed no union will end up here. */
+  gcc_assert (source->ts.type != BT_UNION);
+
   if (source->expr_type == EXPR_ARRAY)
     return encode_array (source, buffer, buffer_size);
 
@@ -593,6 +596,11 @@ gfc_target_interpret_expr (unsigned char *buffer, size_t buffer_size,
       gcc_assert (result->representation.length >= 0);
       break;
 
+    /* TODO: Handle BT_UNION ? */
+    case BT_UNION:
+      gfc_warning_now ("Union binary representation unimplemented");
+      break;
+
     default:
       gfc_internal_error ("Invalid expression in gfc_target_interpret_expr.");
       break;
@@ -639,7 +647,7 @@ expr_to_char (gfc_expr *e, unsigned char *data, unsigned char *chk, size_t len)
 
   /* Take a derived type, one component at a time, using the offsets from the backend
      declaration.  */
-  if (e->ts.type == BT_DERIVED)
+  if (gfc_bt_struct (e->ts.type))
     {
       for (c = gfc_constructor_first (e->value.constructor),
 	   cmp = e->ts.u.derived->components;
diff --git a/gcc/fortran/trans-decl.c b/gcc/fortran/trans-decl.c
index 7d23561..4733544 100644
--- a/gcc/fortran/trans-decl.c
+++ b/gcc/fortran/trans-decl.c
@@ -593,7 +593,7 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)
     }
 
   /* Keep variables larger than max-stack-var-size off stack.  */
-  if (!sym->ns->proc_name->attr.recursive
+  if (!sym->ns->proc_name->attr.recursive && !sym->attr.automatic
       && INTEGER_CST_P (DECL_SIZE_UNIT (decl))
       && !gfc_can_put_var_on_stack (DECL_SIZE_UNIT (decl))
 	 /* Put variable length auto array pointers always into stack.  */
@@ -693,14 +693,14 @@ gfc_get_module_backend_decl (gfc_symbol *sym)
 	  st->n.sym = sym;
 	  sym->refs++;
 	}
-      else if (sym->attr.flavor == FL_DERIVED)
+      else if (gfc_fl_struct (sym->attr.flavor))
 	{
 	  if (s && s->attr.flavor == FL_PROCEDURE)
 	    {
 	      gfc_interface *intr;
 	      gcc_assert (s->attr.generic);
 	      for (intr = s->generic; intr; intr = intr->next)
-		if (intr->sym->attr.flavor == FL_DERIVED)
+		if (gfc_fl_struct (intr->sym->attr.flavor))
 		  {
 		    s = intr->sym;
 		    break;
@@ -708,7 +708,12 @@ gfc_get_module_backend_decl (gfc_symbol *sym)
     	    }
 
 	  if (!s->backend_decl)
-	    s->backend_decl = gfc_get_derived_type (s);
+          {
+            if (s->attr.flavor == FL_UNION)
+              s->backend_decl = gfc_get_union_type (s);
+            else
+              s->backend_decl = gfc_get_derived_type (s);
+          }
 	  gfc_copy_dt_decls_ifequal (s, sym, true);
 	  return true;
 	}
@@ -4045,7 +4050,7 @@ gfc_create_module_variable (gfc_symbol * sym)
       && sym->ts.type == BT_DERIVED)
     sym->backend_decl = gfc_typenode_for_spec (&(sym->ts));
 
-  if (sym->attr.flavor == FL_DERIVED
+  if (gfc_fl_struct (sym->attr.flavor)
       && sym->backend_decl
       && TREE_CODE (sym->backend_decl) == RECORD_TYPE)
     {
@@ -4264,20 +4269,20 @@ check_constant_initializer (gfc_expr *expr, gfc_typespec *ts, bool array,
     }
   else switch (ts->type)
     {
-    case BT_DERIVED:
+    case_struct_bt:
       if (expr->expr_type != EXPR_STRUCTURE)
 	return false;
       cm = expr->ts.u.derived->components;
       for (c = gfc_constructor_first (expr->value.constructor);
-	   c; c = gfc_constructor_next (c), cm = cm->next)
-	{
-	  if (!c->expr || cm->attr.allocatable)
-	    continue;
-	  if (!check_constant_initializer (c->expr, &cm->ts,
-					   cm->attr.dimension,
-					   cm->attr.pointer))
-	    return false;
-	}
+          c; c = gfc_constructor_next (c), cm = cm->next)
+       {
+         if (!c->expr || cm->attr.allocatable)
+           continue;
+         if (!check_constant_initializer (c->expr, &cm->ts,
+                                          cm->attr.dimension,
+                                          cm->attr.pointer))
+           return false;
+       }
       return true;
     default:
       return expr->expr_type == EXPR_CONSTANT;
diff --git a/gcc/fortran/trans-expr.c b/gcc/fortran/trans-expr.c
index d6411b0..369798a 100644
--- a/gcc/fortran/trans-expr.c
+++ b/gcc/fortran/trans-expr.c
@@ -1550,6 +1550,7 @@ gfc_conv_component_ref (gfc_se * se, gfc_ref * ref)
   tree tmp;
   tree decl;
   tree field;
+  tree context;
 
   c = ref->u.c.component;
 
@@ -1558,15 +1559,20 @@ gfc_conv_component_ref (gfc_se * se, gfc_ref * ref)
   field = c->backend_decl;
   gcc_assert (TREE_CODE (field) == FIELD_DECL);
   decl = se->expr;
+  context = DECL_FIELD_CONTEXT (field);
 
   /* Components can correspond to fields of different containing
      types, as components are created without context, whereas
      a concrete use of a component has the type of decl as context.
      So, if the type doesn't match, we search the corresponding
      FIELD_DECL in the parent type.  To not waste too much time
-     we cache this result in norestrict_decl.  */
+     we cache this result in norestrict_decl. 
+     On the other hand, if the context is a UNION or a MAP (a
+     RECORD_TYPE within a UNION_TYPE) always use the given FIELD_DECL. */
 
-  if (DECL_FIELD_CONTEXT (field) != TREE_TYPE (decl))
+  if (context != TREE_TYPE (decl) 
+      && !(   TREE_CODE (TREE_TYPE (field)) == UNION_TYPE /* field is union */
+           || TREE_CODE (context) == UNION_TYPE))         /* field is map */
     {
       tree f2 = c->norestrict_decl;
       if (!f2 || DECL_FIELD_CONTEXT (f2) != TREE_TYPE (decl))
@@ -1606,15 +1612,13 @@ gfc_conv_component_ref (gfc_se * se, gfc_ref * ref)
 static void
 conv_parent_component_references (gfc_se * se, gfc_ref * ref)
 {
-  gfc_component *c;
-  gfc_component *cmp;
+  gfc_component *c, *cmp;
   gfc_symbol *dt;
   gfc_ref parent;
 
   dt = ref->u.c.sym;
   c = ref->u.c.component;
 
-  /* Return if the component is in the parent type.  */
   for (cmp = dt->components; cmp; cmp = cmp->next)
     if (strcmp (c->name, cmp->name) == 0)
       return;
@@ -5684,8 +5688,8 @@ gfc_conv_initializer (gfc_expr * expr, gfc_typespec * ts, tree type,
     {
       switch (ts->type)
 	{
-	case BT_DERIVED:
 	case BT_CLASS:
+        case_struct_bt:
 	  gfc_init_se (&se, NULL);
 	  if (ts->type == BT_CLASS && expr->expr_type == EXPR_NULL)
 	    gfc_conv_structure (&se, gfc_class_null_initializer(ts, expr), 1);
@@ -5829,7 +5833,7 @@ gfc_trans_alloc_subarray_assign (tree dest, gfc_component * cm,
   gfc_add_modify (&block, dest, se.expr);
 
   /* Deal with arrays of derived types with allocatable components.  */
-  if (cm->ts.type == BT_DERIVED
+  if (gfc_bt_struct (cm->ts.type)
 	&& cm->ts.u.derived->attr.alloc_comp)
     tmp = gfc_copy_alloc_comp (cm->ts.u.derived,
 			       se.expr, dest,
@@ -6016,7 +6020,7 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr)
 	  gfc_add_expr_to_block (&block, tmp);
 	}
     }
-  else if (expr->ts.type == BT_DERIVED)
+  else if (gfc_bt_struct (cm->ts.type))
     {
       if (expr->expr_type != EXPR_STRUCTURE)
 	{
@@ -6123,6 +6127,23 @@ gfc_conv_structure (gfc_se * se, gfc_expr * expr, int init)
       return;
     }
 
+  /* Though unions appear to have multiple map components, they must only
+     have a single initializer since each map overlaps. */
+  if (expr->ts.type == BT_UNION)
+  {
+    c = gfc_constructor_first (expr->value.constructor);
+    cm = c->n.component;
+    val = gfc_conv_initializer (c->expr, &expr->ts,
+                                TREE_TYPE (cm->backend_decl),
+                                cm->attr.dimension, cm->attr.pointer,
+                                cm->attr.proc_pointer);
+    val = unshare_expr_without_location (val);
+
+    /* Append it to the constructor list.  */
+    CONSTRUCTOR_APPEND_ELT (v, cm->backend_decl, val);
+    goto finish;
+  }
+
   cm = expr->ts.u.derived->components;
 
   for (c = gfc_constructor_first (expr->value.constructor);
@@ -6163,6 +6184,7 @@ gfc_conv_structure (gfc_se * se, gfc_expr * expr, int init)
 	  CONSTRUCTOR_APPEND_ELT (v, cm->backend_decl, val);
 	}
     }
+finish:
   se->expr = build_constructor (type, v);
   if (init)
     TREE_CONSTANT (se->expr) = 1;
@@ -6835,7 +6857,7 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,
       gfc_trans_string_copy (&block, llen, lse->expr, ts.kind, rlen,
 			     rse->expr, ts.kind);
     }
-  else if (ts.type == BT_DERIVED && ts.u.derived->attr.alloc_comp)
+  else if (gfc_bt_struct (ts.type) && ts.u.derived->attr.alloc_comp)
     {
       cond = NULL_TREE;
 
@@ -6878,7 +6900,7 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,
 	  gfc_add_expr_to_block (&block, tmp);
 	}
     }
-  else if (ts.type == BT_DERIVED || ts.type == BT_CLASS)
+  else if (gfc_bt_struct (ts.type) || ts.type == BT_CLASS)
     {
       gfc_add_block_to_block (&block, &lse->pre);
       gfc_add_block_to_block (&block, &rse->pre);
@@ -7096,7 +7118,7 @@ fcncall_realloc_result (gfc_se *se, int rank)
 
   res_desc = gfc_evaluate_now (desc, &se->pre);
   gfc_conv_descriptor_data_set (&se->pre, res_desc, null_pointer_node);
-  se->expr = gfc_build_addr_expr (TREE_TYPE (se->expr), res_desc);
+  se->expr = gfc_build_addr_expr (NULL_TREE, res_desc);
 
   /* Free the lhs after the function call and copy the result data to
      the lhs descriptor.  */
@@ -7889,7 +7911,7 @@ copyable_array_p (gfc_expr * expr)
     case BT_CHARACTER:
       return false;
 
-    case BT_DERIVED:
+    case_struct_bt:
       return !expr->ts.u.derived->attr.alloc_comp;
 
     default:
diff --git a/gcc/fortran/trans-intrinsic.c b/gcc/fortran/trans-intrinsic.c
index 273c86f..38fd8f4 100644
--- a/gcc/fortran/trans-intrinsic.c
+++ b/gcc/fortran/trans-intrinsic.c
@@ -97,6 +97,12 @@ gfc_intrinsic_map_t;
     BUILT_IN_C ## ID ## L, true, true, true, NAME, NULL_TREE, NULL_TREE, \
     NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE},
 
+#define MATH_ALIAS_BUILTIN(NEWID, ID, NAME, TYPE) \
+  { GFC_ISYM_ ## NEWID, BUILT_IN_ ## ID ## F, BUILT_IN_ ## ID, \
+    BUILT_IN_ ## ID ## L, END_BUILTINS, END_BUILTINS, END_BUILTINS, \
+    true, false, true, NAME, NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE, \
+    NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE},
+
 #define LIB_FUNCTION(ID, NAME, HAVE_COMPLEX) \
   { GFC_ISYM_ ## ID, END_BUILTINS, END_BUILTINS, END_BUILTINS, \
     END_BUILTINS, END_BUILTINS, END_BUILTINS, \
@@ -125,6 +131,7 @@ static GTY(()) gfc_intrinsic_map_t gfc_intrinsic_map[] =
 };
 #undef OTHER_BUILTIN
 #undef LIB_FUNCTION
+#undef MATH_ALIAS_BUILTIN
 #undef DEFINE_MATH_BUILTIN
 #undef DEFINE_MATH_BUILTIN_C
 
@@ -654,6 +661,7 @@ gfc_build_intrinsic_lib_fndecls (void)
 
 #define DEFINE_MATH_BUILTIN(ID, NAME, ARGTYPE)
 #define DEFINE_MATH_BUILTIN_C(ID, NAME, ARGTYPE)
+#define MATH_ALIAS_BUILTIN(NEWID, ID, NAME, TYPE)
 #define LIB_FUNCTION(ID, NAME, HAVE_COMPLEX)
 
     /* Only these built-ins are actually needed here. These are used directly
@@ -667,6 +675,7 @@ gfc_build_intrinsic_lib_fndecls (void)
 
 #undef OTHER_BUILTIN
 #undef LIB_FUNCTION
+#undef MATH_ALIAS_BUILTIN
 #undef DEFINE_MATH_BUILTIN
 #undef DEFINE_MATH_BUILTIN_C
 
diff --git a/gcc/fortran/trans-io.c b/gcc/fortran/trans-io.c
index a11453d..2318201 100644
--- a/gcc/fortran/trans-io.c
+++ b/gcc/fortran/trans-io.c
@@ -1005,6 +1005,15 @@ gfc_trans_open (gfc_code * code)
     mask |= set_parameter_ref (&block, &post_block, var, IOPARM_open_newunit,
 			       p->newunit);
 
+  if (p->share)
+    mask |= set_string (&block, &post_block, var, IOPARM_open_share,
+                        p->share);
+
+  if (p->cc)
+    mask |= set_string (&block, &post_block, var, IOPARM_open_cc, p->cc);
+
+  mask |= set_parameter_const (&block, var, IOPARM_open_readonly, p->readonly);
+
   set_parameter_const (&block, var, IOPARM_common_flags, mask);
 
   if (p->unit)
@@ -1613,7 +1622,7 @@ transfer_namelist_element (stmtblock_t * block, const char * var_name,
       gfc_add_expr_to_block (block, tmp);
     }
 
-  if (ts->type == BT_DERIVED && ts->u.derived->components)
+  if (gfc_bt_struct (ts->type) && ts->u.derived->components)
     {
       gfc_component *cmp;
 
@@ -2149,7 +2158,7 @@ transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr, gfc_code * code)
 
       break;
 
-    case BT_DERIVED:
+    case_struct_bt:
       if (ts->u.derived->components == NULL)
 	return;
 
@@ -2268,7 +2277,7 @@ gfc_trans_transfer (gfc_code * code)
 	  gcc_assert (ref && ref->type == REF_ARRAY);
 	}
 
-      if (expr->ts.type != BT_DERIVED
+      if (!gfc_bt_struct (expr->ts.type)
 	    && ref && ref->next == NULL
 	    && !is_subref_array (expr))
 	{
diff --git a/gcc/fortran/trans-stmt.c b/gcc/fortran/trans-stmt.c
index 1d8588d..68cfb65 100644
--- a/gcc/fortran/trans-stmt.c
+++ b/gcc/fortran/trans-stmt.c
@@ -5471,7 +5471,7 @@ gfc_trans_deallocate (gfc_code *code)
 
       if (expr->rank || gfc_is_coarray (expr))
 	{
-	  if (expr->ts.type == BT_DERIVED && expr->ts.u.derived->attr.alloc_comp)
+	  if (gfc_bt_struct (expr->ts.type) && expr->ts.u.derived->attr.alloc_comp)
 	    {
 	      gfc_ref *ref;
 	      gfc_ref *last = NULL;
diff --git a/gcc/fortran/trans-types.c b/gcc/fortran/trans-types.c
index 30561ee..fd18675 100644
--- a/gcc/fortran/trans-types.c
+++ b/gcc/fortran/trans-types.c
@@ -1100,6 +1100,10 @@ gfc_typenode_for_spec (gfc_typespec * spec)
 	basetype = gfc_get_character_type (spec->kind, spec->u.cl);
       break;
 
+    case BT_UNION:
+      basetype = gfc_get_union_type (spec->u.derived);
+      break;
+
     case BT_DERIVED:
     case BT_CLASS:
       basetype = gfc_get_derived_type (spec->u.derived);
@@ -2323,6 +2327,61 @@ gfc_get_ppc_type (gfc_component* c)
   return build_pointer_type (build_function_type_list (t, NULL_TREE));
 }
 
+/* Build a tree node for a union type. Requires building each map
+   structure which is an element of the union. */
+
+tree
+gfc_get_union_type (gfc_symbol *un)
+{
+    gfc_component *map = NULL;
+    tree typenode = NULL, map_type = NULL, map_field = NULL;
+    tree *chain = NULL;
+
+    if (un->backend_decl)
+    {
+      if (TYPE_FIELDS (un->backend_decl) || un->attr.proc_pointer_comp)
+        return un->backend_decl;
+      else
+        typenode = un->backend_decl;
+    }
+    else
+    {
+      typenode = make_node (UNION_TYPE);
+      TYPE_NAME (typenode) = get_identifier (un->name);
+    }
+
+    /* Add each contained MAP as a field. */
+    for (map = un->components; map; map = map->next)
+    {
+        gcc_assert (map->ts.type == BT_DERIVED);
+
+        /* The map's type node, which is defined within this union's context. */
+        map_type = gfc_get_derived_type (map->ts.u.derived);
+        TYPE_CONTEXT (map_type) = typenode;
+
+        /* The map field's declaration. */
+        map_field = gfc_add_field_to_struct(typenode, get_identifier(map->name),
+                                            map_type, &chain);
+        if (map->loc.lb)
+          gfc_set_decl_location (map_field, &map->loc);
+        else if (un->declared_at.lb)
+          gfc_set_decl_location (map_field, &un->declared_at);
+
+        DECL_PACKED (map_field) |= TYPE_PACKED (typenode);
+        DECL_NAMELESS(map_field) = true;
+
+        /* We should never clobber another backend declaration for this map,
+           because each map component is unique. */
+        if (!map->backend_decl)
+          map->backend_decl = map_field;
+    }
+
+    un->backend_decl = typenode;
+    gfc_finish_type (typenode);
+
+    return typenode;
+}
+
 
 /* Build a tree node for a derived type.  If there are equal
    derived types, with different local names, these are built
@@ -2443,37 +2502,40 @@ gfc_get_derived_type (gfc_symbol * derived)
      pointer component (PR24092). If this happens, the fields
      will be built and so we can return the type.  */
   for (c = derived->components; c; c = c->next)
-    {
-      if (c->ts.type != BT_DERIVED && c->ts.type != BT_CLASS)
-	continue;
+  {
+    if (c->ts.type != BT_DERIVED && c->ts.type != BT_CLASS)
+      continue;
 
-      if ((!c->attr.pointer && !c->attr.proc_pointer)
-	  || c->ts.u.derived->backend_decl == NULL)
-	c->ts.u.derived->backend_decl = gfc_get_derived_type (c->ts.u.derived);
+    if ((!c->attr.pointer && !c->attr.proc_pointer)
+        || c->ts.u.derived->backend_decl == NULL)
+      c->ts.u.derived->backend_decl = gfc_get_derived_type (c->ts.u.derived);
 
-      if (c->ts.u.derived->attr.is_iso_c)
-        {
-          /* Need to copy the modified ts from the derived type.  The
-             typespec was modified because C_PTR/C_FUNPTR are translated
-             into (void *) from derived types.  */
-          c->ts.type = c->ts.u.derived->ts.type;
-          c->ts.kind = c->ts.u.derived->ts.kind;
-          c->ts.f90_type = c->ts.u.derived->ts.f90_type;
-	  if (c->initializer)
-	    {
-	      c->initializer->ts.type = c->ts.type;
-	      c->initializer->ts.kind = c->ts.kind;
-	      c->initializer->ts.f90_type = c->ts.f90_type;
-	      c->initializer->expr_type = EXPR_NULL;
-	    }
-        }
-    }
+    if (c->ts.u.derived->attr.is_iso_c)
+      {
+        /* Need to copy the modified ts from the derived type.  The
+           typespec was modified because C_PTR/C_FUNPTR are translated
+           into (void *) from derived types.  */
+        c->ts.type = c->ts.u.derived->ts.type;
+        c->ts.kind = c->ts.u.derived->ts.kind;
+        c->ts.f90_type = c->ts.u.derived->ts.f90_type;
+        if (c->initializer)
+          {
+            c->initializer->ts.type = c->ts.type;
+            c->initializer->ts.kind = c->ts.kind;
+            c->initializer->ts.f90_type = c->ts.f90_type;
+            c->initializer->expr_type = EXPR_NULL;
+          }
+      }
+  }
 
   if (TYPE_FIELDS (derived->backend_decl))
     return derived->backend_decl;
 
   /* Build the type member list. Install the newly created RECORD_TYPE
-     node as DECL_CONTEXT of each FIELD_DECL.  */
+     node as DECL_CONTEXT of each FIELD_DECL. In this case we must go
+     through only the top-level linked list of components so we correctly
+     build UNION_TYPE nodes for BT_UNION components. MAPs and other nested
+     types are built as part of gfc_get_union_type. */
   for (c = derived->components; c; c = c->next)
     {
       if (c->attr.proc_pointer)
diff --git a/gcc/fortran/trans.c b/gcc/fortran/trans.c
index d7bdf26..11e76d3 100644
--- a/gcc/fortran/trans.c
+++ b/gcc/fortran/trans.c
@@ -1041,7 +1041,7 @@ gfc_build_final_call (gfc_typespec ts, gfc_expr *final_wrapper, gfc_expr *var,
   if (POINTER_TYPE_P (TREE_TYPE (final_fndecl)))
     final_fndecl = build_fold_indirect_ref_loc (input_location, final_fndecl);
 
-  if (ts.type == BT_DERIVED)
+  if (gfc_bt_struct (ts.type))
     {
       tree elem_size;
 
@@ -1186,7 +1186,7 @@ gfc_deallocate_scalar_with_status (tree pointer, tree status, bool can_fail,
   gfc_start_block (&non_null);
 
   /* Free allocatable components.  */
-  if (ts.type == BT_DERIVED && ts.u.derived->attr.alloc_comp)
+  if (gfc_bt_struct (ts.type) && ts.u.derived->attr.alloc_comp)
     {
       tmp = build_fold_indirect_ref_loc (input_location, pointer);
       tmp = gfc_deallocate_alloc_comp (ts.u.derived, tmp, 0);
diff --git a/gcc/testsuite/gfortran.dg/assert.inc b/gcc/testsuite/gfortran.dg/assert.inc
new file mode 100644
index 0000000..40512b0
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/assert.inc
@@ -0,0 +1,62 @@
+
+      subroutine assert(s, b)
+        character*(*) s
+        logical b
+        if (.not. b) then
+          print *, s
+          call abort
+        endif
+      endsubroutine
+
+      subroutine assertss(s, s1, s2)
+        character*(*) s, s1, s2
+        if (s1 /= s2) then
+          print *, s, ": expected ", s2, " but was ", s1
+          call abort
+        endif
+      endsubroutine
+
+      subroutine assertbb(s, b1, b2)
+        character*(*) s
+        integer(1) b1, b2
+        if (b1 .ne. b2) then
+          print *, s, ": expected ", b2, " but was ", b1
+          call abort
+        endif
+      endsubroutine
+
+      subroutine assertii(s, i1, i2)
+        character*(*) s
+        integer(2) i1, i2
+        if (i1 .ne. i2) then
+          print *, s, ": expected ", i2, " but was ", i1
+          call abort
+        endif
+      endsubroutine
+
+      subroutine assertll(s, l1, l2)
+        character*(*) s
+        integer(4) l1, l2
+        if (l1 .ne. l2) then
+          print *, s, ": expected ", l2, " but was ", l1
+          call abort
+        endif
+      endsubroutine
+
+      subroutine assertqq(s, q1, q2)
+        character*(*) s
+        integer(8) q1, q2
+        if (q1 .ne. q2) then
+          print *, s, ": expected ", q2, " but was ", q1
+          call abort
+        endif
+      endsubroutine
+
+      subroutine assertrr(s, r1, r2)
+        character*(*) s
+        real r1, r2
+        if (r1 .ne. r2) then
+          print *, s, ": expected ", r1, " but was ", r2
+          call abort
+        endif
+      endsubroutine
diff --git a/gcc/testsuite/gfortran.dg/auto_save_2.f90 b/gcc/testsuite/gfortran.dg/auto_save_2.f90
new file mode 100644
index 0000000..0d39d48
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/auto_save_2.f90
@@ -0,0 +1,52 @@
+! { dg-do run }
+! { dg-options "-fno-automatic -finit-local-zero" }
+!
+! Make sure variables are saved with -fno-automatic except in
+! functions marked RECURSIVE, and that they are still initialized with
+! -finit-local-zero.
+!
+
+function f (x)
+implicit none
+  integer f, x
+  integer a ! should be SAVEd
+  a = a + x ! should increment by y every time
+  f = a
+  return
+endfunction
+
+recursive function g (x)
+implicit none
+  integer g, x
+  integer b ! should be automatic
+  b = b + x ! should be set to y every time
+  g = b
+  return
+endfunction
+
+implicit none
+integer f, g
+
+! Should return static value of a; accumulates y
+if ( f(3) .ne. 3 ) then
+  call abort ()
+endif
+if ( f(4) .ne. 7 ) then
+  call abort ()
+endif
+if ( f(2) .ne. 9 ) then
+  call abort ()
+endif
+
+! Should return automatic value of a; equal to y each time
+if ( g(3) .ne. 3 ) then
+  call abort ()
+endif
+if ( g(4) .ne. 4 ) then
+  call abort ()
+endif
+if ( g(2) .ne. 2 ) then
+  call abort ()
+endif
+
+end
diff --git a/gcc/testsuite/gfortran.dg/cray_pointers_10.f90 b/gcc/testsuite/gfortran.dg/cray_pointers_10.f90
new file mode 100644
index 0000000..fcc0132
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/cray_pointers_10.f90
@@ -0,0 +1,22 @@
+! { dg-do compile }
+! { dg-options "-fcray-pointer" }
+!
+! Since the introduction of Cray pointers in 4.1.0 as late as 4.8.3,
+! component declarations within derived types would overwrite the typespec of 
+! variables with the same name who were Cray pointees.
+implicit none
+
+type t1
+  integer i
+end type t1
+type(t1) x
+
+pointer (x_ptr, x)
+
+type t2
+  real x ! should not overwrite x's type
+end type t2
+
+x%i = 0 ! should see no error here
+
+end
diff --git a/gcc/testsuite/gfortran.dg/dec/README b/gcc/testsuite/gfortran.dg/dec/README
new file mode 100644
index 0000000..56973d2
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/README
@@ -0,0 +1,12 @@
+This testsuite is for testing gfortran's support for the large suite of
+non-standard Digital Equipment Corporation (DEC) extensions.
+
+TODO:
+ o  Fix -fdec-io tests to test for correctness
+
+
+Copyright (C) 2004-2013 Free Software Foundation, Inc.
+
+Copying and distribution of this file, with or without modification,
+are permitted in any medium without royalty provided the copyright
+notice and this notice are preserved.
diff --git a/gcc/testsuite/gfortran.dg/dec/achar.f90 b/gcc/testsuite/gfortran.dg/dec/achar.f90
new file mode 100644
index 0000000..eb49db8
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/achar.f90
@@ -0,0 +1,21 @@
+! { dg-do run }
+! { dg-options "-fbounds-check" }
+! Tests the fix for PR31257, in which achar caused an ICE because it had no
+! charlen.
+!
+! The code comes from http://www.star.le.ac.uk/~cgp/fortran.html (by Clive Page)
+! Reported by Thomas Koenig <tkoenig@gcc.gnu.org>
+!
+  if (any (Up ("AbCdEfGhIjKlM") .ne. (/"ABCDEFGHIJKLM"/))) call abort ()
+contains
+  Character (len=20) Function Up (string)
+    Character(len=*) string
+    Up =                                                                &
+     transfer(merge(achar(iachar(transfer(string,"x",len(string)))-     &
+     (ichar('a')-ichar('A')) ),                                         &
+     transfer(string,"x",len(string)) ,                                 &
+     transfer(string,"x",len(string)) >= "a" .and.                      &
+     transfer(string,"x",len(string)) <= "z"), repeat("x", len(string)))
+    return
+  end function Up
+end
diff --git a/gcc/testsuite/gfortran.dg/dec/acos.f b/gcc/testsuite/gfortran.dg/dec/acos.f
new file mode 100644
index 0000000..ef95933
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/acos.f
@@ -0,0 +1,30 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-structure" }
+      !
+      include 'eqt.inc'
+      include 'checkf.inc'
+
+      PROGRAM MAIN
+      include 'decl.inc'
+
+      ! Input
+      F_I = 0.68032123_4
+      D_I = 0.68032123_8
+      !Q_I = 0.68032123_16
+
+      ! Expected
+      F_OE = 0.822595489748_4
+      D_OE = 0.822595489748_8
+      !Q_OE = 0.822595489748_16
+
+      ! Actual
+      F_OA =  ACOS (F_I)
+      F_OC =  ACOS (0.68032123_4)
+      D_OA = DACOS (D_I)
+      D_OC = DACOS (0.68032123_8)
+      !Q_OA = QACOS (Q_I)
+      !Q_OC = QACOS (0.68032123_16)
+
+      include 'check.inc'
+
+      END PROGRAM MAIN
diff --git a/gcc/testsuite/gfortran.dg/dec/acosd.f b/gcc/testsuite/gfortran.dg/dec/acosd.f
new file mode 100644
index 0000000..3c70b9d
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/acosd.f
@@ -0,0 +1,30 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-math" }
+      !
+      include 'eqt.inc'
+      include 'checkf.inc'
+
+      PROGRAM MAIN
+      include 'decl.inc'
+
+      ! Input
+      F_I = 0.68032123_4
+      D_I = 0.68032123_8
+      !Q_I = 0.68032123_16
+
+      ! Expected
+      F_OE = 47.131249809_4
+      D_OE = 47.131249809_8
+      !Q_OE = 47.131249809_16
+
+      ! Actual
+      F_OA =  ACOSD (F_I)
+      F_OC =  ACOSD (0.68032123_4)
+      D_OA = DACOSD (D_I)
+      D_OC = DACOSD (0.68032123_8)
+      !Q_OA = QACOSD (Q_I)
+      !Q_OC = QACOSD (0.68032123_16)
+
+      include 'check.inc'
+
+      END PROGRAM MAIN
diff --git a/gcc/testsuite/gfortran.dg/dec/asin.f b/gcc/testsuite/gfortran.dg/dec/asin.f
new file mode 100644
index 0000000..9c26039
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/asin.f
@@ -0,0 +1,30 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-math" }
+      !
+      include 'eqt.inc'
+      include 'checkf.inc'
+
+      PROGRAM MAIN
+      include 'decl.inc'
+
+      ! Input
+      F_I = 0.79345021_4
+      D_I = 0.79345021_8
+      !Q_I = 0.79345021_16
+
+      ! Expected
+      F_OE = 0.916456999698_4
+      D_OE = 0.916456999698_8
+      !Q_OE = 0.916456999698_16
+
+      ! Actual
+      F_OA =  ASIN (F_I)
+      F_OC =  ASIN (0.79345021_4)
+      D_OA = DASIN (D_I)
+      D_OC = DASIN (0.79345021_8)
+      !Q_OA = QASIN (Q_I)
+      !Q_OC = QASIN (0.79345021_16)
+
+      include 'check.inc'
+
+      END PROGRAM MAIN
diff --git a/gcc/testsuite/gfortran.dg/dec/asind.f b/gcc/testsuite/gfortran.dg/dec/asind.f
new file mode 100644
index 0000000..4c24331
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/asind.f
@@ -0,0 +1,30 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-math" }
+      !
+      include 'eqt.inc'
+      include 'checkf.inc'
+
+      PROGRAM MAIN
+      include 'decl.inc'
+
+      ! Input
+      F_I = 0.79345021_4
+      D_I = 0.79345021_8
+      !Q_I = 0.79345021_16
+
+      ! Expected
+      F_OE = 52.5091181879_4
+      D_OE = 52.5091181879_8
+      !Q_OE = 52.5091181879_16
+
+      ! Actual
+      F_OA =  ASIND (F_I)
+      F_OC =  ASIND (0.79345021_4)
+      D_OA = DASIND (D_I)
+      D_OC = DASIND (0.79345021_8)
+      !Q_OA = QASIND (Q_I)
+      !Q_OC = QASIND (0.79345021_16)
+
+      include 'check.inc'
+
+      END PROGRAM MAIN
diff --git a/gcc/testsuite/gfortran.dg/dec/assert.inc b/gcc/testsuite/gfortran.dg/dec/assert.inc
new file mode 100644
index 0000000..40512b0
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/assert.inc
@@ -0,0 +1,62 @@
+
+      subroutine assert(s, b)
+        character*(*) s
+        logical b
+        if (.not. b) then
+          print *, s
+          call abort
+        endif
+      endsubroutine
+
+      subroutine assertss(s, s1, s2)
+        character*(*) s, s1, s2
+        if (s1 /= s2) then
+          print *, s, ": expected ", s2, " but was ", s1
+          call abort
+        endif
+      endsubroutine
+
+      subroutine assertbb(s, b1, b2)
+        character*(*) s
+        integer(1) b1, b2
+        if (b1 .ne. b2) then
+          print *, s, ": expected ", b2, " but was ", b1
+          call abort
+        endif
+      endsubroutine
+
+      subroutine assertii(s, i1, i2)
+        character*(*) s
+        integer(2) i1, i2
+        if (i1 .ne. i2) then
+          print *, s, ": expected ", i2, " but was ", i1
+          call abort
+        endif
+      endsubroutine
+
+      subroutine assertll(s, l1, l2)
+        character*(*) s
+        integer(4) l1, l2
+        if (l1 .ne. l2) then
+          print *, s, ": expected ", l2, " but was ", l1
+          call abort
+        endif
+      endsubroutine
+
+      subroutine assertqq(s, q1, q2)
+        character*(*) s
+        integer(8) q1, q2
+        if (q1 .ne. q2) then
+          print *, s, ": expected ", q2, " but was ", q1
+          call abort
+        endif
+      endsubroutine
+
+      subroutine assertrr(s, r1, r2)
+        character*(*) s
+        real r1, r2
+        if (r1 .ne. r2) then
+          print *, s, ": expected ", r1, " but was ", r2
+          call abort
+        endif
+      endsubroutine
diff --git a/gcc/testsuite/gfortran.dg/dec/atan.f b/gcc/testsuite/gfortran.dg/dec/atan.f
new file mode 100644
index 0000000..de226c4
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/atan.f
@@ -0,0 +1,30 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-math" }
+      !
+      include 'eqt.inc'
+      include 'checkf.inc'
+
+      PROGRAM MAIN
+      include 'decl.inc'
+
+      ! Input
+      F_I = 1.5874993_4
+      D_I = 1.5874993_8
+      !Q_I = 1.5874993_16
+
+      ! Expected
+      F_OE = 1.00866575383_4
+      D_OE = 1.00866575383_8
+      !Q_OE = 1.00866575383_16
+
+      ! Actual
+      F_OA =  ATAN (F_I)
+      F_OC =  ATAN (1.5874993_4)
+      D_OA = DATAN (D_I)
+      D_OC = DATAN (1.5874993_8)
+      !Q_OA = QATAN (Q_I)
+      !Q_OC = QATAN (1.5874993_16)
+
+      include 'check.inc'
+
+      END PROGRAM MAIN
diff --git a/gcc/testsuite/gfortran.dg/dec/atan2d.f b/gcc/testsuite/gfortran.dg/dec/atan2d.f
new file mode 100644
index 0000000..67183ec
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/atan2d.f
@@ -0,0 +1,46 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-math" }
+      !
+      include 'eqt.inc'
+      include 'checkf.inc'
+
+      PROGRAM MAIN
+      IMPLICIT NONE
+
+      LOGICAL f_eqt, d_eqt!, q_eqt
+      LOGICAL BF, CF, BD, CD!, BQ, CQ
+      CHARACTER*12 E, A
+
+      ! in,   out expected,   out actual,   out from constant input
+      REAL*4  F_I1, F_I2, F_OE, F_OA, F_OC, F_TOL
+      REAL*8  D_I1, D_I2, D_OE, D_OA, D_OC, D_TOL
+      !REAL*16 Q_I1, Q_I2, Q_OE, Q_OA, Q_OC, Q_TOL
+
+      F_TOL = 5e-5_4
+      D_TOL = 5e-6_8
+      !Q_TOL = 5e-6_16
+
+      ! Input
+      F_I1 = 2.679676_4
+      F_I2 = 1.0_4
+      D_I1 = 2.679676_8
+      D_I2 = 1.0_8
+      !Q_I1 = 2.679676_16
+      !Q_I2 = 1.0_16
+
+      ! Expected
+      F_OE = 69.53546_4
+      D_OE = 69.53546_8
+      !Q_OE = 69.53546_16
+
+      ! Actual
+      F_OA =  ATAN2D (F_I1, F_I2)
+      F_OC =  ATAN2D (2.679676_4, 1.0_4)
+      D_OA = DATAN2D (D_I1, D_I2)
+      D_OC = DATAN2D (2.679676_8, 1.0_8)
+      !Q_OA = QATAN2D (Q_I1, Q_I2)
+      !Q_OC = QATAN2D (2.679676_16, 1.0_16)
+
+      include 'check.inc'
+
+      END PROGRAM MAIN
diff --git a/gcc/testsuite/gfortran.dg/dec/atand.f b/gcc/testsuite/gfortran.dg/dec/atand.f
new file mode 100644
index 0000000..796fe1f
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/atand.f
@@ -0,0 +1,30 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-math" }
+      !
+      include 'eqt.inc'
+      include 'checkf.inc'
+
+      PROGRAM MAIN
+      include 'decl.inc'
+
+      ! Input
+      F_I = 1.5874993_4
+      D_I = 1.5874993_8
+      !Q_I = 1.5874993_16
+
+      ! Expected
+      F_OE = 57.7922906336_4
+      D_OE = 57.7922906336_8
+      !Q_OE = 57.7922906336_16
+
+      ! Actual
+      F_OA =  ATAND (F_I)
+      F_OC =  ATAND (1.5874993_4)
+      D_OA = DATAND (D_I)
+      D_OC = DATAND (1.5874993_8)
+      !Q_OA = QATAND (Q_I)
+      !Q_OC = QATAND (1.5874993_16)
+
+      include 'check.inc'
+
+      END PROGRAM MAIN
diff --git a/gcc/testsuite/gfortran.dg/dec/bijk_btest.f b/gcc/testsuite/gfortran.dg/dec/bijk_btest.f
new file mode 100644
index 0000000..f21cb1a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bijk_btest.f
@@ -0,0 +1,35 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-intrinsic-ints" }
+      !
+      ! Tests the extended integer formats on bitwise and other
+      ! functions (BIJK-prefixes).
+      !
+
+      PROGRAM MAIN
+      IMPLICIT NONE
+
+      INTEGER*1 :: IB = 9_1, BPOS = 3_1
+      INTEGER*2 :: II = 9_2, IPOS = 3_2
+      INTEGER*4 :: IJ = 9_4, JPOS = 3_4
+      INTEGER*8 :: IK = 9_8, KPOS = 3_8
+      INTEGER   :: I  = 9  ,  POS = 3
+
+      LOGICAL*1 :: LB
+      LOGICAL*2 :: LI
+      LOGICAL*4 :: LJ
+      LOGICAL*8 :: LK
+      LOGICAL   :: L
+
+      LB = BBTEST(IB, BPOS)
+      LI = BITEST(II, IPOS)
+      LJ = BJTEST(IJ, JPOS)
+      LK = BKTEST(IK, KPOS)
+      L  =  BTEST(I ,  POS)
+
+      LB = BBTEST(9_1, 3_1)
+      LI = BITEST(9_2, 3_2)
+      LJ = BJTEST(9_4, 3_4)
+      LK = BKTEST(9_8, 3_8)
+      L  =  BTEST(9  , 3  )
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bijk_float.f b/gcc/testsuite/gfortran.dg/dec/bijk_float.f
new file mode 100644
index 0000000..deff903
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bijk_float.f
@@ -0,0 +1,28 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-intrinsic-ints" }
+      !
+      ! Tests the extended integer formats on bitwise and other
+      ! functions (BIJK-prefixes).
+      !
+
+      PROGRAM MAIN
+      IMPLICIT NONE
+
+      INTEGER*2 :: AI = 9_2
+      INTEGER*4 :: AJ = 9_4
+      INTEGER*8 :: AK = 9_8
+      INTEGER   :: A  = 9
+
+      REAL :: R
+
+      R = FLOATI(AI)
+      R = FLOATJ(AJ)
+      R = FLOATK(AK)
+      R = FLOAT (A )
+
+      R = FLOATI(9_2)
+      R = FLOATJ(9_4)
+      R = FLOATK(9_8)
+      R = FLOAT (9  )
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bijk_iabs.f b/gcc/testsuite/gfortran.dg/dec/bijk_iabs.f
new file mode 100644
index 0000000..a7a553d
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bijk_iabs.f
@@ -0,0 +1,29 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-intrinsic-ints" }
+      !
+      ! Tests the extended integer formats on bitwise and other
+      ! functions (BIJK-prefixes).
+      !
+
+      PROGRAM MAIN
+      IMPLICIT NONE
+
+      INTEGER*1 :: AB = -9_1, BB
+      INTEGER*2 :: AI = -9_2, BI
+      INTEGER*4 :: AJ = -9_4, BJ
+      INTEGER*8 :: AK = -9_8, BK
+      INTEGER   :: A  = -9  , B
+
+      BB =  BABS(AB)
+      BI = IIABS(AI)
+      BJ = JIABS(AJ)
+      BK = KIABS(AK)
+      B  =  IABS(A )
+
+      BB =  BABS(9_1)
+      BI = IIABS(9_2)
+      BJ = JIABS(9_4)
+      BK = KIABS(9_8)
+      B  =  IABS(9  )
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bijk_iand.f b/gcc/testsuite/gfortran.dg/dec/bijk_iand.f
new file mode 100644
index 0000000..48fd07c
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bijk_iand.f
@@ -0,0 +1,29 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-intrinsic-ints" }
+      !
+      ! Tests the extended integer formats on bitwise and other
+      ! functions (BIJK-prefixes).
+      !
+
+      PROGRAM MAIN
+      IMPLICIT NONE
+
+      INTEGER*1 :: AB = 9_1, BB = 3_1, CB
+      INTEGER*2 :: AI = 9_2, BI = 3_2, CI
+      INTEGER*4 :: AJ = 9_4, BJ = 3_4, CJ
+      INTEGER*8 :: AK = 9_8, BK = 3_8, CK
+      INTEGER   :: A  = 9  , B  = 3  , C
+
+      CB = BIAND(AB, BB)
+      CI = IIAND(AI, BI)
+      CJ = JIAND(AJ, BJ)
+      CK = KIAND(AK, BK)
+      C  =  IAND(A , B )
+
+      CB = BIAND(9_1, 3_1)
+      CI = IIAND(9_2, 3_2)
+      CJ = JIAND(9_4, 3_4)
+      CK = KIAND(9_8, 3_8)
+      C  =  IAND(9  , 3  )
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bijk_ibclr.f b/gcc/testsuite/gfortran.dg/dec/bijk_ibclr.f
new file mode 100644
index 0000000..fccc6b4
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bijk_ibclr.f
@@ -0,0 +1,29 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-intrinsic-ints" }
+      !
+      ! Tests the extended integer formats on bitwise and other
+      ! functions (BIJK-prefixes).
+      !
+
+      PROGRAM MAIN
+      IMPLICIT NONE
+
+      INTEGER*1 :: IB = 9_1, BPOS = 3_1, CB
+      INTEGER*2 :: II = 9_2, IPOS = 3_2, CI
+      INTEGER*4 :: IJ = 9_4, JPOS = 3_4, CJ
+      INTEGER*8 :: IK = 9_8, KPOS = 3_8, CK
+      INTEGER   :: I  = 9  ,  POS = 3  , C
+
+      CB =  BBCLR(IB, BPOS)
+      CI = IIBCLR(II, IPOS)
+      CJ = JIBCLR(IJ, JPOS)
+      CK = KIBCLR(IK, KPOS)
+      C  =  IBCLR(I ,  POS)
+
+      CB =  BBCLR(9_1, 3_1)
+      CI = IIBCLR(9_2, 3_2)
+      CJ = JIBCLR(9_4, 3_4)
+      CK = KIBCLR(9_8, 3_8)
+      C  =  IBCLR(I ,  POS)
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bijk_ibset.f b/gcc/testsuite/gfortran.dg/dec/bijk_ibset.f
new file mode 100644
index 0000000..5d39a0a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bijk_ibset.f
@@ -0,0 +1,29 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-intrinsic-ints" }
+      !
+      ! Tests the extended integer formats on bitwise and other
+      ! functions (BIJK-prefixes).
+      !
+
+      PROGRAM MAIN
+      IMPLICIT NONE
+
+      INTEGER*1 :: IB = 9_1, BPOS = 3_1, CB
+      INTEGER*2 :: II = 9_2, IPOS = 3_2, CI
+      INTEGER*4 :: IJ = 9_4, JPOS = 3_4, CJ
+      INTEGER*8 :: IK = 9_8, KPOS = 3_8, CK
+      INTEGER   :: I  = 9  ,  POS = 3  , C
+
+      CB =  BBSET(IB, BPOS)
+      CI = IIBSET(II, IPOS)
+      CJ = JIBSET(IJ, JPOS)
+      CK = KIBSET(IK, KPOS)
+      C  =  IBSET(I ,  POS)
+
+      CB =  BBSET(9_1, 3_1)
+      CI = IIBSET(9_2, 3_2)
+      CJ = JIBSET(9_4, 3_4)
+      CK = KIBSET(9_8, 3_8)
+      C  =  IBSET(I ,  POS)
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bijk_ieor.f b/gcc/testsuite/gfortran.dg/dec/bijk_ieor.f
new file mode 100644
index 0000000..f38ac9e
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bijk_ieor.f
@@ -0,0 +1,29 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-intrinsic-ints" }
+      !
+      ! Tests the extended integer formats on bitwise and other
+      ! functions (BIJK-prefixes).
+      !
+
+      PROGRAM MAIN
+      IMPLICIT NONE
+
+      INTEGER*1 :: AB = 9_1, BB = 3_1, CB
+      INTEGER*2 :: AI = 9_2, BI = 3_2, CI
+      INTEGER*4 :: AJ = 9_4, BJ = 3_4, CJ
+      INTEGER*8 :: AK = 9_8, BK = 3_8, CK
+      INTEGER   :: A  = 9  , B  = 3  , C
+
+      CB = BIEOR(AB, BB)
+      CI = IIEOR(AI, BI)
+      CJ = JIEOR(AJ, BJ)
+      CK = KIEOR(AK, BK)
+      C  =  IEOR(A , B )
+
+      CB = BIEOR(9_1, 3_1)
+      CI = IIEOR(9_2, 3_2)
+      CJ = JIEOR(9_4, 3_4)
+      CK = KIEOR(9_8, 3_8)
+      C  =  IEOR(9  , 3  )
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bijk_ior.f b/gcc/testsuite/gfortran.dg/dec/bijk_ior.f
new file mode 100644
index 0000000..70e9a2b
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bijk_ior.f
@@ -0,0 +1,29 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-intrinsic-ints" }
+      !
+      ! Tests the extended integer formats on bitwise and other
+      ! functions (BIJK-prefixes).
+      !
+
+      PROGRAM MAIN
+      IMPLICIT NONE
+
+      INTEGER*1 :: AB = 9_1, BB = 3_1, CB
+      INTEGER*2 :: AI = 9_2, BI = 3_2, CI
+      INTEGER*4 :: AJ = 9_4, BJ = 3_4, CJ
+      INTEGER*8 :: AK = 9_8, BK = 3_8, CK
+      INTEGER   :: A  = 9  , B  = 3  , C
+
+      CB = BIOR(AB, BB)
+      CI = IIOR(AI, BI)
+      CJ = JIOR(AJ, BJ)
+      CK = KIOR(AK, BK)
+      C  =  IOR(A , B )
+
+      CB = BIOR(9_1, 3_1)
+      CI = IIOR(9_2, 3_2)
+      CJ = JIOR(9_4, 3_4)
+      CK = KIOR(9_8, 3_8)
+      C  =  IOR(9  , 3  )
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bijk_mod.f b/gcc/testsuite/gfortran.dg/dec/bijk_mod.f
new file mode 100644
index 0000000..6cf5822
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bijk_mod.f
@@ -0,0 +1,29 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-intrinsic-ints" }
+      !
+      ! Tests the extended integer formats on bitwise and other
+      ! functions (BIJK-prefixes).
+      !
+
+      PROGRAM MAIN
+      IMPLICIT NONE
+
+      INTEGER*1 :: AB = 9_1, BB = 3_1, CB
+      INTEGER*2 :: AI = 9_2, BI = 3_2, CI
+      INTEGER*4 :: AJ = 9_4, BJ = 3_4, CJ
+      INTEGER*8 :: AK = 9_8, BK = 3_8, CK
+      INTEGER   :: A  = 9  , B  = 3  , C
+
+      CB = BMOD(AB, BB)
+      CI = IMOD(AI, BI)
+      CJ = JMOD(AJ, BJ)
+      CK = KMOD(AK, BK)
+      C  =  MOD(A , B )
+
+      CB = BMOD(9_1, 3_1)
+      CI = IMOD(9_2, 3_2)
+      CJ = JMOD(9_4, 3_4)
+      CK = KMOD(9_8, 3_8)
+      C  =  MOD(9  , 3  )
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_and1.f b/gcc/testsuite/gfortran.dg/dec/bits_and1.f
new file mode 100644
index 0000000..eb184ae
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_and1.f
@@ -0,0 +1,29 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*1 A, B, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 3
+      B = 5
+      C = 1
+      
+      OP     = A .and. B
+      FUNC   = iand(A, B)
+      OP_C   = 3 .and. 5
+      FUNC_C = iand(3, 5)
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ",  C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_and2.f b/gcc/testsuite/gfortran.dg/dec/bits_and2.f
new file mode 100644
index 0000000..53205a2
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_and2.f
@@ -0,0 +1,29 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*2 A, B, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 3
+      B = 5
+      C = 1
+      
+      OP     = A .and. B
+      FUNC   = iand(A, B)
+      OP_C   = 3 .and. 5
+      FUNC_C = iand(3, 5)
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ",  C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_and4.f b/gcc/testsuite/gfortran.dg/dec/bits_and4.f
new file mode 100644
index 0000000..968f85a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_and4.f
@@ -0,0 +1,29 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*4 A, B, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 3
+      B = 5
+      C = 1
+      
+      OP     = A .and. B
+      FUNC   = iand(A, B)
+      OP_C   = 3 .and. 5
+      FUNC_C = iand(3, 5)
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ",  C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_and8.f b/gcc/testsuite/gfortran.dg/dec/bits_and8.f
new file mode 100644
index 0000000..c5b9383
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_and8.f
@@ -0,0 +1,29 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*8 A, B, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 3
+      B = 5
+      C = 1
+      
+      OP     = A .and. B
+      FUNC   = iand(A, B)
+      OP_C   = 3 .and. 5
+      FUNC_C = iand(3, 5)
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ",  C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_eqv1.f b/gcc/testsuite/gfortran.dg/dec/bits_eqv1.f
new file mode 100644
index 0000000..0e271f7
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_eqv1.f
@@ -0,0 +1,29 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*1 A, B, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 3
+      B = 5
+      C = -7
+      
+      OP     = A .eqv. B
+      FUNC   = not(ieor(A, B))
+      OP_C   = 3 .eqv. 5
+      FUNC_C = not(ieor(3, 5))
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ",  C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_eqv2.f b/gcc/testsuite/gfortran.dg/dec/bits_eqv2.f
new file mode 100644
index 0000000..fc30234
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_eqv2.f
@@ -0,0 +1,29 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*2 A, B, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 3
+      B = 5
+      C = -7
+      
+      OP     = A .eqv. B
+      FUNC   = not(ieor(A, B))
+      OP_C   = 3 .eqv. 5
+      FUNC_C = not(ieor(3, 5))
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ",  C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_eqv4.f b/gcc/testsuite/gfortran.dg/dec/bits_eqv4.f
new file mode 100644
index 0000000..76802b8
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_eqv4.f
@@ -0,0 +1,29 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*4 A, B, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 3
+      B = 5
+      C = -7
+      
+      OP     = A .eqv. B
+      FUNC   = not(ieor(A, B))
+      OP_C   = 3 .eqv. 5
+      FUNC_C = not(ieor(3, 5))
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ",  C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_eqv8.f b/gcc/testsuite/gfortran.dg/dec/bits_eqv8.f
new file mode 100644
index 0000000..f9804cb
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_eqv8.f
@@ -0,0 +1,29 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*8 A, B, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 3
+      B = 5
+      C = -7
+      
+      OP     = A .eqv. B
+      FUNC   = not(ieor(A, B))
+      OP_C   = 3 .eqv. 5
+      FUNC_C = not(ieor(3, 5))
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ",  C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_neqv1.f b/gcc/testsuite/gfortran.dg/dec/bits_neqv1.f
new file mode 100644
index 0000000..9463ad3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_neqv1.f
@@ -0,0 +1,29 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*1 A, B, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 3
+      B = 5
+      C = 6
+      
+      OP     = A .neqv. B
+      FUNC   = ieor(A, B)
+      OP_C   = 3 .neqv. 5
+      FUNC_C = ieor(3, 5)
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ",  C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_neqv2.f b/gcc/testsuite/gfortran.dg/dec/bits_neqv2.f
new file mode 100644
index 0000000..cc0dca4
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_neqv2.f
@@ -0,0 +1,29 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*2 A, B, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 3
+      B = 5
+      C = 6
+      
+      OP     = A .neqv. B
+      FUNC   = ieor(A, B)
+      OP_C   = 3 .neqv. 5
+      FUNC_C = ieor(3, 5)
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ",  C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_neqv4.f b/gcc/testsuite/gfortran.dg/dec/bits_neqv4.f
new file mode 100644
index 0000000..e5eb3a7
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_neqv4.f
@@ -0,0 +1,29 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*4 A, B, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 3
+      B = 5
+      C = 6
+      
+      OP     = A .neqv. B
+      FUNC   = ieor(A, B)
+      OP_C   = 3 .neqv. 5
+      FUNC_C = ieor(3, 5)
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ",  C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_neqv8.f b/gcc/testsuite/gfortran.dg/dec/bits_neqv8.f
new file mode 100644
index 0000000..1878e99
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_neqv8.f
@@ -0,0 +1,29 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*8 A, B, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 3
+      B = 5
+      C = 6
+      
+      OP     = A .neqv. B
+      FUNC   = ieor(A, B)
+      OP_C   = 3 .neqv. 5
+      FUNC_C = ieor(3, 5)
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ",  C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_not1.f b/gcc/testsuite/gfortran.dg/dec/bits_not1.f
new file mode 100644
index 0000000..4bd46a7
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_not1.f
@@ -0,0 +1,28 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*1 A, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 4
+      C = -5
+      
+      OP     = .not. A
+      FUNC   = not(A)
+      OP_C   = .not. 4
+      FUNC_C = not(4)
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ", C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_not2.f b/gcc/testsuite/gfortran.dg/dec/bits_not2.f
new file mode 100644
index 0000000..11926d2
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_not2.f
@@ -0,0 +1,28 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*2 A, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 4
+      C = -5
+      
+      OP     = .not. A
+      FUNC   = not(A)
+      OP_C   = .not. 4
+      FUNC_C = not(4)
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ", C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_not4.f b/gcc/testsuite/gfortran.dg/dec/bits_not4.f
new file mode 100644
index 0000000..13dc874
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_not4.f
@@ -0,0 +1,28 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*4 A, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 4
+      C = -5
+      
+      OP     = .not. A
+      FUNC   = not(A)
+      OP_C   = .not. 4
+      FUNC_C = not(4)
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ", C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_not8.f b/gcc/testsuite/gfortran.dg/dec/bits_not8.f
new file mode 100644
index 0000000..6b498d8
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_not8.f
@@ -0,0 +1,28 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*8 A, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 4
+      C = -5
+      
+      OP     = .not. A
+      FUNC   = not(A)
+      OP_C   = .not. 4
+      FUNC_C = not(4)
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ", C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_or1.f b/gcc/testsuite/gfortran.dg/dec/bits_or1.f
new file mode 100644
index 0000000..83011c0
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_or1.f
@@ -0,0 +1,29 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*1 A, B, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 3
+      B = 5
+      C = 7
+      
+      OP     = A .or. B
+      FUNC   = ior(A, B)
+      OP_C   = 3 .or. 5
+      FUNC_C = ior(3, 5)
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ",  C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_or2.f b/gcc/testsuite/gfortran.dg/dec/bits_or2.f
new file mode 100644
index 0000000..027f570
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_or2.f
@@ -0,0 +1,29 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*2 A, B, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 3
+      B = 5
+      C = 7
+      
+      OP     = A .or. B
+      FUNC   = ior(A, B)
+      OP_C   = 3 .or. 5
+      FUNC_C = ior(3, 5)
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ",  C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_or4.f b/gcc/testsuite/gfortran.dg/dec/bits_or4.f
new file mode 100644
index 0000000..01966c0
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_or4.f
@@ -0,0 +1,29 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*4 A, B, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 3
+      B = 5
+      C = 7
+      
+      OP     = A .or. B
+      FUNC   = ior(A, B)
+      OP_C   = 3 .or. 5
+      FUNC_C = ior(3, 5)
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ",  C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/bits_or8.f b/gcc/testsuite/gfortran.dg/dec/bits_or8.f
new file mode 100644
index 0000000..66feb6a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/bits_or8.f
@@ -0,0 +1,29 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-bitwise-ops" }
+      !
+      ! Test the use of logical operators as bitwise operators when they
+      ! have integer arguments.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*8 A, B, OP, FUNC, OP_C, FUNC_C, C
+
+      A = 3
+      B = 5
+      C = 7
+      
+      OP     = A .or. B
+      FUNC   = ior(A, B)
+      OP_C   = 3 .or. 5
+      FUNC_C = ior(3, 5)
+
+      IF (OP .NE. C .OR. OP .NE.FUNC .OR. 
+     &    OP_C .NE. FUNC_C .OR. OP .NE. OP_C) THEN
+        PRINT *, "FAIL!!!! exp: ",  C
+        PRINT *, "         op: ",   OP,   " func: ",   FUNC,
+     &           "         op_c: ", OP_C, " func_c: ", FUNC_C
+        call abort
+      ENDIF
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/buffer.inc b/gcc/testsuite/gfortran.dg/dec/buffer.inc
new file mode 100644
index 0000000..7a128c4
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/buffer.inc
@@ -0,0 +1,40 @@
+	STRUCTURE /BUFFER/
+	UNION
+	 MAP
+	  byte		bbuf(L_bbuf)
+	 END MAP
+	 MAP
+	  character*8	abuf(L_bbuf/8)
+	 END MAP
+	 MAP
+	  integer*2	ibuf(L_bbuf/2)
+	 END MAP
+	 MAP
+	  integer*4	lbuf(L_bbuf/4)
+	 END MAP
+	 MAP
+	  real*4	fbuf(L_bbuf/4)
+	 END MAP
+!if !_PFC
+	 MAP
+	  integer*8	xbuf(L_bbuf/8)
+	 END MAP
+!endif
+	 MAP
+	  real*8	dbuf(L_bbuf/8)
+	 END MAP
+	 MAP
+	  complex*8	cfbuf(L_bbuf/8)
+	 END MAP
+	 MAP
+	  complex*16	cdbuf(L_bbuf/16)
+	 END MAP
+	 MAP
+!if _CNVX
+!
+!else
+	  character*(L_bbuf)  sbuf		! Sun/OSF/SOL/IRIX Fortran
+!endif
+	 END MAP
+	END UNION
+	END STRUCTURE
diff --git a/gcc/testsuite/gfortran.dg/dec/check.inc b/gcc/testsuite/gfortran.dg/dec/check.inc
new file mode 100644
index 0000000..b418369
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/check.inc
@@ -0,0 +1,24 @@
+      BF = f_eqt(F_OE, F_OA, F_TOL)
+      CF = f_eqt(F_OE, F_OC, F_TOL)
+      BD = d_eqt(D_OE, D_OA, D_TOL)
+      CD = d_eqt(D_OE, D_OC, D_TOL)
+      !BQ = q_eqt(Q_OE, Q_OA, Q_TOL)
+      !CQ = q_eqt(Q_OE, Q_OC, Q_TOL)
+
+      WRITE (E, '(F10.6)') F_OE
+      WRITE (A, '(F10.6)') F_OA
+      call fail_on_false(BF, "F ", E, A)
+      WRITE (A, '(F10.6)') F_OC
+      call fail_on_false(CF, "CF", E, A)
+
+      WRITE (E, '(F10.6)') D_OE
+      WRITE (A, '(F10.6)') D_OA
+      call fail_on_false(BD, "D ", E, A)
+      WRITE (A, '(F10.6)') D_OC
+      call fail_on_false(CD, "CD", E, A)
+
+      !WRITE (E, '(F10.6)') Q_OE
+      !WRITE (A, '(F10.6)') Q_OA
+      !call fail_on_false(BQ, "Q ", E, A)
+      !WRITE (A, '(F10.6)') Q_OC
+      !call fail_on_false(CQ, "CQ", E, A)
diff --git a/gcc/testsuite/gfortran.dg/dec/checkf.inc b/gcc/testsuite/gfortran.dg/dec/checkf.inc
new file mode 100644
index 0000000..544b318
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/checkf.inc
@@ -0,0 +1,19 @@
+      SUBROUTINE fail_on_true(bool, msg, e, a)
+        IMPLICIT NONE
+        LOGICAL, INTENT (IN) :: bool
+        CHARACTER(*), INTENT (IN) :: msg, e, a
+        if ( bool ) then
+          print *, msg, "FAIL!!!! exp: ", e, " act: ", a
+          call abort
+        endif
+      END
+
+      SUBROUTINE fail_on_false(bool, msg, e, a)
+        IMPLICIT NONE
+        LOGICAL, INTENT (IN) :: bool
+        CHARACTER(*), INTENT (IN) :: msg, e, a
+        if ( .not. bool ) then
+          print *, "(", msg, ") FAIL!!!! exp: ", e, " act: ", a
+          call abort
+        endif
+      END
diff --git a/gcc/testsuite/gfortran.dg/dec/cos.f b/gcc/testsuite/gfortran.dg/dec/cos.f
new file mode 100644
index 0000000..dbb3f81
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/cos.f
@@ -0,0 +1,30 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-math" }
+      !
+      include 'eqt.inc'
+      include 'checkf.inc'
+
+      PROGRAM MAIN
+      include 'decl.inc'
+
+      ! Input
+      F_I = 1.0471975512_4
+      D_I = 1.0471975512_8
+      !Q_I = 1.0471975512_16
+
+      ! Expected
+      F_OE = 0.5_4
+      D_OE = 0.5_8
+      !Q_OE = 0.5_16
+
+      ! Actual
+      F_OA =  COS (F_I)
+      F_OC =  COS (1.0471975512_4)
+      D_OA = DCOS (D_I)
+      D_OC = DCOS (1.0471975512_8)
+      !Q_OA = QCOS (Q_I)
+      !Q_OC = QCOS (1.0471975512_16)
+
+      include 'check.inc'
+
+      END PROGRAM MAIN
diff --git a/gcc/testsuite/gfortran.dg/dec/cosd.f b/gcc/testsuite/gfortran.dg/dec/cosd.f
new file mode 100644
index 0000000..d7bded5
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/cosd.f
@@ -0,0 +1,30 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-math" }
+      !
+      include 'eqt.inc'
+      include 'checkf.inc'
+
+      PROGRAM MAIN
+      include 'decl.inc'
+
+      ! Input
+      F_I = 60.0_4
+      D_I = 60.0_8
+      !Q_I = 60.0_16
+
+      ! Expected
+      F_OE = 0.5_4
+      D_OE = 0.5_8
+      !Q_OE = 0.5_16
+
+      ! Actual
+      F_OA =  COSD (F_I)
+      F_OC =  COSD (60.0_4)
+      D_OA = DCOSD (D_I)
+      D_OC = DCOSD (60.0_8)
+      !Q_OA = QCOSD (Q_I)
+      !Q_OC = QCOSD (60.0_16)
+
+      include 'check.inc'
+
+      END PROGRAM MAIN
diff --git a/gcc/testsuite/gfortran.dg/dec/cotan.f b/gcc/testsuite/gfortran.dg/dec/cotan.f
new file mode 100644
index 0000000..e2ace4a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/cotan.f
@@ -0,0 +1,30 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-math" }
+      !
+      include 'eqt.inc'
+      include 'checkf.inc'
+
+      PROGRAM MAIN
+      include 'decl.inc'
+
+      ! Input
+      F_I = 0.6_4
+      D_I = 0.6_8
+      !Q_I = 0.6_16
+
+      ! Expected
+      F_OE = 1.46169594708_4
+      D_OE = 1.46169594708_8
+      !Q_OE = 1.46169594708_16
+
+      ! Actual
+      F_OA =  COTAN (F_I)
+      F_OC =  COTAN (0.6_4)
+      D_OA = DCOTAN (D_I)
+      D_OC = DCOTAN (0.6_8)
+      !Q_OA = QCOTAN (Q_I)
+      !Q_OC = QCOTAN (0.6_16)
+
+      include 'check.inc'
+
+      END PROGRAM MAIN
diff --git a/gcc/testsuite/gfortran.dg/dec/cotand.f b/gcc/testsuite/gfortran.dg/dec/cotand.f
new file mode 100644
index 0000000..d1824cc
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/cotand.f
@@ -0,0 +1,32 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-math" }
+      !
+      include 'eqt.inc'
+      include 'checkf.inc'
+
+      PROGRAM MAIN
+      include 'decl.inc'
+
+      F_TOL = 5e-5_4
+
+      ! Input
+      F_I = 0.6_4
+      D_I = 0.6_8
+      !Q_I = 0.6_16
+
+      ! Expected
+      F_OE = 95.4894751711_4
+      D_OE = 95.4894751711_8
+      !Q_OE = 95.4894751711_16
+
+      ! Actual
+      F_OA =  COTAND (F_I)
+      F_OC =  COTAND (0.6_4)
+      D_OA = DCOTAND (D_I)
+      D_OC = DCOTAND (0.6_8)
+      !Q_OA = QCOTAND (Q_I)
+      !Q_OC = QCOTAND (0.6_16)
+
+      include 'check.inc'
+
+      END PROGRAM MAIN
diff --git a/gcc/testsuite/gfortran.dg/dec/cray_assumed.f b/gcc/testsuite/gfortran.dg/dec/cray_assumed.f
new file mode 100644
index 0000000..cffd04a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/cray_assumed.f
@@ -0,0 +1,15 @@
+      ! { dg-do compile }
+      ! { dg-options "-fcray-pointer" }
+      !
+      ! Allow assumed-size arrays which are derived-type Cray pointees.
+      !
+      program main
+
+      type test
+        integer*4 i
+      end type
+
+      type (test) y(*)
+      pointer (y_ptr, y)
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/decl.inc b/gcc/testsuite/gfortran.dg/dec/decl.inc
new file mode 100644
index 0000000..7989896
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/decl.inc
@@ -0,0 +1,14 @@
+      IMPLICIT NONE
+
+      LOGICAL f_eqt, d_eqt!, q_eqt
+      LOGICAL BF, CF, BD, CD!, BQ, CQ
+      CHARACTER*12 E, A
+
+      ! in,   out expected,   out actual,   out from constant input
+      REAL*4  F_I, F_OE, F_OA, F_OC, F_TOL
+      REAL*8  D_I, D_OE, D_OA, D_OC, D_TOL
+      !REAL*16 Q_I, Q_OE, Q_OA, Q_OC, Q_TOL
+
+      F_TOL = 5e-6_4
+      D_TOL = 5e-6_8
+      !Q_TOL = 5e-6_16
diff --git a/gcc/testsuite/gfortran.dg/dec/dlines.f b/gcc/testsuite/gfortran.dg/dec/dlines.f
new file mode 100644
index 0000000..4134130
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dlines.f
@@ -0,0 +1,18 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec" }
+      !
+      ! Test the recognition of debug lines as comments with -fdec.
+      !
+      program main
+
+      character*32 a, b
+
+      a = "debug lines"
+      b = "are comments"
+
+D     a = "no comments"
+D     b = "for these debug lines"
+
+      print *, a, b
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/dot1.f b/gcc/testsuite/gfortran.dg/dec/dot1.f
new file mode 100644
index 0000000..5094c2c
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot1.f
@@ -0,0 +1,19 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-member-dot" }
+      !
+      ! This should compile with -fdec-member-dot.
+      ! This tests to make sure operators beginning with '.' are not interpreted
+      ! as structure member accesses.
+      !
+      ! No output expected here.
+        program main
+
+        LOGICAL x, y, z
+        x = .TRUE.
+        y = .FALSE.
+        z = .FALSE.
+
+        if ( x .AND. y .OR. z ) then
+        endif
+
+        end program
diff --git a/gcc/testsuite/gfortran.dg/dec/dot10.f b/gcc/testsuite/gfortran.dg/dec/dot10.f
new file mode 100644
index 0000000..0f2b25a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot10.f
@@ -0,0 +1,40 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-member-dot" }
+      !
+      ! This should compile with -fdec-member-dot.
+      !
+      ! Tests whether integer literals as operands inhibit recognizing '.' as
+      ! a member separator. 
+      !
+      ! Output should be "pass".
+      PROGRAM MAIN
+      TYPE t
+          INTEGER :: i
+          INTEGER :: j
+      END TYPE
+
+      INTEGER :: tmp1 = 0
+      INTEGER :: tmp2 = 1
+      TYPE (t) tmp3
+      tmp3.i = 0
+      tmp3.j = 1
+
+      if     ( .not. (tmp1.eq.0)   ) then
+          print *, "FAIL!!!! 0"
+          call abort
+
+      elseif ( .not. (1.eq.tmp2)   ) then
+          print *, "FAIL!!!! 1"
+          call abort
+
+      elseif ( .not. (tmp3.i.eq.0) ) then
+          print *, "FAIL!!!! ->0"
+          call abort
+
+      elseif ( .not. (1.eq.tmp3.j) ) then
+          print *, "FAIL!!!! ->1"
+          call abort
+
+      endif
+
+      END PROGRAM MAIN
diff --git a/gcc/testsuite/gfortran.dg/dec/dot11.f b/gcc/testsuite/gfortran.dg/dec/dot11.f
new file mode 100644
index 0000000..248f818
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot11.f
@@ -0,0 +1,40 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-member-dot" }
+      !
+      ! This should compile with -fdec-member-dot.
+      !
+      ! Tests whether string literals as operands inhibit recognizing '.' as
+      ! a member separator. 
+      !
+      ! Output should be "pass".
+      PROGRAM MAIN
+      TYPE t
+          CHARACTER*20 :: a
+          CHARACTER*20 :: b
+      END TYPE
+
+      CHARACTER*20 :: tmp1 = "HELLO"
+      CHARACTER*20 :: tmp2 = "GOODBYE"
+      TYPE (t) tmp3
+      tmp3.a = "HELLO"
+      tmp3.b = "GOODBYE"
+
+      if     ( .not. (tmp1.eq."HELLO")   ) then
+          print *, "FAIL!!!! Hello"
+          call abort
+
+      elseif ( .not. ("GOODBYE".eq.tmp2)   ) then
+          print *, "FAIL!!!! Goodbye"
+          call abort
+
+      elseif ( .not. (tmp3.a.eq."HELLO") ) then
+          print *, "FAIL!!!! ->Hello"
+          call abort
+
+      elseif ( .not. ("GOODBYE".eq.tmp3.b) ) then
+          print *, "FAIL!!!! ->Goodbye"
+          call abort
+
+      endif
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/dot12.f b/gcc/testsuite/gfortran.dg/dec/dot12.f
new file mode 100644
index 0000000..395fc14
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot12.f
@@ -0,0 +1,31 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-member-dot" }
+      !
+      ! This should compile with -fdec-member-dot.
+      ! This tests the precedence between member accesses and intrinsic
+      ! operators.
+      !
+      ! "x.and.y" should be interpreted as the nested access
+      ! (x->and)->y rather than the logical operation and(x,y). The result
+      ! should be OR'd with z. 
+      !
+      ! The output is unimportant; if the precedence described above is not
+      ! recognized, the program will fail to compile.
+      program main
+
+      TYPE bob
+          LOGICAL y
+      END TYPE
+
+      TYPE item
+          LOGICAL b
+          TYPE(bob) and
+      END TYPE
+
+      TYPE(item) x, y
+      LOGICAL z
+
+      if ( x .AND. y .OR. z ) then
+      endif
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/dot13.f b/gcc/testsuite/gfortran.dg/dec/dot13.f
new file mode 100644
index 0000000..4642871
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot13.f
@@ -0,0 +1,47 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-member-dot" }
+      !
+      ! This is a horrible example of how twisted Fortran is:
+      ! "X.AND.AND.AND.AND" resolves to (X.AND.AND) .AND. (AND)
+      ! because ".AND." is defined to take (LOGICAL, T) parameters 
+      ! where "X.AND.AND" is type LOGICAL and "AND" is type T.
+      ! Without the knowledge of the type of parameters expected by the
+      ! user-defined ".AND.", this would be completely ambiguous.
+      module mod
+
+      TYPE t
+          logical and
+      END TYPE
+        
+      interface operator (.and.)
+          module procedure a
+      end interface operator (.and.)
+
+      contains
+
+      function a(x, y)
+          type(t), intent (in) :: x
+          logical, intent (in) :: y
+          logical a
+          print *, "called and"
+          a = (.not. x%and) .and. (.not. y)
+          return
+      end function a
+
+      end module mod
+
+      use mod
+
+      TYPE(t) :: x
+      LOGICAL  :: and
+      LOGICAL :: i
+      x.and = .true.
+      and   = .true.
+
+      i = x.and.and ! MUHAHAHAH this makes ifort (11.1) segfault!!!!
+
+      if ( i ) then ! (x->and) .AND. (z)
+          print *, .true.
+      endif
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/dot2.f b/gcc/testsuite/gfortran.dg/dec/dot2.f
new file mode 100644
index 0000000..8f02f41
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot2.f
@@ -0,0 +1,9 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-member-dot" }
+      !
+      ! Make sure logical names aren't interpreted as member accesses.
+      !
+      PROGRAM MAIN
+      LOGICAL :: AND
+      AND = AND.AND.AND.AND.AND
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/dot3.f b/gcc/testsuite/gfortran.dg/dec/dot3.f
new file mode 100644
index 0000000..a29b162
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot3.f
@@ -0,0 +1,47 @@
+! { dg-do run }
+! { dg-options "-fdec-member-dot" }
+!
+! This should compile with -fdec-member-dot.
+! This tests the precedence between member accesses and intrinsic
+! operators.
+!
+! The first expression t2.eq.i should be evaluated as (t2->eq)->i
+! and return 0. The second expression (t2).eq.i should be evaluated
+! as the operation eq(t2,i) and call eq_func resulting in -10.
+       include 'assert.inc'
+       module mod
+       type T1_t
+           integer :: i
+       end type T1_t
+       type T2_t
+           type (T1_t) :: eq
+           integer :: i
+       end type T2_t
+        
+       interface operator (.eq.)
+           module procedure eq_func
+       end interface operator (.eq.)
+
+       contains
+
+       function eq_func(t2, i) result (rslt)
+           type(T2_t), intent (in) :: t2
+           integer, intent (in) :: i
+           rslt = t2%eq%i + i
+       end function eq_func
+
+       end module mod
+
+       use mod
+
+       type(T2_t) :: t2
+       integer :: i,j
+       t2%eq%i = 2
+       t2%i = -10
+       i = -10
+       j = t2 . eq . i    ! t2->eq->i
+       call assertll ("t2.eq.i", j, 2)
+       j = (t2) . eq . i  ! eq_func(t2, i)
+       call assertll ("(t2).eq.i", j, -8)
+       
+       end program
diff --git a/gcc/testsuite/gfortran.dg/dec/dot4.f b/gcc/testsuite/gfortran.dg/dec/dot4.f
new file mode 100644
index 0000000..2900565
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot4.f
@@ -0,0 +1,17 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-member-dot" }
+      !
+      ! This should compile with -fdec-member-dot.
+      ! Test to make sure initializers and operators beginning with '.'
+      ! are not interpreted as structure member accesses.
+      ! Output should be "T T", and this should compile with -fdec-member-dot.
+      include 'assert.inc'
+      program main
+      implicit none
+
+      logical :: b = .TRUE.
+      logical :: c = .TRUE.
+      call assert ("b.eqv.c", b.eqv.c)
+      call assert ("(b).eqv.c", (b).eqv.c)
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/dot5.f b/gcc/testsuite/gfortran.dg/dec/dot5.f
new file mode 100644
index 0000000..4297909
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot5.f
@@ -0,0 +1,41 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-member-dot" }
+      !
+      ! This should compile with -fdec-member-dot.
+      ! This tests the precedence between member accesses and intrinsic
+      ! operators.
+      !
+      ! This is similar to dot-3, but t2 has no member 'eq' so t2.eq.i
+      ! should always be interpreted as eq(t2,i).
+      include 'assert.inc'
+      module mod
+       type T2_t
+           integer :: i
+       end type T2_t
+        
+       interface operator (.eq.)
+           module procedure eq_func
+       end interface operator (.eq.)
+
+       contains
+
+       function eq_func(t2, i) result (rslt)
+           type(T2_t), intent (in) :: t2
+           integer, intent (in) :: i
+           rslt = t2%i + i
+       end function eq_func
+
+       end module mod
+
+       use mod
+
+       type(T2_t) :: t2
+       integer :: i,j
+       i = 0
+       t2%i = -10
+       j = t2.eq.i    ! eq_func(t2, i)
+       call assertll ("t2.eq.i", j, -10)
+       j = (t2).eq.i  ! eq_func(t2, i)
+       call assertll ("(t2).eq.i", j, -10)
+
+       end program
diff --git a/gcc/testsuite/gfortran.dg/dec/dot6.f b/gcc/testsuite/gfortran.dg/dec/dot6.f
new file mode 100644
index 0000000..28ebb26
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot6.f
@@ -0,0 +1,71 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-member-dot" }
+      !
+      ! This should compile with -fdec-member-dot.
+      ! This tests the precedence between member accesses, intrinsic
+      ! operators, and user-defined operators.
+      !
+      ! (1) t2.eq.i     should be the member access (t2->eq)->i
+      ! (2) (t2).eq.i   should be the operation eq(t2, i)
+      ! (3) t2.test.i   is the operation test(t2, i) (because Intel does that)
+      ! (4) (t2).test.i is still the operation test(t2, i) (ditto)
+      !
+      ! The output should be:
+      ! 1
+      ! 5
+      ! 6
+      ! 6
+      include 'assert.inc'
+      module mod
+      type T1_t
+          integer :: i
+      end type T1_t
+      type T2_t
+          integer :: i
+          type (T1_t) :: eq
+          type (T1_t) :: test
+      end type T2_t
+       
+      interface operator (.eq.)
+          module procedure eq_func
+      end interface operator (.eq.)
+
+      interface operator (.test.)
+          module procedure tstfunc
+      end interface operator (.test.)
+
+      contains
+
+      function eq_func(t2, i)
+          type(T2_t), intent (in) :: t2
+          integer, intent (in) :: i
+          integer eq_func
+          eq_func = t2%eq%i + i
+          return
+      end function eq_func
+
+      function tstfunc(t1, i)
+          type(T2_t), intent (in) :: t1
+          integer, intent (in) :: i
+          integer tstfunc
+          tstfunc = t1%i + i
+          return
+      end function tstfunc
+
+      end module mod
+
+      use mod
+
+      type(T2_t) :: t2
+      integer :: i
+      t2%eq%i = 1
+      t2%i = 2
+      t2%test%i = 3
+      i = 4
+
+      call assertll ("t2.eq.i",      t2  .eq. i, 1) ! (1) t2->eq->i = 1
+      call assertll ("(t2).eq.i",   (t2) .eq. i, 5) ! (2) eq_func(t2,i) = 5
+      call assertll ("t2.test.i",    t2 .test.i, 6) ! (3) tstfunc(t2,i) = 6
+      call assertll ("(t2).test.i", (t2).test.i, 6) ! (4) tstfunc(t2,i) = 6
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/dot7.f b/gcc/testsuite/gfortran.dg/dec/dot7.f
new file mode 100644
index 0000000..8ef658c
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot7.f
@@ -0,0 +1,52 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-member-dot" }
+      !
+      ! This should compile with and without -fdec-member-dot.
+      ! This tests the precedence between member accesses and intrinsic
+      ! operators.
+      !
+      ! This is similar to dot-3, but the member 'eq' is not a derived type
+      ! variable so t2.eq.* should always evaluate to the operation eq(t2,*).
+      !
+      ! The output should be:
+      ! 5
+      ! 5
+
+      include 'assert.inc'
+      module mod
+      type T1_t
+          integer :: i
+      end type T1_t
+      type T2_t
+          integer :: i
+          integer :: eq
+      end type T2_t
+       
+      interface operator (.eq.)
+          module procedure eq_func
+      end interface operator (.eq.)
+
+      contains
+
+      function eq_func(t2, i)
+          type(T2_t), intent (in) :: t2
+          integer, intent (in) :: i
+          integer eq_func
+          eq_func = t2%eq + i
+          return
+      end function eq_func
+
+      end module mod
+
+      use mod
+
+      type(T2_t) :: t2
+      integer :: i
+      t2%eq = 1
+      t2%i = 2
+      i = 4
+
+      call assertll ("t2.eq.i",    t2 .eq.i, 5) ! eq_func(t2,i) = 5
+      call assertll ("(t2).eq.i", (t2).eq.i, 5) ! eq_func(t2,i) = 5
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/dot8.f b/gcc/testsuite/gfortran.dg/dec/dot8.f
new file mode 100644
index 0000000..5efcd01
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot8.f
@@ -0,0 +1,46 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-member-dot" }
+      !
+      ! This should compile with -fdec-member-dot.
+      ! This tests nested member accesses without dots.
+      ! The output should be '1'.
+
+      include 'assert.inc'
+      program main
+
+      type tg
+          integer i
+      end type
+
+      type tf
+          type(tg) g
+      end type
+
+      type te
+          type(tf) f
+      end type
+
+      type td
+          type(te) e
+      end type
+
+      TYPE tc
+          type(td) d
+      end type
+
+      TYPE tb
+          type(tc) c
+      END TYPE
+
+      TYPE ta
+          TYPE(tb) b
+      END TYPE
+
+      TYPE(ta) a
+
+      integer i
+      a%b%c%d%e%f%g%i = 1
+      i = a%b%c%d%e%f%g%i
+      call assertll ("a%b%c%d%e%f%g%i", i, 1)
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/dot9.f b/gcc/testsuite/gfortran.dg/dec/dot9.f
new file mode 100644
index 0000000..40ffe53
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot9.f
@@ -0,0 +1,47 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-member-dot" }
+      !
+      ! This should compile with -fdec-member-dot.
+      ! This tests nested member accesses with dots.
+      ! The output should be '1'.
+
+      include 'assert.inc'
+      program main
+
+      type tg
+          integer i
+      end type
+
+      type tf
+          type(tg) g
+      end type
+
+      type te
+          type(tf) f
+      end type
+
+      type td
+          type(te) e
+      end type
+
+      TYPE tc
+          type(td) d
+      end type
+
+      TYPE tb
+          type(tc) c
+      END TYPE
+
+      TYPE ta
+          TYPE(tb) b
+      END TYPE
+
+      TYPE(ta) a
+
+      integer i
+      a.b.c.d.e.f.g.i = 1
+      i = a.b.c.d.e.f.g.i
+
+      call assertll ("a.b.c.d.e.f.g.i", i, 1)
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/dot_bad1.f b/gcc/testsuite/gfortran.dg/dec/dot_bad1.f
new file mode 100644
index 0000000..35f7d7e
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot_bad1.f
@@ -0,0 +1,28 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-member-dot" }
+      !
+      ! This should NOT compile with -fdec-member-dot.
+      ! This tests the precedence between member accesses and intrinsic
+      ! operators.
+      !
+      ! Since the member 'eq' is not a derived type variable, the compiler
+      ! should attempt to use the intrinsic operator 'eq', even though it is
+      ! not applicable to t2.
+      program main
+      type T1_t
+          integer :: i
+      end type T1_t
+      type T2_t
+          integer :: i
+          integer :: eq
+      end type T2_t
+       
+      type(T2_t) :: t2
+      integer :: i
+      t2%eq = 1
+      t2%i = 2
+      i = 4
+      print *,  t2.eq.i    ! { dg-error "Operands of comparison" }
+      print *, (t2).eq.i   ! { dg-error "Operands of comparison" }
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/dot_bad2.f b/gcc/testsuite/gfortran.dg/dec/dot_bad2.f
new file mode 100644
index 0000000..9e37600
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot_bad2.f
@@ -0,0 +1,11 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-member-dot" }
+      !
+      ! This should NOT compile with or without -fdec-member-dot.
+      ! This tests the error message given for invalid member accesses.
+      program main
+
+      integer i,j,k
+      k = i.j ! { dg-error "Unclassifiable statement" }
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/dot_bad3.f b/gcc/testsuite/gfortran.dg/dec/dot_bad3.f
new file mode 100644
index 0000000..1172fcd
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot_bad3.f
@@ -0,0 +1,10 @@
+      ! { dg-do compile }
+      !
+      ! This should NOT compile with or without -fdec-member-dot.
+      ! This tests the error message given for invalid member accesses.
+      program main
+
+      integer i,j,k
+      k = i.j ! { dg-error "Unclassifiable statement" }
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/dot_bad4.f b/gcc/testsuite/gfortran.dg/dec/dot_bad4.f
new file mode 100644
index 0000000..e998f6d
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot_bad4.f
@@ -0,0 +1,18 @@
+      ! { dg-do compile }
+      !
+      ! This test should NOT compile with or without -fdec-member-dot.
+      ! This tests the error message given for member accesses on valid
+      ! derived-type variables to a missing/invalid member.
+      program main
+
+      type t
+          integer y
+      end type
+
+      type (t) x
+      integer i,j,k,l
+
+      i = x%y
+      j = x%z ! { dg-error "is not a member of" }
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/dot_bad5.f b/gcc/testsuite/gfortran.dg/dec/dot_bad5.f
new file mode 100644
index 0000000..9df0916
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/dot_bad5.f
@@ -0,0 +1,20 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-member-dot" }
+      !
+      ! This test should NOT compile with or without -fdec-member-dot.
+      ! This tests the error message given for member accesses on valid
+      ! derived-type variables to a missing/invalid member.
+      ! This test is the same as dot-11 but with '.' instead of '%'.
+      program main
+
+      type t
+          integer y
+      end type
+
+      type (t) x
+      integer i,j,k,l
+
+      i = x.y
+      j = x.z ! { dg-error "is not a member of" }
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/eqt.inc b/gcc/testsuite/gfortran.dg/dec/eqt.inc
new file mode 100644
index 0000000..240186c
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/eqt.inc
@@ -0,0 +1,29 @@
+      LOGICAL*4 FUNCTION f_eqt(fe, fa, t)
+        IMPLICIT NONE
+        REAL*4, INTENT (IN) :: fe
+        REAL*4, INTENT (IN) :: fa
+        REAL*4, INTENT (IN) :: t
+        REAL*4 diff
+        diff = ABS(fa - fe)
+        f_eqt = diff .lt. t
+      END
+
+      LOGICAL*4 FUNCTION d_eqt(de, da, t)
+        IMPLICIT NONE
+        REAL*8, INTENT (IN) :: de
+        REAL*8, INTENT (IN) :: da
+        REAL*8, INTENT (IN) :: t
+        REAL*8 diff
+        diff = DABS(da - de)
+        d_eqt = diff .lt. t
+      END
+
+      !LOGICAL*4 FUNCTION q_eqt(qe, qa, t)
+      !  IMPLICIT NONE
+      !  REAL*16, INTENT (IN) :: qe
+      !  REAL*16, INTENT (IN) :: qa
+      !  REAL*16, INTENT (IN) :: t
+      !  REAL*16 diff
+      !  diff = QABS(qa - qe)
+      !  q_eqt = diff .lt. t
+      !END
diff --git a/gcc/testsuite/gfortran.dg/dec/exint_1.f b/gcc/testsuite/gfortran.dg/dec/exint_1.f
new file mode 100644
index 0000000..8267536
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/exint_1.f
@@ -0,0 +1,35 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-extended-int" }
+      !
+      ! Test the DEC extended integer format 'base#value' in several
+      ! contexts.
+      !
+
+      include 'assert.inc'
+      program main
+      implicit integer(a-z)
+      integer*3#11        :: H ! { dg-error "Old-style.*INTEGER.3" }
+      integer(kind=2#100) I    ! 100 base 2 => 4
+      integer(5#13)       J, K ! 13  base 5 => 8
+      I     = #3D + 2
+      J     = 16 # 3f
+      K     = 2 #  1000000 - 6   # 1 
+      L     = -(-4#3 + 5#231)
+      M     = '3F'X
+      N     = 36#1R
+      O     = (-1)#4        ! { dg-error "Unclassifiable statement" }
+      P     = 0#10          ! { dg-error ".0. out of range" }
+      Q     = 1#0000        ! { dg-error ".1. out of range" }
+      R     = 37#XYZ14      ! { dg-error ".37. out of range" }
+      S     = 10#123456789A ! { dg-error "Invalid digit .a." }
+      T     = 16#3hfba      ! { dg-error "Invalid digit .h." }
+      U     = 13#           ! { dg-error "Expected.*after .#." }
+      write (*,3#22) x'BEEF'! { dg-error "Syntax error" }
+3#22  format (z8)           ! { dg-error "character in" }
+      call assertll ("i", i,  63)
+      call assertqq ("j", j,  63_8) ! J should have kind 8
+      call assertqq ("k", k,  63_8) ! K should have kind 8
+      call assertll ("l", l, -63)
+      call assertll ("m", m,  63)
+      call assertll ("n", n,  63)
+      end program main
diff --git a/gcc/testsuite/gfortran.dg/dec/float_noe.f b/gcc/testsuite/gfortran.dg/dec/float_noe.f
new file mode 100644
index 0000000..c4c1cc5
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/float_noe.f
@@ -0,0 +1,21 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-io" }
+      !
+      ! Tests the extension to libgfortran which allows a floating point
+      ! number such as '1e' to be recognized as '1e0'.
+      !
+
+      program main
+      implicit none
+      real*4 d
+      character*20 :: tmp = "1e"
+
+      read (tmp,*,ERR=20) d
+      if (d == 1e0) then
+        write (*,'(a,g10.4)') "pass", d
+        stop
+      endif
+
+20    print *, "FAIL!!!!"
+      call abort
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/init_default.f b/gcc/testsuite/gfortran.dg/dec/init_default.f
new file mode 100644
index 0000000..6207177
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/init_default.f
@@ -0,0 +1,27 @@
+      ! { dg-do run }
+      ! { dg-options "-finit-local-zero -finit-derived" }
+      !
+      ! Test -finit-derived with a component with a default initialization.
+      !
+      include 'assert.inc'
+
+      PROGRAM MAIN 
+
+      TYPE REPORT
+        CHARACTER (LEN=20) REPORT_NAME
+        INTEGER DAY
+        CHARACTER (LEN=3) MONTH
+        INTEGER :: YEAR = 1995 ! Only component with default
+      END TYPE REPORT ! initialization
+
+      TYPE (REPORT) :: SEP_REPORT
+      TYPE (REPORT), PARAMETER :: NOV_REPORT = REPORT ("Sales", 15,
+     &                                                 "NOV", 1996)
+      SEP_REPORT%MONTH = "SEP"
+      SEP_REPORT%REPORT_NAME = "Sept sales"
+
+      call assertll ("sep_report%year", sep_report%year, 1995)
+      call assertll ("sep_report%day", sep_report%day, 0)
+      call assertll ("nov_report%year", nov_report%year, 1996)
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/init_derived.f b/gcc/testsuite/gfortran.dg/dec/init_derived.f
new file mode 100644
index 0000000..dcf1e69
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/init_derived.f
@@ -0,0 +1,48 @@
+      ! { dg-do run }
+      ! { dg-options "-finit-local-zero -finit-derived" }
+      !
+      ! Make sure -finit-derived initializes components of local derived type
+      ! variables.
+      !
+      include 'assert.inc'
+
+      function myfunc(i)
+          integer myfunc, i
+          TYPE item
+            INTEGER :: id ! = 0
+            INTEGER :: description  = 0
+            INTEGER :: noinit
+            REAL price
+          END TYPE
+
+          TYPE(item) pear
+          INTEGER x
+          pear%noinit = 0
+          if(i > 0) then
+              pear%id = i
+          endif
+          myfunc = x + i + pear%id
+      end function myfunc
+
+      program main
+      implicit none
+      TYPE item
+        INTEGER :: id ! = 0
+        INTEGER :: description  = 0
+        INTEGER :: noinit
+        REAL price
+      END TYPE
+
+      type(item) bob
+      integer :: i, j, myfunc
+
+      call assertll ("i", i, 0)
+      call assertll ("j", j, 0)
+      call assertll ("bob%id", bob%id, 0)
+      call assertll ("bob%description", bob%description, 0)
+      call assertll ("bob%noinit", bob%noinit, 0)
+      call assertll ("myfunc(0)", myfunc(0), 0)
+      call assertll ("myfunc(1)", myfunc(1), 2)
+      call assertll ("myfunc(0)", myfunc(0), 0)
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/init_old.f b/gcc/testsuite/gfortran.dg/dec/init_old.f
new file mode 100644
index 0000000..bd41477
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/init_old.f
@@ -0,0 +1,110 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-structure -fno-range-check" }
+      !
+      ! Test old-style initializations for structure components.
+      ! 
+      SUBROUTINE DUMP (X)
+      INTEGER,PARAMETER :: AS = 3
+      STRUCTURE /T/
+        CHARACTER*20 C
+        INTEGER*1 I
+        INTEGER*2 J
+        INTEGER   K
+        INTEGER*4 L
+        INTEGER   M(5)
+        INTEGER   N(5)
+        INTEGER   O(AS)
+        INTEGER   P(2,2)
+        REAL      Q(3)
+      END STRUCTURE
+      RECORD /T/ X
+
+      PRINT *, "C) ", X%C
+      PRINT *, "I) ", X%I
+      PRINT *, "J) ", X%J
+      PRINT *, "K) ", X%K
+      PRINT *, "L) ", X%L
+      PRINT *, "M) ", X%M
+      PRINT *, "N) ", X%N
+      PRINT *, "O) ", X%O
+      PRINT *, "P) ", X%P
+      WRITE (*,'(a4)',advance='no'), " Q) "
+      WRITE (*,'(f6.4,a1,f6.4,a1,f6.4)'), X%Q(1), "", X%Q(2), "", X%Q(3)
+
+      call abort
+      END SUBROUTINE
+
+      subroutine assert (x, s, i1, i2)
+        character*(*) s
+        integer i1, i2
+        logical b
+        INTEGER,PARAMETER :: AS = 3
+        STRUCTURE /T/
+          CHARACTER*20 C
+          INTEGER*1 I
+          INTEGER*2 J
+          INTEGER   K
+          INTEGER*4 L
+          INTEGER   M(5)
+          INTEGER   N(5)
+          INTEGER   O(AS)
+          INTEGER   P(2,2)
+          REAL      Q(3)
+        END STRUCTURE
+        RECORD /T/ X
+        if ( i1 .ne. i2 ) then
+          print *, s, ": expected ", i2, " but was ", i1
+          call dump (x)
+        endif
+      end subroutine
+
+      PROGRAM MAIN
+      INTEGER,PARAMETER :: AS = 3
+      STRUCTURE /T/
+        CHARACTER*20 C /"hello"/  ! OK
+        INTEGER*1 I /300_2/       ! bad, but still compiles; overflows int_1
+        INTEGER*2 J /300_4/       ! OK, converted
+        INTEGER   K /65536_8/     ! OK, implicit
+        INTEGER   L /200000/      ! OK, types match
+        INTEGER   M(5) /5,4,3,2,1/! OK
+        INTEGER   N(5) /1,3*2,1/  ! OK, with repeat spec (/1,2,2,2,1/)
+        INTEGER   O(AS) /AS*9/    ! OK, parameter array spec
+        INTEGER   P(2,2) /1,2,3,4/! OK
+        REAL      Q(3) /1_2,3.5,2.4e-12_8/ ! OK, with some implicit conversions
+      END STRUCTURE
+
+      RECORD /T/ X
+
+      ! do these by hand to avoid fortran type bs
+      if ( x%i .ne. 44 ) then
+        print *, "x%i: expected 44 but was ", x%i
+        call dump(x)
+      else if ( x%j .ne. 300 ) then
+        print *, "x%j: expected 300 but was ", x%j
+        call dump(x)
+      endif
+      call assert ( x, "x%k", x%k, 65536 )
+      call assert ( x, "x%l", x%l, 200000 )
+
+      call assert ( x, "x%m(1)", x%m(1), 5 )
+      call assert ( x, "x%m(2)", x%m(2), 4 )
+      call assert ( x, "x%m(3)", x%m(3), 3 )
+      call assert ( x, "x%m(4)", x%m(4), 2 )
+      call assert ( x, "x%m(5)", x%m(5), 1 )
+
+      call assert ( x, "x%n(1)", x%n(1), 1 )
+      call assert ( x, "x%n(2)", x%n(2), 2 )
+      call assert ( x, "x%n(3)", x%n(3), 2 )
+      call assert ( x, "x%n(4)", x%n(4), 2 )
+      call assert ( x, "x%n(5)", x%n(5), 1 )
+
+      call assert ( x, "x%o(1)", x%o(1), 9 )
+      call assert ( x, "x%o(2)", x%o(2), 9 )
+      call assert ( x, "x%o(3)", x%o(3), 9 )
+
+      call assert ( x, "x%p(1,1)", x%p(1,1), 1 )
+      call assert ( x, "x%p(2,1)", x%p(2,1), 2 )
+      call assert ( x, "x%p(1,2)", x%p(1,2), 3 )
+      call assert ( x, "x%p(2,2)", x%p(2,2), 4 )
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/init_old_bad.f b/gcc/testsuite/gfortran.dg/dec/init_old_bad.f
new file mode 100644
index 0000000..4a6abd1
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/init_old_bad.f
@@ -0,0 +1,19 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-structure" }
+      !
+      ! Test error checking for old-style initializations of structure components.
+      ! 
+
+      PROGRAM MAIN
+      INTEGER,PARAMETER :: AS = 3
+      STRUCTURE /T/
+        INTEGER   T(AS) /4*9/    ! { dg-error "Too many elements" }
+        INTEGER   U /1,2,3/      ! { dg-error "End of scalar initializer expected" }
+        INTEGER   V /"hi"/       ! { dg-error "Can't convert" }
+        INTEGER   W(3) /1,3/     ! { dg-error "Not enough elements" }
+        INTEGER   X(3) /1,3,5,7/ ! { dg-error "Too many elements" }
+        INTEGER   Y(3) /2*1/     ! { dg-error "Not enough elements" }
+        INTEGER   Z(3) /10*1/    ! { dg-error "Too many elements" }
+      END STRUCTURE
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/io_ccdef.f b/gcc/testsuite/gfortran.dg/dec/io_ccdef.f
new file mode 100644
index 0000000..29c3891
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/io_ccdef.f
@@ -0,0 +1,53 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-io" }
+      !
+      ! Control test for the cc*.for tests which test the DEC
+      ! CARRIAGECONTROL specifier. Should act like cclist.for.
+      !
+
+      subroutine writeall (s, fd1)
+        implicit none
+        character*(*) s
+        integer fd1
+        write (fd1,*) s
+      endsubroutine
+
+      subroutine readall (s, fd)
+        implicit none
+        integer i, fd, st
+        character*(*) s
+        character*19 buf
+        print *, "===> ", s, " <==="
+        st = 0
+        read (fd,'(a)',iostat=st) buf
+        do while (st .eq. 0)
+          print *, buf
+          read (fd,'(a)',iostat=st) buf
+        enddo
+      endsubroutine
+
+      program main
+
+      integer, parameter :: deffd=3
+      character*(*), parameter :: def   = "cc-def.txt"
+
+      open(unit=deffd,  file=def, action ="WRITE")
+
+      call writeall  ("+hi", deffd)
+      call writeall  ("-hi", deffd)
+      call writeall  ("0hi", deffd)
+      call writeall  ("1hi", deffd)
+      call writeall  ("$hi", deffd)
+      call writeall  (" hi", deffd)
+      call writeall  ("h	i", deffd)
+      call writeall  ("o k b y e n o w", deffd)
+
+      close(unit=deffd)
+
+      open(unit=deffd,  file=def, action ="READ")
+
+      call readall ("default", deffd)
+
+      close(unit=deffd)
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/io_ccfort.f b/gcc/testsuite/gfortran.dg/dec/io_ccfort.f
new file mode 100644
index 0000000..daf2d4c
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/io_ccfort.f
@@ -0,0 +1,54 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-io" }
+      !
+      ! Tests CARRIAGECONTROL='FORTRAN'.
+      !
+
+      subroutine writeall (s, fd1)
+        implicit none
+        character*(*) s
+        integer fd1
+        write (fd1,*) s
+      endsubroutine
+
+      subroutine readall (s, fd)
+        implicit none
+        integer i, fd, st
+        character*(*) s
+        character*19 buf
+        print *, "===> ", s, " <==="
+        st = 0
+        read (fd,'(a)',iostat=st) buf
+        do while (st .eq. 0)
+          print *, buf
+          read (fd,'(a)',iostat=st) buf
+        enddo
+      endsubroutine
+
+      program main
+
+      integer, parameter :: deffd=3
+      character*(*), parameter :: def   = "cc-fort.txt"
+
+      open(unit=deffd,  file=def, action ="WRITE",
+     &     carriagecontrol="FORTRAN")
+
+      call writeall  ("+hi", deffd)
+      call writeall  ("-hi", deffd)
+      call writeall  ("0hi", deffd)
+      call writeall  ("1hi", deffd)
+      call writeall  ("$hi", deffd)
+      call writeall  (" hi", deffd)
+      call writeall  ("h	i", deffd)
+      call writeall  ("o k b y e n o w", deffd)
+
+      close(unit=deffd)
+
+      open(unit=deffd,  file=def, action ="READ",
+     &     carriagecontrol="FORTRAN")
+
+      call readall ("fort", deffd)
+
+      close(unit=deffd)
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/io_cclist.f b/gcc/testsuite/gfortran.dg/dec/io_cclist.f
new file mode 100644
index 0000000..c0ab30e
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/io_cclist.f
@@ -0,0 +1,54 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-io" }
+      !
+      ! Tests CARRIAGECONTROL='LIST'.
+      !
+
+      subroutine writeall (s, fd1)
+        implicit none
+        character*(*) s
+        integer fd1
+        write (fd1,*) s
+      endsubroutine
+
+      subroutine readall (s, fd)
+        implicit none
+        integer i, fd, st
+        character*(*) s
+        character*19 buf
+        print *, "===> ", s, " <==="
+        st = 0
+        read (fd,'(a)',iostat=st) buf
+        do while (st .eq. 0)
+          print *, buf
+          read (fd,'(a)',iostat=st) buf
+        enddo
+      endsubroutine
+
+      program main
+
+      integer, parameter :: deffd=3
+      character*(*), parameter :: def   = "cc-list.txt"
+
+      open(unit=deffd,  file=def, action ="WRITE",
+     &     carriagecontrol="LIST")
+
+      call writeall  ("+hi", deffd)
+      call writeall  ("-hi", deffd)
+      call writeall  ("0hi", deffd)
+      call writeall  ("1hi", deffd)
+      call writeall  ("$hi", deffd)
+      call writeall  (" hi", deffd)
+      call writeall  ("h	i", deffd)
+      call writeall  ("o k b y e n o w", deffd)
+
+      close(unit=deffd)
+
+      open(unit=deffd,  file=def, action ="READ",
+     &     carriagecontrol="LIST")
+
+      call readall ("list", deffd)
+
+      close(unit=deffd)
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/io_ccnone.f b/gcc/testsuite/gfortran.dg/dec/io_ccnone.f
new file mode 100644
index 0000000..c31d289
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/io_ccnone.f
@@ -0,0 +1,55 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-io" }
+      !
+      ! Tests CARRIAGECONTROL='NONE'.
+      !
+
+      subroutine writeall (s, fd1)
+        implicit none
+        character*(*) s
+        integer fd1
+        write (fd1,*) s
+      endsubroutine
+
+      subroutine readall (s, fd)
+        implicit none
+        integer i, fd, st
+        character*(*) s
+        character*19 buf
+        print *, "===> ", s, " <==="
+        st = 0
+        read (fd,'(a)',iostat=st) buf
+        do while (st .eq. 0)
+          print *, buf
+          read (fd,'(a)',iostat=st) buf
+        enddo
+      endsubroutine
+
+      program main
+
+      integer, parameter :: deffd=3
+      character*(*), parameter :: def   = "cc-none.txt"
+      character*4 buf
+
+      open(unit=deffd,  file=def, action ="WRITE",
+     &     carriagecontrol="NONE")
+
+      call writeall  ("+hi", deffd)
+      call writeall  ("-hi", deffd)
+      call writeall  ("0hi", deffd)
+      call writeall  ("1hi", deffd)
+      call writeall  ("$hi", deffd)
+      call writeall  (" hi", deffd)
+      call writeall  ("h	i", deffd)
+      call writeall  ("o k b y e n o w", deffd)
+
+      close(unit=deffd)
+
+      open(unit=deffd,  file=def, action ="READ",
+     &     carriagecontrol="NONE")
+
+      call readall ("none", deffd)
+
+      close(unit=deffd)
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/io_readonly.f b/gcc/testsuite/gfortran.dg/dec/io_readonly.f
new file mode 100644
index 0000000..06fbea0
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/io_readonly.f
@@ -0,0 +1,23 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-io" }
+      !
+      ! Tests the READONLY flag. A more complex test should be done
+      ! which actually exercises the runtime protection of delete on
+      ! close.
+      !
+      program main
+
+      character*20, parameter :: fname='test.txt'
+      integer :: fd = 1
+      !character*100 cdata
+
+      open (unit=fd, file=fname, readonly)
+
+      !read (fd,'(a)') cdata
+      !write (*,'(a)') cdata
+
+      !write (fd,'(a)') cdata ! should cause runtime error
+
+      close (unit=fd) !, status='delete') ! should cause runtime error/warning
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/io_shared.f b/gcc/testsuite/gfortran.dg/dec/io_shared.f
new file mode 100644
index 0000000..b738e75
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/io_shared.f
@@ -0,0 +1,18 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-io" }
+      !
+      ! Tests compilation of the SHARE= specifier family. A more
+      ! complete test should be created which actually checks that the
+      ! correct fcntl() is made at runtime.
+      !
+      program main
+
+      character*20, parameter :: fname='test.txt'
+      integer fd
+
+      open (unit=fd, file=fname, action='read', shared)
+      open (unit=fd, file=fname, action='read', noshared)
+      open (unit=fd, file=fname, action='read', share='denynone')
+      open (unit=fd, file=fname, action='read', share='denyrw')
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/linefeed_fixed.f b/gcc/testsuite/gfortran.dg/dec/linefeed_fixed.f
new file mode 100644
index 0000000..a310e4d
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/linefeed_fixed.f
@@ -0,0 +1,10 @@
+! { dg-do compile }
+! { dg-options "-ffeed -ffixed-form" }
+!
+      PROGRAM MAIN
+
+      INTEGER*4 I   
+     INTEGER*4 K
+      INTEGER*4 J
+
+      END PROGRAM MAIN
diff --git a/gcc/testsuite/gfortran.dg/dec/linefeed_free.f b/gcc/testsuite/gfortran.dg/dec/linefeed_free.f
new file mode 100644
index 0000000..6dd8fa0
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/linefeed_free.f
@@ -0,0 +1,10 @@
+! { dg-do compile }
+! { dg-options "-ffeed -ffree-form" }
+!
+PROGRAM MAIN
+
+  INTEGER*4 I
+ INTEGER*4 K 
+INTEGER*4 J
+
+END PROGRAM MAIN
diff --git a/gcc/testsuite/gfortran.dg/dec/loc_rval.f b/gcc/testsuite/gfortran.dg/dec/loc_rval.f
new file mode 100644
index 0000000..2b8655e
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/loc_rval.f
@@ -0,0 +1,18 @@
+      ! { dg-do run }
+      ! { dg-options "-floc-rval" }
+      !
+      ! Test the usage of %loc as an rvalue with -floc-rval.
+      !
+
+      include 'assert.inc'
+      program main
+      integer j
+
+      integer :: i, k
+      
+      i =  loc ( j )
+      j = %loc ( j )
+
+      call assertll ("loc", i, j)
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/nocomp/nocomp_dot1.for b/gcc/testsuite/gfortran.dg/dec/nocomp/nocomp_dot1.for
new file mode 100644
index 0000000..514cd11
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/nocomp/nocomp_dot1.for
@@ -0,0 +1,66 @@
+! This is a horrible example of how twisted Fortran is:
+! "X.AND.AND.AND.AND" resolves to (X.AND.AND) .AND. (AND)
+! because ".AND." is defined to take (LOGICAL, T) parameters 
+! where "X.AND.AND" is type LOGICAL and "AND" is type T.
+! Without the knowledge of the type of parameters expected by the
+! user-defined ".AND.", this would be completely ambiguous.
+      module mod
+
+      TYPE t2
+          logical y
+      END TYPE
+
+      TYPE t1
+          logical and
+      END TYPE
+        
+      interface operator (.and.)
+          module procedure a
+      end interface operator (.and.)
+
+      interface operator (.or.)
+          module procedure b
+      end interface operator (.or.)
+
+      contains
+
+      function a(x, y)
+          type(t1), intent (in) :: x
+          logical, intent (in) :: y
+          logical a
+          print *, 'called and'
+          a = (.not. x%and) .and. (.not. y)
+          return
+      end function a
+
+      function b(x, y)
+          logical, intent (in) :: x
+          type(t2), intent (in) :: y
+          logical b
+          print *, 'called or'
+          b = (.not. x) .and. (.not. y%y)
+          return
+      end function b
+
+      end module mod
+
+      use mod
+
+      TYPE(t1) :: x
+      TYPE(t2) :: or
+      LOGICAL  :: y
+      LOGICAL :: i
+      x.and = .true.
+      or.y  = .true.
+      y = .true.
+
+      ! could be...
+      !   (x) .and. (or.y)  * but this is the chosen one
+      !   (x.and) .or. (y)
+      i = x.and.or.y 
+
+      if ( i ) then ! (x->and) .AND. (z)
+          print *, .true.
+      endif
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/nocomp/nocomp_dot2.for b/gcc/testsuite/gfortran.dg/dec/nocomp/nocomp_dot2.for
new file mode 100644
index 0000000..49ac578
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/nocomp/nocomp_dot2.for
@@ -0,0 +1,48 @@
+! { dg-do compile }
+! { dg-options "-fdec-member-dot }
+!
+! This is a horrible example of how twisted Fortran is:
+! "X.AND.AND.AND.AND" resolves to (X.AND.AND) .AND. (AND)
+! because ".AND." is defined to take (LOGICAL, T) parameters 
+! where "X.AND.AND" is type LOGICAL and "AND" is type T.
+! Without the knowledge of the type of parameters expected by the
+! user-defined ".AND.", this would be completely ambiguous.
+module mod
+
+TYPE t2
+    logical and
+END TYPE
+
+TYPE t
+    TYPE(t2) and
+END TYPE
+  
+interface operator (.and.)
+    module procedure a
+end interface operator (.and.)
+
+contains
+
+function a(x, y)
+    type(t), intent (in) :: y
+    logical, intent (in) :: x
+    logical a
+    print *, "called and"
+    a = (.not. x) .and. (.not. y%and%and)
+    return
+end function a
+
+end module mod
+
+use mod
+
+TYPE(t) :: and
+!and%and%and = .true.
+
+and.and.and = and.and.and.and.and
+
+if ( and.and.and ) then ! (x->and) .AND. (z)
+    print *, .true.
+endif
+
+end program
diff --git a/gcc/testsuite/gfortran.dg/dec/nocomp/others.for b/gcc/testsuite/gfortran.dg/dec/nocomp/others.for
new file mode 100644
index 0000000..173020c
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/nocomp/others.for
@@ -0,0 +1,40 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-intrinsic-ints" }
+      !
+      ! Tests the extended integer formats on bitwise and other
+      ! functions (BIJK-prefixes).
+      ! The functions in this test may not be implemented.
+      !
+
+      PROGRAM MAIN
+
+      INTEGER*1 :: BA, BB, BC, BD
+      INTEGER*2 :: IA, IB, IC, ID
+      INTEGER*4 :: JA, JB, JC, JD
+      INTEGER*8 :: KA, KB, KC, KD
+
+      BA = BIBITS(357, 10, 5)
+      BB = BMVBITS(357, 8, 3, BA, 1)
+      BC = BISHFTC(BA, 6, 3)
+      BD = BISHFT(BC, -3)
+      BA = BNOT(BD)
+
+      IA = IIBITS(357, 10, 5)
+      IB = IMVBITS(357, 8, 3, IA, 1)
+      IC = IISHFTC(IA, 3, 6)
+      ID = IISHFT(IC, -3)
+      IA = INOT(ID)
+
+      JA = JIBITS(357, 10, 5)
+      JB = JMVBITS(357, 8, 3, JA, 1)
+      JC = JISHFTC(JA, 3, 6)
+      JD = JISHFT(JC, -3)
+      JA = JNOT(JD)
+
+      KA = KIBITS(357_8, 10_8, 5_8)
+      KB = KMVBITS(357_8, 8_8, 3_8, KA, 1_8)
+      KC = KISHFTC(KA, 3_8, 6_8)
+      KD = KISHFT(KC, -3_8)
+      KA = KNOT(KD)
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/nocomp/union_type.for b/gcc/testsuite/gfortran.dg/dec/nocomp/union_type.for
new file mode 100644
index 0000000..a65172d
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/nocomp/union_type.for
@@ -0,0 +1,20 @@
+      program main
+
+      type words_long
+        union 
+          map 
+            integer*2  w1, w2, w3 
+          end map 
+          map 
+            integer*4  long
+          end map 
+        end union 
+      end type
+
+      type (words_long) x
+
+      x%long = z'56781234'
+      write (*,8) x%w1, x%w2, x%w3
+8     format (z5,z5,z5)
+
+      end program main
diff --git a/gcc/testsuite/gfortran.dg/dec/sin.f b/gcc/testsuite/gfortran.dg/dec/sin.f
new file mode 100644
index 0000000..186a917
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/sin.f
@@ -0,0 +1,30 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-math" }
+      !
+      include 'eqt.inc'
+      include 'checkf.inc'
+
+      PROGRAM MAIN
+      include 'decl.inc'
+
+      ! Input
+      F_I = 1.0471975512_4
+      D_I = 1.0471975512_8
+      !Q_I = 1.0471975512_16
+
+      ! Expected
+      F_OE = 0.866025403784_4
+      D_OE = 0.866025403784_8
+      !Q_OE = 0.866025403784_16
+
+      ! Actual
+      F_OA =  SIN (F_I)
+      F_OC =  SIN (1.0471975512_4)
+      D_OA = DSIN (D_I)
+      D_OC = DSIN (1.0471975512_8)
+      !Q_OA = QSIN (Q_I)
+      !Q_OC = QSIN (1.0471975512_16)
+
+      include 'check.inc'
+
+      END PROGRAM MAIN
diff --git a/gcc/testsuite/gfortran.dg/dec/sind.f b/gcc/testsuite/gfortran.dg/dec/sind.f
new file mode 100644
index 0000000..415a817
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/sind.f
@@ -0,0 +1,30 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-math" }
+      !
+      include 'eqt.inc'
+      include 'checkf.inc'
+
+      PROGRAM MAIN
+      include 'decl.inc'
+
+      ! Input
+      F_I = 60.0_4
+      D_I = 60.0_8
+      !Q_I = 60.0_16
+
+      ! Expected
+      F_OE = 0.866025403784_4
+      D_OE = 0.866025403784_8
+      !Q_OE = 0.866025403784_16
+
+      ! Actual
+      F_OA =  SIND (F_I)
+      F_OC =  SIND (60.0_4)
+      D_OA = DSIND (D_I)
+      D_OC = DSIND (60.0_8)
+      !Q_OA = QSIND (Q_I)
+      !Q_OC = QSIND (60.0_16)
+
+      include 'check.inc'
+
+      END PROGRAM MAIN
diff --git a/gcc/testsuite/gfortran.dg/dec/static_1.f b/gcc/testsuite/gfortran.dg/dec/static_1.f
new file mode 100644
index 0000000..85c4afa
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/static_1.f
@@ -0,0 +1,31 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-static -finit-local-zero" }
+      !
+      ! Test AUTOMATIC and STATIC attributes.
+      !
+      include 'assert.inc'
+
+      function f (x, y)
+        integer f, x, y, a      ! only a can actually be saved
+        integer, automatic :: c ! should actually be automatic
+        save
+
+        ! a should be incremented by x every time and saved
+        a = a + x 
+        f = a
+
+        ! c should be zeroed every time, therefore equal y
+        c = c + y 
+        call assertll ("f%c", c, y)
+        return
+      endfunction
+
+      implicit none
+      integer f
+
+      ! Should return static value of a; accumulates x
+      call assertll ("f()", f(1,3), 1)
+      call assertll ("f()", f(1,4), 2)
+      call assertll ("f()", f(1,2), 3)
+
+      end
diff --git a/gcc/testsuite/gfortran.dg/dec/static_2.f b/gcc/testsuite/gfortran.dg/dec/static_2.f
new file mode 100644
index 0000000..2da7d15
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/static_2.f
@@ -0,0 +1,50 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-static -fno-automatic -finit-local-zero" }
+      !
+      ! Make sure a warning is produced when variables marked AUTOMATIC
+      ! cannot be automatic due to compilation with -fno-automatic, and
+      ! that they are in fact still saved.
+      !
+      include 'assert.inc'
+
+      function f (x)
+      implicit none
+        integer f, x
+        integer, static :: a ! should be SAVEd
+        a = a + x ! should increment by x every time
+        f = a
+        return
+      endfunction
+
+      recursive subroutine g (x)
+      implicit none
+        integer x
+        integer, automatic :: a ! should be automatic (in recursive)
+        a = a + x ! should be set to x every time
+        call assertll ("g%a", a, x)
+      endsubroutine
+
+      subroutine h (x)
+      implicit none
+        integer x
+        integer, automatic :: a ! should be automatic (outside recursive)
+        a = a + x ! should be set to x every time
+        call assertll ("h%a", a, x)
+      endsubroutine
+
+      integer f
+
+      ! Should return static value of c; accumulates x
+      call assertll ("f()", f(3), 3)
+      call assertll ("f()", f(4), 7)
+      call assertll ("f()", f(2), 9)
+
+      call g(3)
+      call g(4)
+      call g(2)
+
+      call h(3)
+      call h(4)
+      call h(2)
+
+      end
diff --git a/gcc/testsuite/gfortran.dg/dec/struct_adhoc.f b/gcc/testsuite/gfortran.dg/dec/struct_adhoc.f
new file mode 100644
index 0000000..f88abb7
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/struct_adhoc.f
@@ -0,0 +1,71 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-structure" }
+      !
+      ! Test nested/ad-hoc structure definitions.
+      !
+      include 'assert.inc'
+
+      program main
+
+      structure /date/
+        integer*1 day, month 
+        integer*2 year 
+      end structure 
+
+      type appointment
+      record/date/app_date 
+      structure /time/ app_time (2) 
+        integer*1       hour, minute 
+      end structure 
+      structure/memo/app_memo (4)
+        record/time/when
+        character*20       why
+        structure /person/ who
+            character*10   name
+        end structure
+      end structure
+      logical         app_flag 
+      end type
+
+      record /appointment/ tomorrow
+      record /time/ now
+
+      tomorrow.app_date = date(6, 17, 2014)
+      tomorrow.app_time(1) = time(15, 0)
+      tomorrow.app_time(2) = time(16, 0)
+      tomorrow.app_memo(1).when = now
+      tomorrow.app_memo(1).why = "Kill"
+      tomorrow.app_memo(2).when = now
+      tomorrow.app_memo(2).why = "fortran"
+      tomorrow.app_memo(3).when = now
+      tomorrow.app_memo(3).why = "with"
+      tomorrow.app_memo(4).when = now
+      tomorrow.app_memo(4).why = "fire"
+      tomorrow.app_flag = .true.
+
+      call assertbb("tomorrow.app_date.day",   tomorrow.app_date.day,
+     & 6_1)
+      call assertbb("tomorrow.app_date.month", tomorrow.app_date.month, 
+     & 17_1)
+      call assertii("tomorrow.app_date.year",  tomorrow.app_date.year,  
+     & 2014_2)
+      call assertbb("tomorrow.app_time(1).hour", 
+     & tomorrow.app_time(1).hour, 15_1)
+      call assertbb("tomorrow.app_time(1).minute", 
+     & tomorrow.app_time(1).minute, 0_1)
+      call assertbb("tomorrow.app_time(2).hour", 
+     & tomorrow.app_time(2).hour, 16_1)
+      call assertbb("tomorrow.app_time(2).minute", 
+     & tomorrow.app_time(2).minute, 0_1)
+      call assert  ("tomorrow.app_flag",       tomorrow.app_flag)
+
+      call assertss("tomorrow.app_memo(1).why",
+     & tomorrow.app_memo(1).why, "Kill")
+      call assertss("tomorrow.app_memo(2).why", 
+     & tomorrow.app_memo(2).why, "fortran")
+      call assertss("tomorrow.app_memo(3).why", 
+     & tomorrow.app_memo(3).why, "with")
+      call assertss("tomorrow.app_memo(4).why", 
+     & tomorrow.app_memo(4).why, "fire")
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/struct_anon.f b/gcc/testsuite/gfortran.dg/dec/struct_anon.f
new file mode 100644
index 0000000..9a80ebc
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/struct_anon.f
@@ -0,0 +1,32 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-structure" }
+      !
+      ! Test anonymous ad-hoc structure components.
+      !
+      include 'assert.inc'
+
+      program main
+
+      structure /appointment/
+      structure time_start, time_end
+        integer*1       hour, minute 
+      end structure 
+      logical         app_flag 
+      end structure
+
+      record /appointment/ tomorrow
+
+      tomorrow.time_start.hour = 15
+      tomorrow.time_start.minute = 0
+      tomorrow.time_end.hour = 16
+      tomorrow.time_end.minute = 0
+      tomorrow.app_flag = .true.
+
+      call assertbb ("time_start.hour", tomorrow.time_start.hour, 15_1)
+      call assertbb ("time_start.minute", tomorrow.time_start.minute, 
+     & 0_1)
+      call assertbb ("time_end.hour", tomorrow.time_end.hour, 16_1)
+      call assertbb ("time_end.minute", tomorrow.time_end.minute, 0_1)
+      call assert   ("app_flag", tomorrow.app_flag)
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/struct_array.f b/gcc/testsuite/gfortran.dg/dec/struct_array.f
new file mode 100644
index 0000000..7304313
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/struct_array.f
@@ -0,0 +1,27 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-structure" }
+      !
+      ! Test arrays of structures.
+      !
+      include 'assert.inc'
+      program main
+      implicit none
+
+      structure /t/
+        integer z
+      end structure
+
+      structure /big/
+        integer x
+        record /t/ y
+      end structure
+
+      record /big/ array(10)
+      integer i 
+
+      array(3).y.z = 10
+      i = array(3).y.z
+
+      call assertll ("array(3).y.z", i, 10)
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/struct_basic.f b/gcc/testsuite/gfortran.dg/dec/struct_basic.f
new file mode 100644
index 0000000..c8291b2
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/struct_basic.f
@@ -0,0 +1,60 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-structure" }
+      !
+      ! Test basic semantics of the STRUCTURE extension.
+      !
+      include 'assert.inc'
+
+      program main
+
+      ! Declaring a structure named ``item'' and containing three fields:
+      ! an integer ID, an description string and a floating-point price.
+      STRUCTURE /item/
+        INTEGER id
+        LOGICAL expensive
+        CHARACTER(LEN=200) description
+        REAL price
+      END STRUCTURE
+
+      ! Equivalent to:
+      !TYPE item
+      !  INTEGER id
+      !  LOGICAL expensive
+      !  CHARACTER(LEN=200) description
+      !  REAL price
+      !END TYPE
+
+      ! Define two variables, an single record of type ``item''
+      ! named ``pear'', and an array of items named ``store_catalog''
+      RECORD /item/ pear, store_catalog(100)
+      ! equivalent to:
+      !TYPE(item) pear, store_catalog(100)
+
+      ! We can directly access the fields of both variables
+      pear.id = 92316
+      pear.description = "juicy D'Anjou pear"
+      pear.price = 0.15
+      pear.expensive = .FALSE.
+      store_catalog(7).id = 7831
+      store_catalog(7).description = "milk bottle"
+      store_catalog(7).price = 1.2
+
+      ! Instead of using a dot (.) to access fields of a record, the
+      ! standard syntax uses a percent sign (%)
+      !pear%id = 92316
+      !pear%description = "juicy D'Anjou pear"
+      !pear%price = 0.15
+      !store_catalog(7)%id = 7831
+      !store_catalog(7)%description = "milk bottle"
+      !store_catalog(7)%price = 1.2
+
+      ! Assignments of a whole variable do not change
+      store_catalog(12) = pear
+
+      call assertll ("pear.id", pear%id, 92316)
+      call assertrr ("pear.price", pear%price, 0.15)
+      call assertll ("store_catalog(7).id", store_catalog(7)%id, 7831)
+      call assertrr ("store_catalog(7).price", store_catalog(7)%price,
+     & 1.2)
+
+      end program main
diff --git a/gcc/testsuite/gfortran.dg/dec/struct_fill_bad.f b/gcc/testsuite/gfortran.dg/dec/struct_fill_bad.f
new file mode 100644
index 0000000..acb1bfe
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/struct_fill_bad.f
@@ -0,0 +1,18 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-structure" }
+      !
+      ! Test error handling for %FILL
+      !
+      program main
+
+      structure /s/
+        integer*2 i /3/
+        integer*2 %fill /4/ ! { dg-error "Unnamed field.*initializer" }
+        integer*2, pointer :: %fill ! { dg-error "Unnamed field.*attribute" }
+      end structure
+
+      type t
+        integer %fill ! { dg-error "Unnamed field.*allowed" }
+      endtype
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/struct_fill_fixed.f b/gcc/testsuite/gfortran.dg/dec/struct_fill_fixed.f
new file mode 100644
index 0000000..2d4268c
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/struct_fill_fixed.f
@@ -0,0 +1,32 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-structure" }
+      !
+      ! Test the %FILL component extension.
+      !
+      include 'assert.inc'
+
+      program main
+
+      structure /s/
+        integer*2 i
+        integer*2 %fill
+        integer*2 j
+      end structure
+
+      structure /s2/
+        character buf(6)
+      end structure
+
+      record /s/ x
+      record /s2/ y
+      equivalence (x, y)
+
+      x.i = z'3130'
+      x.j = z'3332'
+
+      call assertss ("[0]", y.buf(1), "0")
+      call assertss ("[1]", y.buf(2), "1")
+      call assertss ("[2]", y.buf(5), "2")
+      call assertss ("[3]", y.buf(6), "3")
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/struct_fill_free.f b/gcc/testsuite/gfortran.dg/dec/struct_fill_free.f
new file mode 100644
index 0000000..b0c1a97
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/struct_fill_free.f
@@ -0,0 +1,32 @@
+! { dg-do compile }
+! { dg-options "-fdec-structure -ffree-form" }
+!
+! Test the %FILL component extension.
+!
+include 'assert.inc'
+
+program main
+
+structure /s/
+  integer*2 i
+  integer*2 %fill
+  integer*2 j
+end structure
+
+structure /s2/
+  character buf(6)
+end structure
+
+record /s/ x
+record /s2/ y
+equivalence (x, y)
+
+x.i = z'3130'
+x.j = z'3332'
+
+call assertss ("[0]", y.buf(1), "0")
+call assertss ("[1]", y.buf(2), "1")
+call assertss ("[2]", y.buf(5), "2")
+call assertss ("[3]", y.buf(6), "3")
+
+end program
diff --git a/gcc/testsuite/gfortran.dg/dec/struct_name_comp.f b/gcc/testsuite/gfortran.dg/dec/struct_name_comp.f
new file mode 100644
index 0000000..d82bda7
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/struct_name_comp.f
@@ -0,0 +1,17 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-structure" }
+      !
+      ! Make sure the name of a component does not conflict with the name of a
+      ! variable. 
+      !
+      program main
+
+      structure /t1/
+        integer*4 comp
+      end structure
+      record /t1/ comp
+      structure /t2/
+        integer*4 comp
+      end structure
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/struct_name_share.f b/gcc/testsuite/gfortran.dg/dec/struct_name_share.f
new file mode 100644
index 0000000..7177a73
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/struct_name_share.f
@@ -0,0 +1,13 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-structure" }
+      !
+      ! Make sure variables can share names with structures.
+      !
+      program main
+
+      structure /TY/
+        integer i
+      end structure
+      record /TY/ ty
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/struct_record.f b/gcc/testsuite/gfortran.dg/dec/struct_record.f
new file mode 100644
index 0000000..6af87d4
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/struct_record.f
@@ -0,0 +1,39 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-structure" }
+      !
+      ! Verify a structure containing a record.
+      !
+      include 'assert.inc'
+
+      program main
+
+      structure /person/ 
+          character(20) name
+          integer(1) age
+      end structure
+
+      structure /car/
+          record /person/ owner
+          character(10)   make
+          character(10)   model
+          integer(4)      year
+      end structure
+
+      record /person/ me
+      record /car/ mycar
+
+      me.name = "fritz"
+      me.age = 21
+
+      mycar.owner = me
+      mycar.make = "volkswagen"
+      mycar.model = "jetta"
+      mycar.year = 2013
+
+      call assertss ("me.name", me.name, "fritz")
+      call assertbb ("me.age", me.age,  21_1)
+      call assertss ("mycar.make", mycar.make,  "volkswagen")
+      call assertss ("mycar.model", mycar.model, "jetta")
+      call assertll ("mycar.year", mycar.year,  2013)
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/tan.f b/gcc/testsuite/gfortran.dg/dec/tan.f
new file mode 100644
index 0000000..3c855e4
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/tan.f
@@ -0,0 +1,30 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-math" }
+      !
+      include 'eqt.inc'
+      include 'checkf.inc'
+
+      PROGRAM MAIN
+      include 'decl.inc'
+
+      ! Input
+      F_I = 1.0471975512_4
+      D_I = 1.0471975512_8
+      !Q_I = 1.0471975512_16
+
+      ! Expected
+      F_OE = 1.73205080757_4
+      D_OE = 1.73205080757_8
+      !Q_OE = 1.73205080757_16
+
+      ! Actual
+      F_OA =  TAN (F_I)
+      F_OC =  TAN (1.0471975512_4)
+      D_OA = DTAN (D_I)
+      D_OC = DTAN (1.0471975512_8)
+      !Q_OA = QTAN (Q_I)
+      !Q_OC = QTAN (1.0471975512_16)
+
+      include 'check.inc'
+
+      END PROGRAM MAIN
diff --git a/gcc/testsuite/gfortran.dg/dec/tand.f b/gcc/testsuite/gfortran.dg/dec/tand.f
new file mode 100644
index 0000000..d5da7b2
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/tand.f
@@ -0,0 +1,30 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-math" }
+      !
+      include 'eqt.inc'
+      include 'checkf.inc'
+
+      PROGRAM MAIN
+      include 'decl.inc'
+
+      ! Input
+      F_I = 60.0_4
+      D_I = 60.0_8
+      !Q_I = 60.0_16
+
+      ! Expected
+      F_OE = 1.73205080757_4
+      D_OE = 1.73205080757_8
+      !Q_OE = 1.73205080757_16
+
+      ! Actual
+      F_OA =  TAND (F_I)
+      F_OC =  TAND (60.0_4)
+      D_OA = DTAND (D_I)
+      D_OC = DTAND (60.0_8)
+      !Q_OA = QTAND (Q_I)
+      !Q_OC = QTAND (60.0_16)
+
+      include 'check.inc'
+
+      END PROGRAM MAIN
diff --git a/gcc/testsuite/gfortran.dg/dec/test.txt b/gcc/testsuite/gfortran.dg/dec/test.txt
new file mode 100644
index 0000000..1e3cfd5
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/test.txt
@@ -0,0 +1,4 @@
+This is a line from a file.
+This file has two lines.
+Actually there are more than two lines.
+What does this mean? I don't know.
diff --git a/gcc/testsuite/gfortran.dg/dec/teststructs.inc b/gcc/testsuite/gfortran.dg/dec/teststructs.inc
new file mode 100644
index 0000000..1277a08
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/teststructs.inc
@@ -0,0 +1,26 @@
+      IMPLICIT NONE
+      STRUCTURE /T1/
+        UNION
+        MAP
+        INTEGER*4 I
+        END MAP
+        MAP
+        INTEGER*2 IH
+        INTEGER*2 IL
+        END MAP
+        END UNION
+        INTEGER*4 IT1
+      END STRUCTURE
+
+      STRUCTURE /T2/
+        UNION
+        MAP
+        INTEGER*4 J
+        END MAP
+        MAP
+        INTEGER*2 JH
+        INTEGER*2 JL
+        END MAP
+        END UNION
+        INTEGER*4 IT2
+      END STRUCTURE
diff --git a/gcc/testsuite/gfortran.dg/dec/union_basic1.f b/gcc/testsuite/gfortran.dg/dec/union_basic1.f
new file mode 100644
index 0000000..b30ac72
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/union_basic1.f
@@ -0,0 +1,27 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-structure" }
+      !
+      ! Tests a basic union.
+      !
+
+      include 'assert.inc'
+      program main
+
+      structure /test/
+        union
+        map
+          integer a
+        end map
+        map
+          real b
+        end map
+        end union
+      end structure
+
+      record /test/ x
+
+      x.b = 1.357e2
+
+      call assertll ("(int) 1.357e2", x.a, 1124578099)
+
+      end program main
diff --git a/gcc/testsuite/gfortran.dg/dec/union_basic2.f b/gcc/testsuite/gfortran.dg/dec/union_basic2.f
new file mode 100644
index 0000000..1c366bf
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/union_basic2.f
@@ -0,0 +1,34 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-structure" }
+      !
+      ! Tests a basic union.
+      !
+
+      include 'assert.inc'
+      program main
+
+      structure /test/
+        integer*4 long
+      end structure
+
+      structure /words_long/ 
+        union 
+          map 
+            integer*2  w1, w2
+          end map 
+          map 
+            integer*4  long
+          end map 
+        end union 
+      end structure 
+
+      record /words_long/ x
+      record /test/ t
+      integer*2, parameter :: w1 = z'1234', w2 = z'5678'
+
+      x.long = z'56781234'
+
+      call assertii ("x.w1", x.w1, w1)
+      call assertii ("x.w2", x.w2, w2)
+
+      end program main
diff --git a/gcc/testsuite/gfortran.dg/dec/union_compare.f b/gcc/testsuite/gfortran.dg/dec/union_compare.f
new file mode 100644
index 0000000..4ea1e48
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/union_compare.f
@@ -0,0 +1,35 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-structure" }
+      !
+      ! teststructs.inc contains declarations for types T1 and T2, which are
+      ! equivalent but with different member names (so not equal)
+
+      SUBROUTINE COMPARE (A, B)
+      include 'teststructs.inc'
+
+      RECORD /T1/ A
+      RECORD /T1/ B
+
+      if ( A.I .eq. B.I ) then
+        PRINT *, "(cmp) pass"
+      else
+        PRINT *, "FAIL!!!!"
+        call abort
+      endif
+      END SUBROUTINE
+
+
+      PROGRAM MAIN
+      include 'teststructs.inc'
+
+      RECORD /T1/ X
+      RECORD /T2/ Y
+
+      X.IT1 = 200
+      X.I = 100
+      Y.J = 100
+
+      CALL COMPARE (X, X)
+      !CALL COMPARE (X, Y) ! should complain (?)
+
+      END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/dec/union_copy.f b/gcc/testsuite/gfortran.dg/dec/union_copy.f
new file mode 100644
index 0000000..6429258
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/union_copy.f
@@ -0,0 +1,71 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-structure" }
+      !
+      ! Tests whether union backend declarations are correctly /not/
+      ! copied when they are not in fact equal.
+
+      include 'assert.inc'
+
+      function test1 (x)
+      implicit none
+      integer x, test1
+
+      ! The BUFFER structure is first seen here.
+      integer*4 L_bbuf
+      parameter (L_bbuf=1024)
+      include 'buffer.inc'
+      record /buffer/ buf
+
+      buf.lbuf(1) = z'badbeef'
+      buf.lbuf(2) = z'badbeef'
+      buf.lbuf(3) = z'badbeef'
+      buf.lbuf(4) = z'badbeef'
+
+      if (x .ge. 0 .and. x .le. 4) then
+        test1 = buf.lbuf(x)
+      else
+        test1 = buf.lbuf(1)
+      endif
+
+      return
+      endfunction
+
+      function test2 (x)
+      implicit none
+      integer x, test2
+
+      ! This is the second BUFFER structure, seen with different
+      ! parameters. Though the declarations are identical, the backend
+      ! from the first union should NOT be copied since it is of
+      ! different size. If it is in fact copied, this may cause
+      ! discrepancies in translation leading to overwriting important
+      ! pieces of the stack due to initialization (such as the return value).
+      integer*4 L_bbuf
+      parameter (L_bbuf=65536)
+      include 'buffer.inc'
+      record /buffer/ buf
+
+      buf.lbuf(1) = z'beefbad'
+      buf.lbuf(2) = z'beefbad'
+      buf.lbuf(3) = z'beefbad'
+      buf.lbuf(4) = z'beefbad'
+
+      if (x .ge. 0 .and. x .le. 4) then
+        test2 = buf.lbuf(x)
+      else
+        test2 = buf.lbuf(1)
+      endif
+
+      return
+      endfunction
+
+      program main
+      implicit none
+      integer x, y, test1, test2
+
+      x = test1(2)
+      y = test2(3)
+      call assertll ("test1", x, 195935983) ! 0xbadbeef
+      call assertll ("test2", y, 200211373) ! 0xbeefbad
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/union_dup.f b/gcc/testsuite/gfortran.dg/dec/union_dup.f
new file mode 100644
index 0000000..53cd8d9
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/union_dup.f
@@ -0,0 +1,39 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-structure" }
+      !
+      ! Tests whether the compiler correctly complains when a member has been
+      ! declared twice in unions, including a nested sense.
+      !
+
+      program main
+
+      structure /test/
+        union
+
+          map
+            integer x ! { dg-error "already declared" }
+          end map
+
+          map
+            integer y ! { dg-error "already declared" }
+
+            union 
+
+              map
+                integer x ! { dg-error "already declared" }
+              end map
+
+              map
+                structure y ! { dg-error "already declared" }
+                  integer*1 hour, minute 
+                end structure  ! { dg-error "Expecting END MAP" }
+              end map
+
+            end union
+
+          end map
+
+        end union
+      end structure
+
+      end program main
diff --git a/gcc/testsuite/gfortran.dg/dec/union_empty.f b/gcc/testsuite/gfortran.dg/dec/union_empty.f
new file mode 100644
index 0000000..65abd0a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/union_empty.f
@@ -0,0 +1,17 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-structure" }
+      !
+      ! Allow compilation of a structure with an empty union.
+      !
+      program main
+      structure /test/
+        integer i
+        union
+          map
+          end map
+          map
+          end map
+        end union
+      end structure
+      end program main
+
diff --git a/gcc/testsuite/gfortran.dg/dec/union_init_def.f b/gcc/testsuite/gfortran.dg/dec/union_init_def.f
new file mode 100644
index 0000000..b5ce998
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/union_init_def.f
@@ -0,0 +1,38 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-structure -finit-local-zero -finit-derived" }
+      !
+      ! Test initialization of a structure containing a union with -finit-derived.
+      !
+
+      include 'assert.inc'
+      program main
+
+      structure /test/
+        integer*4 long
+      end structure
+
+      structure /words_long/ 
+        union 
+          map 
+      integer*2  w1, w2, w3 
+          end map 
+          map 
+      integer*4  long
+          end map 
+        end union 
+      end structure 
+
+      record /words_long/ x
+      record /test/ t
+
+      call assertii ("x.w1", x.w1, 0_2)
+      call assertii ("x.w2", x.w2, 0_2)
+      call assertii ("x.w3", x.w3, 0_2)
+
+      x.long = z'56781234'
+
+      call assertii ("x.w1", x.w1, 4660_2)  ! 0x1234
+      call assertii ("x.w2", x.w2, 22136_2) ! 0x5678
+      call assertii ("x.w3", x.w3, 0_2)     ! untouched
+
+      end program main
diff --git a/gcc/testsuite/gfortran.dg/dec/union_init_exp.f b/gcc/testsuite/gfortran.dg/dec/union_init_exp.f
new file mode 100644
index 0000000..21a9cd9
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/union_init_exp.f
@@ -0,0 +1,36 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-structure -finit-derived -finit-local-zero" }
+      !
+      ! Test explicit initialization expressions within unions mixed with
+      ! -finit-derived.
+      !
+
+      include 'assert.inc'
+      program main
+
+      structure /test/
+      integer :: i = 8
+      union
+      map
+      integer*2 :: x = 1600
+      integer*2 :: y = 1600
+      end map
+      map
+      integer*2 a,b,c,d,e
+      end map
+      end union
+      end structure
+
+      record /test/ t
+
+      call assertll ("i", t.i, 8)
+      call assertii ("x", t.x, 1600_2)
+      call assertii ("x", t.x, 1600_2)
+
+      call assertii ("a", t.a, 1600_2)
+      call assertii ("b", t.b, 1600_2)
+      call assertii ("c", t.c, 0_2)
+      call assertii ("d", t.d, 0_2)
+      call assertii ("e", t.e, 0_2)
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/union_init_overlap.f b/gcc/testsuite/gfortran.dg/dec/union_init_overlap.f
new file mode 100644
index 0000000..5c8c8ef
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/union_init_overlap.f
@@ -0,0 +1,38 @@
+      ! { dg-do compile }
+      ! { dg-options "-fdec-structure" }
+      !
+      ! This program gives a warning with gfortran because the
+      ! initialization of Z overwrites the initializations given in X
+      ! and Y.
+
+      ! The Intel documentation states that the last initializer to
+      ! appear is the prevailing initializer; however, ifort 11.1 does
+      ! not seem to follow this (it seems to use the initializers for X
+      ! and Y rather than Z).
+
+      ! The correct behavior in the future is to initialize the first
+      ! four bytes of the union with 7777777 and the last two bytes
+      ! with 100.
+      program main
+
+      structure /test/
+      integer :: i = 8
+      union
+      map ! { dg-warning "overwritten by initializer" }
+      integer*2 :: x = 1600
+      integer*2 :: y = 1600
+      end map
+      map ! { dg-warning "overwritten by initializer" }
+      integer*4 :: z = 7777777
+      end map
+      map ! { dg-warning "overwritten by initializer" }
+      integer*4 a,b,c,d
+      integer*2 :: e = 100
+      end map
+      end union
+      end structure
+
+      record /test/ t
+      print *, t.z
+
+      end program
diff --git a/gcc/testsuite/gfortran.dg/dec/union_nested1.f b/gcc/testsuite/gfortran.dg/dec/union_nested1.f
new file mode 100644
index 0000000..82a0b34
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/union_nested1.f
@@ -0,0 +1,72 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-structure -fno-range-check" }
+      !
+      ! Test the correctness of nested unions.
+      !
+
+      include 'assert.inc'
+      program main
+      implicit none
+
+      structure /nest/
+      integer*4 a
+
+      union     ! u1
+      map ! u1.m1
+        integer*4 b
+        integer*4 c
+      end map
+      map ! u1.m2
+        integer*2 d
+        integer*2 e
+        integer*4 f
+      end map
+      map ! u1.m3
+        integer*4 w
+        union   ! u1.u2
+        map     ! u1.u2.m1
+          integer*2 x 
+          integer*2 y
+        end map
+        map     ! u1.u2.m2
+          integer*4 z
+        end map
+        end union
+      end map
+      end union
+
+      union     ! u2
+      map ! u2.m1
+        integer*8 g
+        integer*4 h
+      end map
+
+      map ! u2.m2
+        integer*4 i
+        integer*8 j
+      end map
+      end union
+
+      end structure
+
+
+      record /nest/ s
+      ! Use parameters to get around casting problems with hex
+      integer*4, parameter :: b = z'0000ABCD'
+      integer*4, parameter :: c = z'FEEDBEEF'
+      integer*4, parameter :: h = z'FEFEDCBA'
+      integer*4, parameter :: i = z'87654321'
+
+      s.w = z'abcd'
+      s.x = z'beef'
+      s.y = z'feed'
+
+      s.g = z'1234567887654321'
+      S.J = z'ABCDEFeFFeFEDCBA'
+
+      call assertll ("s.b", s.b, b)
+      call assertll ("s.c", s.c, c)
+      call assertll ("s.h", s.h, h)
+      call assertll ("s.i", s.i, i)
+
+      end program main
diff --git a/gcc/testsuite/gfortran.dg/dec/union_nested2.f b/gcc/testsuite/gfortran.dg/dec/union_nested2.f
new file mode 100644
index 0000000..aca046d
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/union_nested2.f
@@ -0,0 +1,80 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-structure -fno-range-check" }
+      !
+      ! Simulation of 64-bit intel register and its various access modes
+      ! using the fortran union construct. Tests correctness of nested unions.
+      !
+
+      include 'assert.inc'
+      program main
+
+      structure /reg/
+
+      union     ! rax
+      map
+        integer*8 rx
+        end map
+      map
+        integer*4 rh
+
+        union   ! eax
+        map
+          integer*4 rl
+          end map
+        map
+          integer*4 ex
+          end map
+        map
+          integer*2 eh
+
+          union ! ax
+          map
+      integer*2 el
+      end map
+          map
+      integer*2 x
+      end map
+          map
+      integer*1 h
+      integer*1 l
+          end map
+          end union
+
+        end map
+        end union
+
+      end map
+      end union
+
+      end structure
+
+
+      record /reg/ a ! rax
+
+      integer*8, parameter :: rax = z'AABBCCCCFFFFFFFF'
+      integer*4, parameter :: rah =         z'FFFFFFFF'
+      integer*4, parameter :: ral = z'AABBCCCC'
+
+      integer*4, parameter :: eax = z'AABBCCCC'
+      integer*2, parameter :: eah =     z'CCCC'
+      integer*2, parameter :: eal = z'AABB'
+
+      integer*2, parameter ::  ax = z'AABB'
+      integer*1, parameter ::  ah =   z'BB'
+      integer*1, parameter ::  al = z'AA'
+
+      a.rx = z'AABBCCCCFFFFFFFF'
+
+      call assertqq ('rax', a.rx, rax)
+      call assertll ('rah', a.rh, rah)
+      call assertll ('ral', a.rl, ral)
+
+      call assertll ('eax', a.ex, eax)
+      call assertii ('eah', a.eh, eah)
+      call assertii ('eal', a.el, eal)
+
+      call assertii (' ax',  a.x,  ax)
+      call assertbb (' ah',  a.h,  ah)
+      call assertbb (' al',  a.l,  al)
+
+      end program main
diff --git a/gcc/testsuite/gfortran.dg/dec/union_ref.f b/gcc/testsuite/gfortran.dg/dec/union_ref.f
new file mode 100644
index 0000000..d64502a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/union_ref.f
@@ -0,0 +1,29 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-structure -fno-range-check" }
+      !
+      ! Ensure array and component references are calculated correctly for
+      ! unions.
+      !
+
+      include 'assert.inc'
+      program main
+
+      structure /test/
+      union
+        map
+          character*20 m
+        end map
+        map
+          integer*4 a, b, c
+        end map
+      end union
+      end structure
+
+      record /test/ x
+
+      x.m = "CDEFGHIJKLMNOPQRSTUV"
+
+      call assert ('x.m(1:1)', x.m(1:1).eq.'C')
+
+      END PROGRAM MAIN
+
diff --git a/gcc/testsuite/gfortran.dg/dec/xor.f b/gcc/testsuite/gfortran.dg/dec/xor.f
new file mode 100644
index 0000000..ba25142
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec/xor.f
@@ -0,0 +1,27 @@
+      ! { dg-do run }
+      ! { dg-options "-fdec-logical-xor -ffixed-form" }
+      !
+      ! Test the logical XOR operator.
+      !
+
+      program main
+      implicit none
+      logical a, b, c, n, x, d(2)
+      integer i, j
+      d(1) = .true.
+      d(2) = .false.
+      do 10 i = 1,2
+        do 11 j = 1,2
+            a = d(j)
+            b = d(i)
+            n = a .neqv. b
+            x = a .xor. b
+            if ( n .neqv. x ) then
+                print *, "(",a,b,") fail!!!! NEQV: ", n, "  XOR: ", x
+                call abort
+            else
+                print *, "(",a,b,") PASS"
+            endif
+11      enddo
+10    enddo
+      end program main
diff --git a/gcc/testsuite/gfortran.dg/dg.exp b/gcc/testsuite/gfortran.dg/dg.exp
index 795ac8e..e3dfdfc 100644
--- a/gcc/testsuite/gfortran.dg/dg.exp
+++ b/gcc/testsuite/gfortran.dg/dg.exp
@@ -29,6 +29,10 @@ if ![info exists DEFAULT_FFLAGS] then {
 dg-init
 
 # Main loop.
+
+gfortran-dg-runtest [lsort \
+       [glob -nocomplain $srcdir/$subdir/dec/*.\[fF\] ] ] $DEFAULT_FFLAGS
+
 gfortran-dg-runtest [lsort \
        [glob -nocomplain $srcdir/$subdir/*.\[fF\]{,90,95,03,08} ] ] $DEFAULT_FFLAGS
 
diff --git a/gcc/testsuite/gfortran.dg/init_derived_1.f b/gcc/testsuite/gfortran.dg/init_derived_1.f
new file mode 100644
index 0000000..c187203
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/init_derived_1.f
@@ -0,0 +1,72 @@
+! { dg-do run }
+! { dg-options "-finit-local-zero -finit-derived -fbackslash" }
+!
+! Make sure -finit-derived with -finit-local-zero initializes components
+! of local derived type variables to zero without overwriting explicit default
+! initializers.
+!
+      include 'assert.inc'
+
+      implicit none
+
+      type ty
+        ! Make sure components are initialized to zero
+        integer i1
+        real r1
+        logical l1
+        character c1
+        ! Make sure explicit default initializers are not overwritten
+        integer :: i2 = 1
+        real :: r2 = 1.0
+        logical :: l2 = .true.
+        character :: c2 = 'x'
+      end type
+      type(ty) t
+      ! Make sure explicit symbol initializer is not overwritten
+      type(ty) :: t2 = ty(1,1.0,.true.,'x',0,0.0,.false.,'\0')
+
+      ! Make sure locals are still initialized to zero
+      integer ii1
+      real rr1
+      logical ll1
+      character cc1
+
+      ! Make sure locals' initializers are not overwritten
+      integer :: ii2 = 1
+      real :: rr2 = 1.0
+      logical :: ll2 = .true.
+      character :: cc2 = 'x'
+
+      ! Local simply typed variables
+      call assertll ("ii1",  ii1,  0)
+      call assertrr ("rr1",  rr1,  0.0)
+      call assert   ("ll1",  .not. ll1)
+      call assertss ("cc1", cc1, '\0')
+
+      call assertll ("ii2",  ii2,  1)
+      call assertrr ("rr2",  rr2,  1.0)
+      call assert   ("ll2",  ll2)
+      call assertss ("cc2", cc2, 'x')
+
+      ! Local derived type variables
+      call assertll ("t%i1",  t%i1,  0)
+      call assertrr ("t%r1",  t%r1,  0.0)
+      call assert   ("t%l1",  .not. t%l1)
+      call assertss ("t%c1", t%c1, '\0')
+
+      call assertll ("t%i2",  t%i2,  1)
+      call assertrr ("t%r2",  t%r2,  1.0)
+      call assert   ("t%l2",  t%l2)
+      call assertss ("t%c2",  t%c2, 'x')
+
+      call assertll ("t2%i1",  t2%i1,  1)
+      call assertrr ("t2%r1",  t2%r1,  1.0)
+      call assert   ("t2%l1",  t2%l1)
+      call assertss ("t2%c1",  t2%c1, 'x')
+
+      call assertll ("t2%i2",  t2%i2,  0)
+      call assertrr ("t2%r2",  t2%r2,  0.0)
+      call assert   ("t2%l2",  .not. t2%l2)
+      call assertss ("t2%c2",  t2%c2, '\0')
+
+      end
diff --git a/gcc/testsuite/gfortran.dg/init_derived_2.f b/gcc/testsuite/gfortran.dg/init_derived_2.f
new file mode 100644
index 0000000..36ba36d
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/init_derived_2.f
@@ -0,0 +1,38 @@
+! { dg-do run }
+! { dg-options "-finit-integer=5 -finit-real=nan -finit-logical=true -finit-character=32 -finit-derived -fbackslash" }
+!
+! Make sure -finit-derived initializes components of local derived type
+! variables to parameters given on the command line.
+!
+      include 'assert.inc'
+
+      implicit none
+
+      type ty
+        ! Make sure components are initialized appropriately
+        integer i   ! = 5
+        real r      ! = nan
+        logical l   ! = .true.
+        character c ! = ' ' (32)
+      end type
+      type(ty) t
+
+      ! Make sure locals are still initialized appropriately
+      integer ii   ! = 5
+      real rr      ! = nan
+      logical ll   ! = .true.
+      character cc ! = ' ' (32)
+
+      ! Local simply typed variables
+      call assertll ("ii",  ii,   5)
+      call assert   ("isnan(rr)", ISNAN(rr))
+      call assert   ("ll",  ll)
+      call assertss ("cc",  cc,   ' ')
+
+      ! Local derived type variables
+      call assertll ("t%i",  t%i,  5)
+      call assert   ("isnan(t%r)", ISNAN(t%r))
+      call assert   ("t%l",  t%l)
+      call assertss ("t%c",  t%c,  ' ')
+
+      end
diff --git a/gcc/testsuite/gfortran.dg/oldstyle_5.f b/gcc/testsuite/gfortran.dg/oldstyle_5.f
new file mode 100644
index 0000000..8a0d311
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/oldstyle_5.f
@@ -0,0 +1,8 @@
+C { dg-do compile }
+      TYPE T
+      INTEGER A(2)/1,2/ ! { dg-error "Invalid old style initialization for derived type component" }
+      END TYPE
+      TYPE S
+      INTEGER B/1/ ! { dg-error "Invalid old style initialization for derived type component" }
+      END TYPE
+      END
diff --git a/libgfortran/io/close.c b/libgfortran/io/close.c
index fa9c113..871d721 100644
--- a/libgfortran/io/close.c
+++ b/libgfortran/io/close.c
@@ -66,6 +66,8 @@ st_close (st_parameter_close *clp)
   u = find_unit (clp->common.unit);
   if (u != NULL)
     {
+      if (close_fcntl (u))
+        generate_error (&clp->common, LIBERROR_OS, "Problem in CLOSE");
       if (u->flags.status == STATUS_SCRATCH)
 	{
 	  if (status == CLOSE_KEEP)
@@ -80,12 +82,18 @@ st_close (st_parameter_close *clp)
 	{
 	  if (status == CLOSE_DELETE)
             {
+              if (u->flags.readonly)
+                generate_warning (&clp->common, "STATUS set to DELETE on CLOSE"
+                                  " but file protected by READONLY specifier");
+              else
+              {
 #if HAVE_UNLINK_OPEN_FILE
 	      delete_file (u);
 #else
 	      path = (char *) gfc_alloca (u->file_len + 1);
               unpack_filename (path, u->file, u->file_len);
 #endif
+              }
             }
 	}
 
diff --git a/libgfortran/io/file_pos.c b/libgfortran/io/file_pos.c
index 8b4fda3..93c564a 100644
--- a/libgfortran/io/file_pos.c
+++ b/libgfortran/io/file_pos.c
@@ -362,6 +362,8 @@ st_endfile (st_parameter_filepos *fpp)
 	  u_flags.sign = SIGN_UNSPECIFIED;
 	  u_flags.status = STATUS_UNKNOWN;
 	  u_flags.convert = GFC_CONVERT_NATIVE;
+          u_flags.share = SHARE_UNSPECIFIED;
+          u_flags.cc = CC_UNSPECIFIED;
 
 	  opp.common = fpp->common;
 	  opp.common.flags &= IOPARM_COMMON_MASK;
diff --git a/libgfortran/io/io.h b/libgfortran/io/io.h
index 10f0985..7dfa577 100644
--- a/libgfortran/io/io.h
+++ b/libgfortran/io/io.h
@@ -209,6 +209,18 @@ typedef enum
 unit_async;
 
 typedef enum
+{ SHARE_DENYRW, SHARE_DENYNONE,
+  SHARE_UNSPECIFIED
+}
+unit_share;
+
+typedef enum
+{ CC_LIST, CC_FORTRAN, CC_NONE,
+  CC_UNSPECIFIED
+}
+unit_cc;
+
+typedef enum
 { SIGN_S, SIGN_SS, SIGN_SP }
 unit_sign_s;
 
@@ -239,6 +251,9 @@ typedef struct
   CHARACTER1 (sign);
   CHARACTER2 (asynchronous);
   GFC_INTEGER_4 *newunit;
+  GFC_INTEGER_4 (readonly);
+  CHARACTER1 (share);
+  CHARACTER2 (cc);
 }
 st_parameter_open;
 
@@ -494,17 +509,20 @@ typedef struct
   unit_blank blank;
   unit_delim delim;
   unit_form form;
-  int is_notpadded;
   unit_position position;
   unit_status status;
   unit_pad pad;
   unit_convert convert;
-  int has_recl;
   unit_decimal decimal;
   unit_encoding encoding;
   unit_round round;
   unit_sign sign;
   unit_async async;
+  unit_share share;
+  unit_cc cc;
+  int is_notpadded : 1;
+  int has_recl     : 1;
+  int readonly     : 1;
 }
 unit_flags;
 
diff --git a/libgfortran/io/list_read.c b/libgfortran/io/list_read.c
index 91ef8b5..a1dd840 100644
--- a/libgfortran/io/list_read.c
+++ b/libgfortran/io/list_read.c
@@ -1618,7 +1618,10 @@ read_real (st_parameter_dt *dtp, void * dest, int length)
 
  exp2:
   if (!isdigit (c))
-    goto bad_real;
+  {
+    push_char (dtp, '0');
+    goto done; /* Extension: exponent defaults to 1 when ommitted. */
+  }
   push_char (dtp, c);
 
   for (;;)
diff --git a/libgfortran/io/open.c b/libgfortran/io/open.c
index d9cfde8..c539a4d 100644
--- a/libgfortran/io/open.c
+++ b/libgfortran/io/open.c
@@ -48,6 +48,21 @@ static const st_option action_opt[] =
   { NULL, 0}
 };
 
+static const st_option share_opt[] =
+{
+  { "denyrw", SHARE_DENYRW },
+  { "denynone", SHARE_DENYNONE },
+  { NULL, 0}
+};
+
+static const st_option cc_opt[] =
+{
+  { "list", CC_LIST },
+  { "fortran", CC_FORTRAN },
+  { "none", CC_NONE },
+  { NULL, 0}
+};
+
 static const st_option blank_opt[] =
 {
   { "null", BLANK_NULL},
@@ -191,6 +206,14 @@ edit_modes (st_parameter_open *opp, gfc_unit * u, unit_flags * flags)
     generate_error (&opp->common, LIBERROR_BAD_OPTION,
 		    "Cannot change ACTION parameter in OPEN statement");
 
+  if (flags->share != SHARE_UNSPECIFIED && u->flags.share != flags->share)
+    generate_error (&opp->common, LIBERROR_BAD_OPTION,
+                    "Cannot change SHARE parameter in OPEN statement");
+
+  if (flags->cc != CC_UNSPECIFIED && u->flags.cc != flags->cc)
+    generate_error (&opp->common, LIBERROR_BAD_OPTION,
+                  "Cannot change CARRIAGECONTROL parameter in OPEN statement");
+
   /* Status must be OLD if present.  */
 
   if (flags->status != STATUS_UNSPECIFIED && flags->status != STATUS_OLD &&
@@ -326,6 +349,16 @@ new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags * flags)
   if (flags->status == STATUS_UNSPECIFIED)
     flags->status = STATUS_UNKNOWN;
 
+  if (flags->cc == CC_UNSPECIFIED)
+    flags->cc = flags->form == FORM_UNFORMATTED ? CC_NONE : CC_LIST;
+  else if (flags->form == FORM_UNFORMATTED && flags->cc != CC_NONE)
+    {
+      generate_error (&opp->common, LIBERROR_OPTION_CONFLICT,
+          "CARRIAGECONTROL parameter conflicts with UNFORMATTED form in "
+          "OPEN statement");
+      goto fail;
+    }
+
   /* Checks.  */
 
   if (flags->delim == DELIM_UNSPECIFIED)
@@ -726,6 +759,7 @@ st_open (st_parameter_open *opp)
   library_start (&opp->common);
 
   /* Decode options.  */
+  flags.readonly = !(cf & IOPARM_OPEN_HAS_READONLY) ? 0 : opp->readonly;
 
   flags.access = !(cf & IOPARM_OPEN_HAS_ACCESS) ? ACCESS_UNSPECIFIED :
     find_option (&opp->common, opp->access, opp->access_len,
@@ -735,6 +769,14 @@ st_open (st_parameter_open *opp)
     find_option (&opp->common, opp->action, opp->action_len,
 		 action_opt, "Bad ACTION parameter in OPEN statement");
 
+  flags.share = !(cf & IOPARM_OPEN_HAS_SHARE) ? SHARE_UNSPECIFIED :
+    find_option (&opp->common, opp->share, opp->share_len,
+                 share_opt, "Bad SHARE parameter in OPEN statement");
+
+  flags.cc = !(cf & IOPARM_OPEN_HAS_CC) ? CC_UNSPECIFIED :
+    find_option (&opp->common, opp->cc, opp->cc_len,
+                 cc_opt, "Bad CARRIAGECONTROL parameter in OPEN statement");
+
   flags.blank = !(cf & IOPARM_OPEN_HAS_BLANK) ? BLANK_UNSPECIFIED :
     find_option (&opp->common, opp->blank, opp->blank_len,
 		 blank_opt, "Bad BLANK parameter in OPEN statement");
diff --git a/libgfortran/io/read.c b/libgfortran/io/read.c
index f45e1b4..9e82d23 100644
--- a/libgfortran/io/read.c
+++ b/libgfortran/io/read.c
@@ -1056,7 +1056,7 @@ exponent:
      the d parameter before explict conversion takes place.  */
 
   if (w == 0)
-    goto bad_float;
+    goto done; /* Extension: exponent defaults to 1 when ommitted. */
 
   if (dtp->u.p.blank_status == BLANK_UNSPECIFIED)
     {
@@ -1220,7 +1220,8 @@ read_x (st_parameter_dt *dtp, int n)
       q = fbuf_getc (dtp->u.p.current_unit);
       if (q == EOF)
 	break;
-      else if (q == '\n' || q == '\r')
+      else if (dtp->u.p.current_unit->flags.cc != CC_NONE
+               && (q == '\n' || q == '\r'))
 	{
 	  /* Unexpected end of line. Set the position.  */
 	  dtp->u.p.sf_seen_eor = 1;
diff --git a/libgfortran/io/transfer.c b/libgfortran/io/transfer.c
index 5260be7..cd197ad 100644
--- a/libgfortran/io/transfer.c
+++ b/libgfortran/io/transfer.c
@@ -306,7 +306,8 @@ read_sf (st_parameter_dt *dtp, int * length)
       q = fbuf_getc (dtp->u.p.current_unit);
       if (q == EOF)
 	break;
-      else if (q == '\n' || q == '\r')
+      else if (dtp->u.p.current_unit->flags.cc != CC_NONE
+               && (q == '\n' || q == '\r'))
 	{
 	  /* Unexpected end of line. Set the position.  */
 	  dtp->u.p.sf_seen_eor = 1;
@@ -2415,6 +2416,9 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)
       u_flags.async = ASYNC_UNSPECIFIED;
       u_flags.round = ROUND_UNSPECIFIED;
       u_flags.sign = SIGN_UNSPECIFIED;
+      u_flags.share = SHARE_UNSPECIFIED;
+      u_flags.cc = CC_UNSPECIFIED;
+      u_flags.readonly = 0;
 
       u_flags.status = STATUS_UNKNOWN;
 
@@ -3035,6 +3039,9 @@ next_record_r (st_parameter_dt *dtp, int done)
   int bytes_left;
   char p;
   int cc;
+  unit_flags flags;
+
+  flags = dtp->u.p.current_unit->flags;
 
   switch (current_mode (dtp))
     {
@@ -3099,7 +3106,7 @@ next_record_r (st_parameter_dt *dtp, int done)
 	    } 
 	  break;
 	}
-      else 
+      else if (flags.cc != CC_NONE)
 	{
 	  do
 	    {
@@ -3288,8 +3295,11 @@ static void
 next_record_w (st_parameter_dt *dtp, int done)
 {
   gfc_offset m, record, max_pos;
+  unit_flags flags;
   int length;
 
+  flags = dtp->u.p.current_unit->flags;
+
   /* Zero counters for X- and T-editing.  */
   max_pos = dtp->u.p.max_pos;
   dtp->u.p.max_pos = dtp->u.p.skips = dtp->u.p.pending_spaces = 0;
@@ -3431,11 +3441,15 @@ next_record_w (st_parameter_dt *dtp, int done)
       else
 	{
 #ifdef HAVE_CRLF
-	  const int len = 2;
+	  static const int lflen = 2;
 #else
-	  const int len = 1;
+	  static const int lflen = 1;
 #endif
+          const int len = flags.cc == CC_NONE ? 0 : lflen;
           fbuf_seek (dtp->u.p.current_unit, 0, SEEK_END);
+          /* Skip newlines for CC_NONE */
+          if (flags.cc != CC_NONE)
+          {
           char * p = fbuf_alloc (dtp->u.p.current_unit, len);
           if (!p)
             goto io_error;
@@ -3443,6 +3457,7 @@ next_record_w (st_parameter_dt *dtp, int done)
           *(p++) = '\r';
 #endif
           *p = '\n';
+          }
 	  if (is_stream_io (dtp))
 	    {
 	      dtp->u.p.current_unit->strm_pos += len;
diff --git a/libgfortran/io/unix.c b/libgfortran/io/unix.c
index 8b9d7a7..63d97cd 100644
--- a/libgfortran/io/unix.c
+++ b/libgfortran/io/unix.c
@@ -1331,6 +1331,41 @@ regular_file (st_parameter_open *opp, unit_flags *flags)
   return fd;			/* failure */
 }
 
+/* Use fcntl to modify the given file descriptor based on flags.
+   Return value semantics are the same as fcntl.
+   Does not operate on stdin, stdout, or stderr. */
+
+static int
+open_fcntl (int fd, unit_flags *flags)
+{
+  int r = 0;
+  struct flock f;
+
+  if (fd == STDOUT_FILENO || fd == STDERR_FILENO || fd == STDIN_FILENO)
+    return 0;
+
+  f.l_start = 0;
+  f.l_len = 0;
+  f.l_whence = SEEK_SET;
+
+  switch (flags->share)
+  {
+    case SHARE_DENYNONE:
+      f.l_type = F_RDLCK;
+      r |= fcntl (fd, F_SETLK, &f);
+      break;
+    case SHARE_DENYRW:
+      f.l_type = F_WRLCK;
+      r |= fcntl (fd, F_SETLK, &f);
+      break;
+    case SHARE_UNSPECIFIED:
+    default:
+      break;
+  }
+
+  return r;
+}
+
 
 /* open_external()-- Open an external file, unix specific version.
  * Change flags->action if it is ACTION_UNSPECIFIED on entry.
@@ -1364,6 +1399,10 @@ open_external (st_parameter_open *opp, unit_flags *flags)
     return NULL;
   fd = fix_fd (fd);
 
+  /* Apply any required FCNTL calls to the file descriptor based on flags. */
+  if (open_fcntl (fd, flags) < 0)
+    return NULL;
+
   return fd_to_stream (fd);
 }
 
@@ -1632,6 +1671,38 @@ flush_all_units (void)
 }
 
 
+/* Apply any fcntls required based on the unit. */
+
+int
+close_fcntl (gfc_unit *u)
+{
+  int r = 0;
+  unix_stream *s = (unix_stream *)u->s;
+  int fd = s->fd;
+  struct flock f;
+
+  /* Unlock any OS-level locks. */
+  switch (u->flags.share)
+  {
+    case SHARE_DENYRW:
+    case SHARE_DENYNONE:
+      if (fd != STDOUT_FILENO && fd != STDERR_FILENO && fd != STDIN_FILENO)
+      {
+        f.l_start = 0;
+        f.l_len = 0;
+        f.l_whence = SEEK_SET;
+        f.l_type = F_UNLCK;
+        r = fcntl (fd, F_SETLK, &f);
+      }
+    case SHARE_UNSPECIFIED:
+    default:
+      break;
+  }
+
+  return r;
+}
+
+
 /* delete_file()-- Given a unit structure, delete the file associated
  * with the unit.  Returns nonzero if something went wrong. */
 
diff --git a/libgfortran/io/unix.h b/libgfortran/io/unix.h
index bf59a8e..a90869a 100644
--- a/libgfortran/io/unix.h
+++ b/libgfortran/io/unix.h
@@ -134,6 +134,9 @@ internal_proto(compare_file_filename);
 extern gfc_unit *find_file (const char *file, gfc_charlen_type file_len);
 internal_proto(find_file);
 
+extern int close_fcntl (gfc_unit *);
+internal_proto(close_fcntl);
+
 extern int delete_file (gfc_unit *);
 internal_proto(delete_file);
 
diff --git a/libgfortran/io/write.c b/libgfortran/io/write.c
index f17528e..e46a443 100644
--- a/libgfortran/io/write.c
+++ b/libgfortran/io/write.c
@@ -1547,7 +1547,7 @@ list_formatted_write_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,
   if (dtp->u.p.first_item)
     {
       dtp->u.p.first_item = 0;
-      write_char (dtp, ' ');
+      if (dtp->u.p.current_unit->flags.cc != CC_FORTRAN) write_char (dtp, ' ');
     }
   else
     {
diff --git a/libgfortran/libgfortran.h b/libgfortran/libgfortran.h
index f54edc0..a5dfe70 100644
--- a/libgfortran/libgfortran.h
+++ b/libgfortran/libgfortran.h
@@ -634,6 +634,9 @@ st_parameter_common;
 #define IOPARM_OPEN_HAS_SIGN		(1 << 21)
 #define IOPARM_OPEN_HAS_ASYNCHRONOUS	(1 << 22)
 #define IOPARM_OPEN_HAS_NEWUNIT		(1 << 23)
+#define IOPARM_OPEN_HAS_READONLY        (1 << 24)
+#define IOPARM_OPEN_HAS_SHARE           (1 << 25)
+#define IOPARM_OPEN_HAS_CC              (1 << 26)
 
 /* library start function and end macro.  These can be expanded if needed
    in the future.  cmp is st_parameter_common *cmp  */
